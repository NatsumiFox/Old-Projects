; ---------------------------------------------------------------------------

	rsreset
HwCh =		__rs
HwCh.bitfield:		rs.b 1		; bit7 - Active. Set if	running
					; bit6 - initialized. Clear if channel neers.b initialization
					; bit5 - music.	Set if running a music track. Else its sfx
					; bit4 - modulation. Set if we are modulating
					; bit3 - unk
					; bit2 - if releasing is finished
					; bit1 - resting. Set if rest is playing
					; bit0 - if releasing should be	started
HwCh.type:		rs.b 1
HwCh.MainVol:		rs.b 1
HwCh.instrument:	rs.b 1
HwCh.priority:		rs.b 1
HwCh.KeyOnOps:		rs.b 1
HwCh.SlotID:		rs.b 1
HwCh.notectr:		rs.b 1
HwCh.ModFreqFinal:	rs.w 1
HwCh.ModFreqFnLast:	rs.w 1
HwCh.CurrModFreq:	rs.w 1
HwCh.ModTrackTimer:	rs.b 1
HwCh.ModLoopCtr:	rs.b 1
HwCh.ModTrackAddr:	rs.w 1
HwCh.ModLoopAddr:	rs.w 1
HwCh.ModBaseFreq:	rs.w 1
HwCh.ModOffFreq:	rs.w 1
HwCh.ModFreqTgt:	rs.w 1
HwCh.ModSpeed:		rs.w 1
HwCh.LFOvol:		rs.b 1
HwCh.LFOoff:		rs.b 1
HwCh.LFOtimer:		rs.b 1
HwCh.LFOloopCtr:	rs.b 1
HwCh.LFOtrackAddr:	rs.w 1
HwCh.LFOloopAddr:	rs.w 1
HwCh.algorithm:		rs.b 1
HwCh.PanAF:		rs.b 1
HwCh.ModFreqOff:	rs.w 1
HwCh.CurrHwVol:		rs.b 1			; instrument TL
HwCh.PreHwVol:		rs.b 1			; previous TL
HwCh.EnvAddr:		rs.w 1			; previous Detune + Multiple
HwCh.EnvTimer:		rs.b 1			; previous table offset
HwCh.EnvTimerBack:	rs.b 1			; same data for	op3
HwCh.RelVolSpeed:	rs.b 1
HwCh.RelDestVol:	rs.b 1
HwCh.CurrChVol:		rs.b 1
HwCh.field_31:		rs.l 1		; same data for	op2
HwCh.field_35:		rs.b 3		; same data for	op4
HwCh.LFOtempoBack:	rs.b 1
HwCh.LFOtempo:		rs.b 1
HwCh.ModTempoBack:	rs.b 1
HwCh.ModTempo:		rs.b 1
HwCh.TempoAcc:		rs.b 1
HwCh.TempoTimer:	rs.b 1
HwCh.PanCtrl:		rs.b 1
HwCh.ModShiftCount:	rs.b 1

; ---------------------------------------------------------------------------

	rsreset
SlotCh =		__rs
SlotCh.bitfield:	rs.b 1			; bit7 - Active. Set if	running
					; bit6 - initialized. Clear if channel neers.b initialization
					; bit5 - Modulation. Set if performing frequency modulation
					; bit4 - No Attack flag? Seems rather strange way to do	it though. Maybe I am missing something
					; bit3 - unk
					; bit2 - unk
					; bit1 - unk
					; bit0 - Drum channel bit
SlotCh.loopoff:		rs.b 1
SlotCh.timer:		rs.w 1
SlotCh.timerback:	rs.w 1
SlotCh.TrackerAddr:	rs.w 1
SlotCh.section:		rs.b 1
SlotCh.Instrument:	rs.b 1
SlotCh.hwmask:		rs.b 1
SlotCh.TempoDiv:	rs.b 1
SlotCh.freq:		rs.w 1
SlotCh.volume:		rs.b 1
SlotCh.ModSpeedDiv:	rs.b 1
SlotCh.priority:	rs.b 1			; negative = music
SlotCh.Panning:		rs.b 1
SlotCh.notectr:		rs.b 1
SlotCh.notesplayed:	rs.b 1
SlotCh.loopdata:	rs.b 12		; all the loop data. 4 entries,	3 bytes	per entry.
					; first	2 bytes	are the	address, third byte is counter


;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2011 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: B3-432E-F558-21			    |
; |				Ilfak Guilfanov				    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	62778D1D3743B9762762867EE3BA6E68
; Input	CRC32 :	A61B8C49

; File Name   :	G:\disassemblies\MonsterBoyinMonsterWorld\sound.bin
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 1A77h Loaded length: 1A77h

; Processor	  : z80	[]
; Target assembler: Zilog Macro	Assembler

; ===========================================================================

; Segment type:	Pure code
;		segment	ROM

; =============== S U B	R O U T	I N E =======================================

; Wonder Boy in	Monster	World
; Wonder Boy V:	Monster	World III
; Westone sound	driver
; Disassembled by Natsumi and MarkeyJester 2017

sub_0:
		di
; End of function sub_0


; =============== S U B	R O U T	I N E =======================================


sub_1:					; DATA XREF: sub_1+69r

; FUNCTION CHUNK AT 003B SIZE 000000A8 BYTES

		im	1
		jp	init
; End of function sub_1

; ---------------------------------------------------------------------------
		dw ramstart

; =============== S U B	R O U T	I N E =======================================


FillRAM:				; CODE XREF: FillRAM+5j sub_1+46p ...
		ld	(hl), d		; load byte to RAM
		inc	hl		; inc addr
		dec	bc		; dec ctr
		ld	a, b		; copy b to a (upper byte of addr)
		zor	c		; or low byte
		jr	nz, FillRAM	; if nonzero, loop
		ret
; End of function FillRAM


; =============== S U B	R O U T	I N E =======================================


WritePartOp:				; CODE XREF: WriteGroupOps+5p
					; WriteGroupOps+6p ...
		rst	WriteChOp	; do for each channel in group
		rst	WriteChOp
		rst	WriteChOp
		inc	e		; next part
		ret
; End of function WritePartOp

; ---------------------------------------------------------------------------
		db 0FFh, 0FFh, 0FFh

; =============== S U B	R O U T	I N E =======================================


WriteChOp:				; CODE XREF: WritePartOpp
					; WritePartOp+1p ...
		ld	a, e		; copy e to a
		ld	b, d		; copy d to b
		call	WriteYMch
		inc	e
		ret
; End of function WriteChOp

; ---------------------------------------------------------------------------
		db 0FFh
; ---------------------------------------------------------------------------
		ex	(sp), hl
		dec	hl
		ex	(sp), hl
		jp	DebugStuff
; ---------------------------------------------------------------------------
		db 0FFh,0FFh
; ---------------------------------------------------------------------------
		ex	(sp), hl
		dec	hl
		ex	(sp), hl
		jp	DebugStuff
; ---------------------------------------------------------------------------
		db 0FFh,0FFh
; ---------------------------------------------------------------------------
		ex	(sp), hl
		dec	hl
		ex	(sp), hl
		jp	DebugStuff
; ---------------------------------------------------------------------------
		db 0FFh,0FFh

; =============== S U B	R O U T	I N E =======================================


vint:
		znop
		reti
; End of function vint

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_1

init:					; CODE XREF: sub_1+2j
		ld	hl, DebugAF	; get address to fill
		ld	sp, hl		; copy to stack
		ld	(hl), 0FFh	; first	byte is	0FFh
		inc	hl		; go to	next byte
		ld	bc, 0FFh	; fill FF bytes...
		ld	d, 0		; ...with 0
		rst	FillRAM
		ld	bc, 380h	; next 380h bytes...
		dec	d		; ...with FF
		rst	FillRAM
		ld	hl, ChannelRAM	; get channel RAM
		ld	de, 40h	; '@'   ; each ch is 40h bytes
		ld	b, 9		; 6 FM,	3 PSG

Init_StopCh:				; CODE XREF: sub_1+56j
		ld	(hl), d		; Stop running
		zadd	hl, de		; next ch
		djnz	Init_StopCh	; repeat for all chs
		ld	e, 20h ; ' '    ; 20 bytes per slot channel
		ld	b, 0Ah		; A slot channels

Init_StopSlots:				; CODE XREF: sub_1+5Ej
		ld	(hl), d		; stop channel
		zadd	hl, de		; next channel
		djnz	Init_StopSlots	; loop for all slots
		ld	hl,  SlotChannels+SlotCh.Panning ; panning of slot channels
		ld	b, 0Ah		; A slot channels

Init_SlotPan:				; CODE XREF: sub_1+67j
		ld	(hl), d		; clear pan control
		zadd	hl, de		; next channel
		djnz	Init_SlotPan	; loop for all slots
		ld	a, (2)		; Supposed to be immediate 1h. Fixed in	later versions!
		ld	(6000h), a	; high bit
		ld	l, 00000000b	; bank,	$00008000
		ld	b, 8		; 8 bits to load

Init_setbank:				; CODE XREF: sub_1+7Aj
		xor	a		; clear	a
		sla	l		; shift	bit from l to carry
		rla			; shift	it into	a
		ld	(6000h), a	; set next bit
		djnz	Init_setbank	; do 8 times
		ld	c, 0		; optimized later to bc
		ld	b, 2Bh ; '+'
		call	WriteYM1	; DAC disable
		ld	c, 0EDh	; 'í'   ; optimized later to bc
		ld	b, 26h ; '&'
		call	WriteYM1	; Set Timer B to 0EDh
		ld	a, 101010b
		ld	(YM27val), a	; save reg data	to RAM
		ld	c, a
		ld	b, 27h ; '''
		call	WriteYM1	; load,	enable & reset Timer B
		ld	hl, 7F11h	; PSG
		ld	(hl), 9Fh ; 'Ÿ' ; mute PSG
		ld	(hl), 0BFh ; '¿'
		ld	(hl), 0DFh ; 'ß'
		ld	(hl), 0FFh
		call	MuteFM		; Mute Mr FM
		call	InitChTypes	; init channel types
		ld	a, 1
		ld	(MusicSpeedCtrl), a ; load 1 to	here
		xor	a
		ld	(SndQueueAccess), a ; Give sound queue access to 68k

MainLoop:				; CODE XREF: sub_1+E0j
		xor	a
		ld	(TempoCount), a	; clear	quotient
		ld	a, 3		; run 3	times

ProcessHw:				; CODE XREF: sub_1+DBj
		ld	(MainLoopCtr), a ; save	counter
		call	SyncTimerB	; synchronise with YM timer B
		call	VolumeControl
		call	LoadSound
		ld	hl, (TempoAcc)	; get fraction
		ld	h, 0
		ld	de, (MainTempo)	; get main tempo to de
		zadd	hl, de		; add tempo to accumulator
		ld	(TempoAcc), hl	; save back
		ld	a, h		; get quotient
		ld	hl, TempoCount
		zadd	a, (hl)		; add a	to RAM
		ld	(hl), a		; ''
		call	ProcessHwChs	; process hardware channels
		ld	a, (MainLoopCtr) ; load	loop counter to	a
		dec	a		; decrement once
		jr	nz, ProcessHw	; if not zero, branch
		call	ProcessSlotChs	; process slot channels
		jr	MainLoop
; END OF FUNCTION CHUNK	FOR sub_1

; =============== S U B	R O U T	I N E =======================================


MuteFM:					; CODE XREF: sub_1+A0p
		ld	c, 0
		ld	d, 90h ; ''
		call	WriteAllChsOps	; SSG-EG
		dec	c
		ld	d, 80h ; '€'
		call	WriteAllChsOps	; D1L RR
		ld	b, 28h ; '('
		call	@keyoff		; key on/off

@keyoff:				; do for 1-3 and 4-6
		inc	c
		ld	e, 3		; do 3 times

@loop:					; CODE XREF: MuteFM+1Aj
		call	WriteYM1	; b = address
					; c = data
		inc	c		; increase channel ID
		dec	e		; decrement counter
		jr	nz, @loop	; if not 0, loop
		ret
; End of function MuteFM


; =============== S U B	R O U T	I N E =======================================


WriteAllChsOps:				; CODE XREF: MuteFM+4p	MuteFM+Ap
		xor	a		; part 1
		call	WriteGroupOps
		ld	a, 2		; part 2
; End of function WriteAllChsOps


; =============== S U B	R O U T	I N E =======================================


WriteGroupOps:				; CODE XREF: WriteAllChsOps+1p
		ld	(YMpartAddr), a	; save address
		ld	e, 0		; e is channel num
		rst	WritePartOp	; do 4 ops
		rst	WritePartOp
		rst	WritePartOp
		rst	WritePartOp
		ret
; End of function WriteGroupOps


; =============== S U B	R O U T	I N E =======================================

; Subroutine to	delay at the speed of the YM2612 timer

SyncTimerB:				; CODE XREF: sub_1+B8p	SyncTimerB+1Cj
		ld	a, (DebugZ80Access) ; check for	Z80 debug access?
		zor	a		; check	if 0
		call	nz, DebugStuff	; if not, do some weird	debug shite
		ld	hl, MusicSpeedCtrl ; get some sort of delay
		dec	(hl)		; dec 1	from it
		ret	nz		; if not 0, do not add delay
		ld	(hl), 1		; slow timer
		ld	a, (Paused)	; check	if speed up bit	is set
		zand	2		; ''
		jr	z, @tempogot	; branch if not	set
		ld	(hl), 4		; faster timer

@tempogot:				; CODE XREF: SyncTimerB+13j
		ld	a, (4000h)	; get YM stat
		zand	2		; is Timer B overflowed?
		jr	z, SyncTimerB	; if not, keep it looping
		ld	hl, (TimerBctr)	; get counter value
		inc	hl		; increase 1
		ld	(TimerBctr), hl	; save it
		ld	a, (YM27val)	; get the value	again
		ld	c, a
		ld	b, 27h ; '''
		jp	WriteYM1	; reset	timer
; End of function SyncTimerB


; =============== S U B	R O U T	I N E =======================================


InitChTypes:				; CODE XREF: sub_1+A3p
		call	MusFF_StopSounds
		ld	hl,  ChannelRAM+HwCh.type ; channel + 1
		ld	de, 40h	; '@'   ; 40h bytes per ch
		ld	b, 6		; 6 FM channels

@loopFM:				; CODE XREF: InitChTypes+Dj
		ld	(hl), d		; initialize as	FM
		zadd	hl, de		; next ch
		djnz	@loopFM		; loop for all FM
		ld	b, 3		; 3 PSG	channels

@loopUnk:				; CODE XREF: InitChTypes+14j
		ld	(hl), 2		; initialize as	PSG
		zadd	hl, de		; next ch
		djnz	@loopUnk	; loop for all chs
		ret
; End of function InitChTypes


; =============== S U B	R O U T	I N E =======================================

; Subroutine to	handle fading the volume

VolumeControl:				; CODE XREF: sub_1+BBp
		ld	a, (VolumeCtrl)	; load an override volume control
		zor	a		; is the volume	being controlled specifically and differently to normal	fading?
		jr	z, FadeControl	; if not, branch to check for standard fading
		ld	a, (VolumeCtrl+1) ; load the user controlled volume
		ld	(MasterVol), a	; set as master	volume
		ret
; ---------------------------------------------------------------------------

FadeControl:				; CODE XREF: VolumeControl+4j
		ld	a, (FadeCounter) ; load	counter
		zor	a		; has the counter already reached 0? (finished?)
		ret	z		; if so, return
		ld	hl, (FadeAmount) ; load	the current fade amount
		ld	de, (FadeSpeed)	; load the speed
		zadd	hl, de		; add speed to amount
		bit	7, h		; has the volume amount	passed 7F?
		jr	z, @ContFading	; if not, branch to keep fading
		bit	7, d		; is the speed going backwarrs.b (i.e. fading in)?
		call	z, StopMusicChs	; if not, stop the entire music	(finished fading)
		xor	a		; reset	volume and counter
		ld	(FadeCounter), a ; ''
		ld	(MasterVol), a	; ''
		ret
; ---------------------------------------------------------------------------

@ContFading:				; CODE XREF: VolumeControl+1Cj
		ld	(FadeAmount), hl ; update amount
		ld	hl, FadeCounter	; load the fade	amount
		dec	(hl)		; decrease fade	counter
		ret	nz		; if it	hasn't finished, branch
		ld	de, (FadeListPos) ; load fade list position
		ld	a, (de)		; load the counter first
		inc	de
		ld	(hl), a		; reset	fade counter
		ex	de, hl
		ld	e, (hl)		; load the speed
		inc	hl		; ''
		ld	d, (hl)		; ''
		inc	hl		; ''
		ld	(FadeListPos), hl ; update list
		ld	(FadeSpeed), de	; set the speed
		ret
; End of function VolumeControl


; =============== S U B	R O U T	I N E =======================================


LoadSound:				; CODE XREF: sub_1+BEp
		ld	a, 0FFh		; no access
		ld	(SndQueueAccess), a ; save to flag
		ld	a, (SndQueueCount) ; get queue counter
		zor	a		; check	if empty
		jr	nz, @notempty	; branch if not
		ld	(SndQueueAccess), a ; allow access
		ret
; ---------------------------------------------------------------------------

@notempty:				; CODE XREF: LoadSound+9j
		dec	a		; sub 1	from count
		ld	(SndQueueCount), a ; save count
		ld	a, (SndQueuePos) ; get position
		ld	e, a		; copy offset to e
		ld	d, 0		; upper	byte is	cleared
		ld	hl, SndQueue	; get sound queue to hl
		zadd	hl, de		; add offset to	hl
		inc	a		; next slot
		zand	0Fh		; keep in range
		ld	(SndQueuePos), a ; save	back in
		ld	c, (hl)		; get sound ID
		xor	a		; clear	a
		ld	(SndQueueAccess), a ; 68k has access
		ld	a, c		; copy c back to a
		cp	0FAh		; check	if FA or higher
		jr	c, LoadMusicSFX	; if not a flag, branch(?)
		cpl			; not a
		zadd	a, a		; double value
		ld	e, a		; copy to low byte of e
		ld	hl, MusicCommands ; get	table
		zadd	hl, de		; advance to correct entry
		ld	a, (hl)		; load first byte to a
		inc	hl		; next byte
		ld	h, (hl)		; load to h
		ld	l, a		; then load lower byte to l
		jp	(hl)		; jump to sub
; ---------------------------------------------------------------------------

LoadMusicSFX:				; CODE XREF: LoadSound+2Bj
		cp	58h		; 58h or less
		ret	nc		; if lower, return
		zadd	a, a		; double value
		ld	e, a		; copy to e
		ld	hl, mus		; get offset to	read from
		zadd	hl, de		; add value*2
		ld	a, (hl)		; load low byte
		inc	hl		; inc to high
		ld	h, (hl)		; load high byte to h
		ld	l, a		; copy a to h
		ld	a, (hl)		; get byte from	hl
		inc	hl		; go to	next byte
		ld	(Priority), a	; used later to	set ch+10h
		zor	a		; check	if negative
		jp	p, @loadsfx	; if not, branch
		xor	a		; clear	a
		ld	(FadeAmount), a
		ld	(MasterVol), a
		ld	(FadeCounter), a
		ld	(VolumeCtrl), a
		ld	e, (hl)		; load low byte
		inc	hl
		ld	d, (hl)		; load high byte
		inc	hl
		ld	(MainTempo), de	; save the word	to here
		push	hl		; push hl to stack
		ld	hl, 0
		ld	(TempoAcc), hl	; clear	this var
		call	StopMusicChs	; stop music
		pop	hl		; restore hl
		ld	ix, SlotChannels ; get slot channel RAM	into ix
		ld	bc, 20h	; ' '   ; 20h bytes per ch

@chloop:				; CODE XREF: LoadSound+8Fj
		ld	e, (hl)		; get low byte of offset
		inc	hl
		ld	d, (hl)		; get high byte	of offset
		ld	a, e		; copy e to a
		zor	d		; check	if d and e are 0
		ret	z		; if so, return	now
		inc	hl
		ld	(ix+SlotCh), 80h ; '€' ; set channel active
		ld	a, (Priority)	; copy first byte to a
		ld	(ix+SlotCh.priority), a	; copy to priority
		ld	(ix+SlotCh.TrackerAddr), e ; store tracker address
		ld	(ix+SlotCh.TrackerAddr+1), d ; ''
		zadd	ix, bc		; next ch
		jr	@chloop
; ---------------------------------------------------------------------------

@loadsfx:				; CODE XREF: LoadSound+4Cj
		push	hl
		call	StopSamePrioChs	; if channels have same	priority, stop them
		pop	hl

@chnloop:				; CODE XREF: LoadSound+BCj
					; LoadSound+D7j
		ld	a, (hl)		; load a byte
		cp	0FFh		; check	if it is FF (end of list)
		ret	z		; if so, return
		inc	hl
		rrca			; Warning! Complex shit, do not	bother,	it works, tried	it.
		rrca			; 7 -> E0
		rrca			; shift	thrice right
		ld	d, a		; copy to d
		zand	0E0h ; 'à'      ; clear all other bits
		ld	e, a		; copy a to e
		ld	a, d		; copy d to a
		zand	7		; get 3	low bits only
		ld	d, a		; save back to d
		ld	ix, SlotChannels ; get channel RAM
		zadd	ix, de		; basically adrs.b value*20h to ix. Does some complex shit because it does bytes of de separately! Trust me.
		bit	7, (ix+SlotCh)	; check	if running
		jr	z, @loadch	; if not, branch
		ld	a, (Priority)	; get priority
		cp	(ix+SlotCh.priority) ; compare with ones from ch
		jr	nc, @loadandstop ; branch if channel has lower priority
		inc	hl
		inc	hl		; skip 2 bytes
		jr	@chnloop	; check	next channel
; ---------------------------------------------------------------------------

@loadandstop:				; CODE XREF: LoadSound+B8j
		push	hl
		call	StopHwCh	; stop the channel
		pop	hl

@loadch:				; CODE XREF: LoadSound+B0j
		ld	(ix+SlotCh), 80h ; '€' ; set ch as active
		ld	a, (Priority)	; get priority
		ld	(ix+SlotCh.priority), a	; put it in
		ld	a, (hl)		; load upper byte
		inc	hl
		ld	(ix+SlotCh.TrackerAddr), a ; set tracker address
		ld	a, (hl)		; load lower byte
		inc	hl
		ld	(ix+7),	a	; set tracker address
		jr	@chnloop
; End of function LoadSound

; ---------------------------------------------------------------------------
MusicCommands:	dw MusFF_StopSounds, MusFE_FadeQuick, MusFD_Unpause, MusFC_PauseMusic
					; DATA XREF: LoadSound+30o
		dw MusFB_OverrideVol, MusFA_FadeSlow
; ---------------------------------------------------------------------------
		ret
; ---------------------------------------------------------------------------

MusFB_OverrideVol:			; DATA XREF: ROM:MusicCommandso
		ld	a, 1
		ld	(VolumeCtrl), a	; do not fade, 68k control master volume
		ret
; ---------------------------------------------------------------------------

MusFA_FadeSlow:				; DATA XREF: ROM:MusicCommandso
		ld	hl, FadeListSlow
		jr	SetFading
; ---------------------------------------------------------------------------
FadeListSlow:	db 80h			; DATA XREF: ROM:MusFA_FadeSlowo
					; num of frames	to fade
		dw 10h			; speed
		db 80h
		dw 18h
		db 0FFh
		dw 20h
		db 0FFh
		dw 40h
		db 0FFh
		dw 80h
; ---------------------------------------------------------------------------

MusFE_FadeQuick:			; DATA XREF: ROM:MusicCommandso
		ld	hl, FadeListQuick

SetFading:				; CODE XREF: ROM:028Bj
		ld	(FadeListPos), hl ; save fade list
		ld	hl, 0		; clear	speed and volume
		ld	(FadeSpeed), hl	; ''
		ld	(VolumeCtrl), hl ; ''
		ld	a, 1		; set counter to decrease to 0 immediately
		ld	(FadeCounter), a ; ''
		ret
; ---------------------------------------------------------------------------
FadeListQuick:	db 20h			; DATA XREF: ROM:MusFE_FadeQuicko
					; number of frames to fade by
		dw 40h			; fade speed
		db 20h			; ''
		dw 60h			; ''
		db 0FFh			; ''
		dw 80h			; ''
; ---------------------------------------------------------------------------

MusFC_PauseMusic:			; DATA XREF: ROM:MusicCommandso
		ld	ix, SlotChannels ; get ch ram
		xor	a		; clear	a

@chloop:				; CODE XREF: ROM:02DAj
		ld	(SlotCounter), a ; set channel num
		bit	7, (ix+SlotCh)	; check	if running
		jr	z, @norun	; if not, branch
		bit	7, (ix+SlotCh.priority)	; check	if this	is a music track
		call	nz, StopHwCh	; If is, then stop it

@norun:					; CODE XREF: ROM:02C6j
		ld	de, 20h	; ' '   ; get ch size
		zadd	ix, de		; go to	next slot
		ld	a, (SlotCounter) ; reload a
		inc	a		; increase ch num by 1
		cp	0Ah		; check	if this	was the	last channel
		jr	c, @chloop	; if not, loop
		ld	hl, Paused	; load paused flag
		zset	0, (hl)		; set as paused
		ret
; ---------------------------------------------------------------------------

MusFD_Unpause:				; DATA XREF: ROM:MusicCommandso
		ld	hl, Paused	; load paused flag
		res	0, (hl)		; unpause
		ret
; ---------------------------------------------------------------------------

GetChID20:				; CODE XREF: StopHwChp
		push	ix		; divides the channel offset from 20h to ID
		pop	hl		; load ix to hl
		ld	bc, -1EC0h	; -chRAM
		zadd	hl, bc		; get the channel offset
		ld	a, h		; load high byte
		rlca			; rotate left by 3
		rlca
		rlca
		ld	c, a		; store	a to c
		ld	a, l		; get low byte to a
		rlca			; rotate left by 3
		rlca
		rlca
		zor	c		; or result with c
		ret

; =============== S U B	R O U T	I N E =======================================


StopHwCh:				; CODE XREF: LoadSound+BFp ROM:02CCp ...
		call	GetChID20	; divides the channel offset from 20h to ID
		push	ix		; store	ix
		ld	ix, ChannelRAM	; get some other RAM
		ld	b, 9		; 9 channels

@loopch:				; CODE XREF: StopHwCh+22j
		bit	7, (ix+0)	; check	if running
		jr	z, @nextch	; if not, branch
		cp	(ix+6)		; check	if its the same	ID
		jr	nz, @nextch	; if not, branch
		ld	c, a		; load offset to c
		push	bc		; store	bc
		call	StopChPtr	; stop the channel
		pop	bc		; pop offset
		ld	a, c		; put c	back to	a

@nextch:				; CODE XREF: StopHwCh+Fj StopHwCh+14j
		ld	de, 40h	; '@'   ; channel size
		zadd	ix, de		; add offset
		djnz	@loopch		; loop for all chs
		pop	ix		; pop ix
		ret
; End of function StopHwCh


; =============== S U B	R O U T	I N E =======================================


StopMusicChs:				; CODE XREF: VolumeControl+20p
					; LoadSound+6Bp
		ld	ix, SlotChannels ; later drivers also clears fading stuff and unpauses music
		ld	b, 0Ah		; A channels

@chloop:				; CODE XREF: StopMusicChs+20j
		bit	7, (ix+SlotCh)	; check	if running
		jr	z, @nextch	; if not, branch
		bit	7, (ix+SlotCh.priority)	; check	if this	is music
		jr	z, @nextch	; if not music,	branch
		push	bc		; store	bc
		call	StopHwCh
		pop	bc		; pop bc
		ld	(ix+SlotCh), 0	; stop channel

@nextch:				; CODE XREF: StopMusicChs+Aj
					; StopMusicChs+10j
		ld	de, 20h	; ' '   ; channel size
		zadd	ix, de		; go to	next ch
		djnz	@chloop		; loop for all chs
		ret
; End of function StopMusicChs


; =============== S U B	R O U T	I N E =======================================


StopSamePrioChs:			; CODE XREF: LoadSound+92p
		ld	ix, SlotChannels ; get channel RAM to ix
		ld	b, 0Ah		; A channels

@chloop:				; CODE XREF: StopSamePrioChs+22j
		bit	7, (ix+SlotCh)	; check	if running
		jr	z, @nextch	; if not, branch
		ld	a, (Priority)	; get priority
		cp	(ix+SlotCh.priority) ; check if	it matches
		jr	nz, @nextch	; if not, go to	next ch
		push	bc		; store	bc
		call	StopHwCh
		pop	bc		; pop bc
		ld	(ix+SlotCh), 0	; stop running

@nextch:				; CODE XREF: StopSamePrioChs+Aj
					; StopSamePrioChs+12j
		ld	de, 20h	; ' '   ; channel size
		zadd	ix, de		; go to	next ch
		djnz	@chloop		; loop for all chs
		ret
; End of function StopSamePrioChs


; =============== S U B	R O U T	I N E =======================================


MusFF_StopSounds:			; CODE XREF: InitChTypesp
					; DATA XREF: ROM:MusicCommandso
		ld	ix, SlotChannels ; get slot channel RAM
		ld	b, 0Ah		; A slot chs

@chloop:				; CODE XREF: MusFF_StopSounds+1Aj
		bit	7, (ix+SlotCh)	; check	if running
		jr	z, @nextch	; if not, branch
		push	bc
		call	StopHwCh	; stop hardware	channel
		pop	bc
		ld	(ix+SlotCh), 0	; stop running

@nextch:				; CODE XREF: MusFF_StopSounds+Aj
		ld	de, 20h	; ' '   ; prepare size of each ch
		zadd	ix, de		; go ot	next ch
		djnz	@chloop		; run for all A	channels
		ld	hl, 0		; clear	hl
		ld	(VolumeCtrl), hl ; stop	any volume control
		xor	a
		ld	(FadeCounter), a ; stop	fading counter
		ld	(MasterVol), a	; reset	master vol
		ret
; End of function MusFF_StopSounds


; =============== S U B	R O U T	I N E =======================================


GetLowPrioHwCh:				; CODE XREF: PlayNoteFreeCh+2Ep
					; PlayNoteFreeCh+EBp
		ld	a, (Temp_Section) ; load low byte of value
		ld	e, a		; copy to e
		rrca
		zadd	a, e		; multiply by 1.5
		ld	e, a		; put in e
		ld	d, 0		; DE = offset in table
		ld	hl, SectionList	; table
		zadd	hl, de		; get table+offset to hl
		ld	e, (hl)		; load channel RAM address
		inc	hl
		ld	d, (hl)		; ''
		inc	hl
		push	de
		pop	iy		; iy = channel RAM address
		ld	a, (Temp_ChMask) ; load	channel	mask
		zand	(hl)		; and 3Fh
		ld	c, a		; copy to c
		ld	b, 80h ; '€'    ; prepare some check value
		ld	de, 40h	; '@'   ; prepare channel size

@NextChan:				; CODE XREF: GetLowPrioHwCh+60j
		bit	0, c		; check	if lsb is set
		jr	z, @SkipChan	; if not, branch
		bit	7, (iy+HwCh)	; check	if channel is running
		ret	z		; if it	isn't, return (found channel!)
		ld	a, (Temp_Priority) ; load priority
		cp	(iy+HwCh.priority) ; is	the hardware channel playing something of higher priority?
		jr	c, @SkipChan	; if so, branch
		bit	7, b		; check	if last	channel	was music
		jr	nz, @validch	; if was, branch
		ld	a, b		; load b to a
		cp	(iy+HwCh.priority) ; check if this channel has higher priority
		jr	c, @SkipChan	; branch if a is lower
		jr	nz, @validch	; branch if not	same
		ld	a, (Temp_Tempo+1) ; load high byte of tempo
		cp	(iy+HwCh.TempoTimer) ; check against hw	tempo
		jr	c, @validch	; branch if temp tempo is lower
		jr	nz, @SkipChan	; branch if they dont match
		ld	a, (Temp_Tempo)	; get second byte
		cp	(iy+HwCh.TempoAcc) ; compare
		jr	nc, @SkipChan	; branch if temp tempo is higher

@validch:				; CODE XREF: GetLowPrioHwCh+31j
					; GetLowPrioHwCh+39j ...
		ld	l, (iy+HwCh.TempoAcc) ;	hl = hw	tempo
		ld	h, (iy+HwCh.TempoTimer)
		ld	(Temp_Tempo), hl ; save	temporary tempo
		ld	b, (iy+HwCh.priority) ;	load priority
		push	iy
		pop	hl		; get iy to hl

@SkipChan:				; CODE XREF: GetLowPrioHwCh+20j
					; GetLowPrioHwCh+2Dj ...
		zadd	iy, de		; advance to next channel
		srl	c		; shift	next channel bit to carry
		jr	nz, @NextChan	; if there are still more channels to check, branch
		bit	7, b		; check	if the channel we found	is music
		ret	nz		; if so, return
		push	hl		; store	channel	in stack
		ex	(sp), ix	; swap hl with ix
		call	StopChPtr	; stop channel
		ex	(sp), ix	; swap slot channel back into ix
		pop	iy		; and hw channel into iy
		xor	a		; clear	a (set z)
		ret
; End of function GetLowPrioHwCh

; ---------------------------------------------------------------------------
SectionList:	dw ChannelRAM		; DATA XREF: GetLowPrioHwCh+9o
					; section 0 - 6	FM channels
		db 3Fh			; and value
		dw ChannelRAM+180h	; section 1 - 3	PSG channels
		db 7
		dw ChannelRAM+200h	; section 2 - PSG4
		db 1

; =============== S U B	R O U T	I N E =======================================


FindChNoteHw:				; CODE XREF: PlayNoteFreeCh+5Cp
					; PlayNoteFreeCh+C3p
		ld	a, (ix+SlotCh.notectr) ; get note counter
		zsub	(ix+SlotCh.notesplayed)	; sub the number of notes played last frame
		ld	c, a		; copy to c
		ld	iy, ChannelRAM	; get hw channel RAM
		ld	de, 40h	; '@'   ; 40 bytes per ch
		ld	b, 9		; 9 total chs

@chloop:				; CODE XREF: FindChNoteHw+25j
		bit	7, (iy+HwCh)	; check	if running
		jr	z, @nextch	; if not, branch
		ld	a, (SlotCounter) ; get slot ch
		cp	(iy+HwCh.SlotID) ; check if this is the	same ch
		jr	nz, @nextch	; if not, branch
		ld	a, c		; copy c to a
		cp	(iy+HwCh.notectr) ; check if this is the next note to be replaced
		ret	z		; if is, return	(carry clear)

@nextch:				; CODE XREF: FindChNoteHw+14j
					; FindChNoteHw+1Cj
		zadd	iy, de		; go to	next channel
		djnz	@chloop		; loop for all chs
		scf			; set carry
		ret			; return (carry	set)
; End of function FindChNoteHw


; =============== S U B	R O U T	I N E =======================================

; divides the channel offset from 40h to ID

GetChID40:				; CODE XREF: StopChPtrp
		push	ix		; push ix
		pop	hl		; get ix to hl
		ld	bc, -1C80h	; -FM1RAM
		zadd	hl, bc		; get offset only
		ld	a, h		; copy high byte to a
		rlca
		rlca			; shift	left twice
		ld	h, a		; store	back to	h
		ld	a, l		; get low byte to a
		rlca
		rlca			; shift	left twice
		zor	h		; or the results
		ret
; End of function GetChID40


; =============== S U B	R O U T	I N E =======================================


StopChPtr:				; CODE XREF: StopHwCh+18p
					; GetLowPrioHwCh+68p ...
		call	GetChID40	; get ch ID
		cp	6		; check	against	6
		jr	c, @FM		; if lower than	6
		zsub	6		; make 0-based
		ld	(ChannelID), a	; save ID
		jr	StopCh
; ---------------------------------------------------------------------------

@FM:					; CODE XREF: StopChPtr+5j
		srl	a		; divide by 2 and save last bit	to carry
		ld	(ChannelID), a	; save... ID?
		ld	a, 0		; clear	a
		rla			; load the bit from carry
		rlca			; mul by 2
		ld	(YMpartAddr), a	; set part

StopCh:					; CODE XREF: StopChPtr+Cj
					; ProcessHwCh+32j ...
		ld	a, (ix+HwCh.type) ; load channel type
		zsub	2		; sub 2
		jr	c, StopChFM	; if its FM, branch
		jr	nz, StopChPSG	; branch if not	2
		ld	(ix+HwCh.PreHwVol), 78h	; 'x' ; load mute value to previous volume
		ld	a, (ChannelID)	; get channel ID
		rrca
		rrca
		rrca			; align	to PSG channel ID
		zor	9Fh ; 'Ÿ'       ; set volume to mute (F)
		ld	(7F11h), a	; push to PSG
		ld	(ix+HwCh), 0	; stop channel
		ret
; ---------------------------------------------------------------------------

StopChPSG:				; CODE XREF: StopChPtr+21j
		ld	a, 78h ; 'x'    ; load mute value
		ld	(VolPSG4), a	; save to some PSG4 flag
		ld	a, 0FFh		; mute PSG4
		ld	(7F11h), a	; ''
		ld	(ix+HwCh), 0	; stop channel
		ret
; ---------------------------------------------------------------------------

StopChFM:				; CODE XREF: StopChPtr+1Fj
		ld	c, 0FFh		; Total	level to FF
		ld	b, 80h ; '€'    ; op1
		call	WriteYMchRAM
		ld	b, 84h ; '„'    ; op2
		call	WriteYMchRAM
		ld	b, 88h ; 'ˆ'    ; op3
		call	WriteYMchRAM
		ld	b, 8Ch ; 'Œ'    ; op4
		call	WriteYMchRAM
		bit	1, (ix+HwCh)	; check	if resting
		jr	nz, @nokey	; if so, branch
		xor	a		; clear	a
		call	KeyOffFM	; key off channel

@nokey:					; CODE XREF: StopChPtr+60j
		ld	(ix+HwCh), 0	; stop channel
		ret
; End of function StopChPtr


; =============== S U B	R O U T	I N E =======================================


LoadFreqFM:				; CODE XREF: WriteFrequency+4Dp
		ld	a, d
		rlca
		rlca
		rlca
		rlca
		ld	d, a
		ld	a, e
		rrca
		rrca
		rrca
		rrca
		zand	0Eh		; 0000 DDDD EEE0 0000 -> DDDD EEE0
		zor	d
		zadd	a, l		; add note to the table
		jr	nc, @nocarry	; check	if we went over	0
		inc	h		; add 100h to offset

@nocarry:				; CODE XREF: LoadFreqFM+Fj
		ld	l, a		; copy a back to l
		ld	a, (hl)		; get low byte of freq
		inc	hl
		ld	d, (hl)		; get high byte	of freq
		inc	hl
		ld	l, (hl)		; low byte of the next freq
		ld	h, e		; copy low byte	of freq	to h
		ld	e, a		; copy low byte	of new freq to e
		ld	a, l		; copy low byte	of next	freq to	a
		zsub	e		; sub low byte of new freq from	low bytre of new freq
		srl	a
		bit	4, h
		jr	z, loc_4DA
		ld	l, a
		zadd	a, e
		ld	e, a
		ld	a, l
		jr	nc, loc_4DA
		inc	d

loc_4DA:				; CODE XREF: LoadFreqFM+20j
					; LoadFreqFM+26j
		srl	a
		bit	3, h
		ret	z
		zadd	a, e
		ld	e, a
		ret	nc
		inc	d
		ret
; End of function LoadFreqFM


; =============== S U B	R O U T	I N E =======================================


LoadFreqPSG:				; CODE XREF: WriteFrequency+10p
		ld	a, d		; copy freq high byte to a
		rlca
		rlca
		rlca
		rlca			; shift	by a nibble
		ld	d, a		; save back
		ld	a, e		; get freq low byte to a
		rrca
		rrca
		rrca
		rrca			; shift	4 nibbles
		zand	0Eh		; keep in range
		zor	d		; put them together
		zadd	a, l		; add offset to	the table
		jr	nc, @nocarry	; if carry clear, branch
		inc	h		; add 100h to table

@nocarry:				; CODE XREF: LoadFreqPSG+Fj
		ld	l, a		; copy a back to l
		ld	a, (hl)		; load low byte	of freq
		inc	hl
		ld	d, (hl)		; load high byte
		inc	hl
		ld	l, (hl)		; load something else
		ld	h, e		; copy e to h
		ld	e, a		; copy a to e
		zsub	l		; sub l	from a
		srl	a		; shift	right once
		bit	4, h
		jr	z, loc_50C
		ld	l, a
		zadd	a, e
		ld	e, a
		ld	a, l
		jr	nc, loc_50C
		inc	d

loc_50C:				; CODE XREF: LoadFreqPSG+1Fj
					; LoadFreqPSG+25j
		srl	a
		bit	3, h
		ret	z
		zadd	a, e
		ld	e, a
		ret	nc
		inc	d
		ret
; End of function LoadFreqPSG


; =============== S U B	R O U T	I N E =======================================


GetFreqShift:				; CODE XREF: WriteFrequency+Ap
					; WriteFrequency+47p
		ld	a, d		; copy high byte of freq to a
		cp	60h ; '`'       ; check if lower than 60h
		jr	c, @nomax	; if so, branch
		ld	de, 0BF8h	; load max value?
		ld	c, 7		; set shift counter
		ret
; ---------------------------------------------------------------------------

@nomax:					; CODE XREF: GetFreqShift+3j
		ld	c, 0		; clear	shift counter
		cp	30h ; '0'       ; check if freq is 30h
		jr	c, @oc30	; if lower, branch
		zsub	30h ; '0'       ; sub 30h from freq
		zset	2, c		; add 4	to shift counter

@oc30:					; CODE XREF: GetFreqShift+Fj
		cp	18h		; check	if freq	is 18h
		jr	c, @oc18	; if lower, branch
		zsub	18h		; sub 18h from freq
		zset	1, c		; add 2	to shift counter

@oc18:					; CODE XREF: GetFreqShift+17j
		cp	0Ch		; check	if freq	is 0Ch
		jr	c, @ocC		; if lower, branch
		zsub	0Ch		; sub 0Ch from freq
		inc	c		; add 1	to shift counter

@ocC:					; CODE XREF: GetFreqShift+1Fj
		ld	d, a		; update d
		ret
; End of function GetFreqShift


; =============== S U B	R O U T	I N E =======================================


WriteFrequency:				; CODE XREF: ProcessHwCh:@isfmp
		ld	a, (ix+HwCh.type) ; get	channel	type
		zor	a		; check	if FM
		jr	z, WriteFreqFM	; if so, branch
		call	CheckFreqChg	; check	if frequency changed
		ret	z		; return if not. Else, de is frequency
		call	GetFreqShift	; get shift counter
		ld	hl, FreqPSG
		call	LoadFreqPSG
		ld	b, c		; copy c to b
		inc	b
		dec	b		; set the z flag
		jr	z, @noshift	; if c was 0, branch

@shift:					; CODE XREF: WriteFrequency+1Cj
		srl	d		; shift	right once
		rr	e		; shift	right, bring the lsb from carry	to msb
		djnz	@shift		; shift	num of times set by c

@noshift:				; CODE XREF: WriteFrequency+16j
		ld	a, e		; copy e to a
		zand	0Fh		; keep in range
		ld	c, a		; copy to c
		ld	a, (ChannelID)	; get channel ID
		rrca
		rrca
		rrca			; shift	channel	type in	place
		zor	c		; or 4 bits of frequency
		zor	80h ; '€'       ; set freq write
		ld	(7F11h), a	; put into PSG
		ld	a, e		; copy e to a
		zand	0F0h ; 'ð'      ; get high nibble
		srl	d		; get next bit of freq to carry
		rra			; shift	a right, get bit from carry
		srl	d		; and do that 2	times
		rra			; ''
		rrca			; shift	into place
		rrca			; ''
		ld	(7F11h), a	; put into PSG
		ret
; ---------------------------------------------------------------------------

WriteFreqFM:				; CODE XREF: WriteFrequency+4j
		call	CheckFreqChg	; check	if frequency changed
		ret	z		; return if not. Else, de is frequency
		ld	a, (ChannelID)	; get channel ID
		zadd	a, 0A4h	; '¤'   ; frequency MSB
		ld	b, a		; save into d
		call	GetFreqShift	; get frequency	shift counter
		ld	hl, FreqFM
		call	LoadFreqFM
		ld	a, c		; copy c to a
		rlca
		rlca
		rlca			; rotate 3 bits
		zor	d		; or d into a
		ld	c, a		; c is the octave?
		call	WriteYM		; write	into YM
		res	2, b		; A4 ->	A8
		ld	c, e		; load e
		jp	WriteYM		; write	to YM
; End of function WriteFrequency


; =============== S U B	R O U T	I N E =======================================


CheckLastFreq:				; CODE XREF: CheckFreqChg+Cp
		zand	0F8h ; 'ø'
		ld	e, a
		cp	l
		ret	nz
		ld	a, d
		cp	h
		ret
; End of function CheckLastFreq


; =============== S U B	R O U T	I N E =======================================


CheckFreqChg:				; CODE XREF: WriteFrequency+6p
					; WriteFrequency:WriteFreqFMp
		ld	a, (ix+HwCh.ModFreqFinal) ; get	final frequency	to send	to chip
		ld	d, (ix+9)
		ld	l, (ix+HwCh.ModFreqFnLast) ; get the last frequency sent to chip
		ld	h, (ix+0Bh)
		call	CheckLastFreq	; check	if last	frequency was same
		ret	z		; if was, return
		ld	(ix+HwCh.ModFreqFnLast), e ; save last frequency
		ld	(ix+0Bh), d
		ret
; End of function CheckFreqChg

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ProcessHwCh

UpdateVolume:				; CODE XREF: ProcessHwCh+21Dj
		ld	a, (ix+HwCh.type) ; get	channel	type
		zsub	2		; check	if its FM
		jr	c, UpdateFMVol	; if so, branch
		jr	nz, UpdatePSG4Vol ; if PSG4, branch
		ld	a, (ix+HwCh.bitfield) ;	load bitfield
		zand	20h ; ' '       ; check if is music
		jr	z, @nomaster	; branch if clear
		ld	a, (MasterVol)	; load master volume

@nomaster:				; CODE XREF: ProcessHwCh-18Ej
		zadd	a, (ix+HwCh.CurrHwVol) ; get hardware volume
		jp	p, @nomax	; check	if volume is positive
		ld	a, 7Fh ; ''    ; if not, force max vol

@nomax:					; CODE XREF: ProcessHwCh-186j
		zand	78h ; 'x'       ; clear unused bits
		cp	(ix+HwCh.PreHwVol) ; check if same as last hw vol
		ret	z		; if so, return
		ld	(ix+HwCh.PreHwVol), a ;	else update last hw vol	to match
		rrca			; shift	into place
		rrca
		rrca
		ld	c, a		; copy to c for	now
		ld	a, (ChannelID)	; get channel ID
		rrca			; rotate into place
		rrca
		rrca
		zor	90h ; ''       ; or volume update bits
		zor	c		; or volume
		ld	(7F11h), a	; put into PSG
		ret
; ---------------------------------------------------------------------------

UpdatePSG4Vol:				; CODE XREF: ProcessHwCh-195j
		ld	a, (VolPSG4)	; get PSG4 volume
		ld	b, a		; ''
		ld	a, (ix+HwCh)	; get bitfield
		zand	20h ; ' '       ; check for music
		jr	z, @masterno	; branch if not
		ld	a, (MasterVol)	; get master volume

@masterno:				; CODE XREF: ProcessHwCh-15Ej
		ld	c, a		; copy to c
		zadd	a, (ix+28h)
		jp	p, @nomaxvol
		ld	a, 7Fh ; ''    ; force to max

@nomaxvol:				; CODE XREF: ProcessHwCh-155j
		zand	78h ; 'x'       ; clear unused bits
		cp	b		; check	last volume
		ret	z		; if same, return
		ld	(VolPSG4), a	; copy last volume
		rrca			; rotate into place
		rrca
		rrca
		zor	0F0h ; 'ð'      ; or PSG4 and volume bits
		ld	(7F11h), a	; put into PSG
		ret
; ---------------------------------------------------------------------------

UpdateFMVol:				; CODE XREF: ProcessHwCh-197j
		call	GetSlotOpAddr	; get slot operator address
		ld	e, (hl)		; load to e
		ld	a, (ix+HwCh.MainVol) ; load main volume
		zadd	a, (ix+HwCh.LFOvol) ; add LFO volume
		ld	c, a		; store	to c
		ld	a, (ix+HwCh.bitfield) ;	load status
		zand	20h ; ' '       ; get only bit 5
		jr	z, @nomastervol	; if bit 5 is clear
		ld	a, (MasterVol)	; load master volume?

@nomastervol:				; CODE XREF: ProcessHwCh-130j
		zadd	a, c		; get total volume to a
		jp	po, @volcapno	; branch if positive
		ld	a, 7Fh ; ''    ; keep it in range

@volcapno:				; CODE XREF: ProcessHwCh-12Aj
		ld	(TempVol), a	; save volume for now
		push	ix		; push ix
		pop	hl		; put into hl
		ld	bc, HwCh.CurrHwVol ; get hardware volume to bc
		zadd	hl, bc		; add this channel's offset to it
		ld	d, b		; clear	d

@nextop:				; CODE XREF: ProcessHwCh-F2j
		ld	c, (hl)		; get the next byte to c
		inc	hl		; increase
		srl	e		; shift	op bit into carry
		jr	nc, @noupdate	; branch if not	slot op
		ld	a, (TempVol)	; get volume back
		zadd	a, c		; add op volume
		jp	p, @volnocap	; if positive, branch
		ld	a, 7Fh ; ''    ; cap volume

@volnocap:				; CODE XREF: ProcessHwCh-110j
		cp	(hl)		; check	the next byte
		jr	z, @noupdate	; branch if was	not changed
		ld	(hl), a		; save it
		ld	c, a		; copy a to c
		ld	a, d		; copy operator
		srl	a		; check	the lsb
		jr	nc, @gotpart	; if was not set, branch
		zor	2		; part 2

@gotpart:				; CODE XREF: ProcessHwCh-103j
		rlca			; 4 per	operator
		rlca
		zor	40h ; '@'       ; TL
		call	WriteYMchRAMa	; write	to YM

@noupdate:				; CODE XREF: ProcessHwCh-116j
					; ProcessHwCh-10Aj
		inc	hl
		inc	hl
		inc	hl		; increment hl 3 times
		inc	d		; next channel
		bit	2, d		; check	if all 4 ops are done
		jr	z, @nextop	; if not, branch
		ret
; END OF FUNCTION CHUNK	FOR ProcessHwCh

; =============== S U B	R O U T	I N E =======================================


GetSlotOpAddr:				; CODE XREF: ProcessHwCh:UpdateFMVolp
					; ProcessHwCh+31Fp
		ld	a, (ix+HwCh.algorithm) ; get algo
		zand	7		; keep in range
		zadd	a, SlotOperators&0FFh ;	slot op	low byte
		ld	l, a		; ''
		ld	h, SlotOperators>>8 ;	slot op	high byte
		ret	nc		; return
		inc	h		; useless
		ret			; useless
; End of function GetSlotOpAddr

; ---------------------------------------------------------------------------
SlotOperators:	db 1000b, 1000b, 1000b,	1000b, 1010b, 1110b ; DATA XREF: GetSlotOpAddr+5t
					; GetSlotOpAddr+8t
		db 1110b, 1111b

; =============== S U B	R O U T	I N E =======================================


DoInstrumentGroup:			; CODE XREF: ProcessHwCh+300p
					; ProcessHwCh+305p ...
		ld	(Temp_OpYM), a	; save operator	id
		ldi			; copy TL from instrument to channel
		inc	de		; skip channel byte
		ld	c, (hl)		; load DT + MUL
		inc	hl
		ld	a, (de)		; load saved value
		cp	c		; check	if its the same
		jr	z, @noDT	; if is, do not	update
		ld	a, c
		ld	(de), a		; save prev value
		ld	b, 30h ; '0'    ; YM Detune + Multiple
		call	WriteYMchRAMop

@noDT:					; CODE XREF: DoInstrumentGroup+Aj
		inc	de
		ld	a, (hl)		; load some offset
		inc	hl
		push	hl		; store	HL for now
		ld	l, a		; copy a to l
		ld	h, 0		; clear	h
		zadd	hl, hl		; double
		zadd	hl, hl		; quadruple
		ld	bc, InstrumentRateList
		zadd	hl, bc		; add table to offset
		ld	c, a
		ld	a, (de)		; check	previous table offset
		cp	c		; check	if it changed
		jr	nz, @updaterest	; if not, branch
		inc	de
		inc	hl		; skip over 3 bytes
		inc	hl
		inc	hl
		jr	@updatedecay
; ---------------------------------------------------------------------------

@updaterest:				; CODE XREF: DoInstrumentGroup+23j
		ld	a, c
		ld	(de), a		; save prev offset
		inc	de
		ld	c, (hl)		; load table byte
		inc	hl
		ld	b, 50h ; 'P'    ; YM Attack Rate + Rate Scale
		call	WriteYMchRAMop
		ld	c, (hl)		; load table byte
		inc	hl
		ld	b, 60h ; '`'    ; YM Decay Rate 1
		call	WriteYMchRAMop
		ld	c, (hl)		; load table byte
		inc	hl
		ld	b, 70h ; 'p'    ; YM Decay Rate 2
		call	WriteYMchRAMop

@updatedecay:				; CODE XREF: DoInstrumentGroup+29j
		ld	c, (hl)		; load table byte
		pop	hl		; get instrument back
		ld	b, 80h ; '€'    ; YM Decay Level 1 + Release Rate
; End of function DoInstrumentGroup


; =============== S U B	R O U T	I N E =======================================


WriteYMchRAMop:				; CODE XREF: DoInstrumentGroup+10p
					; DoInstrumentGroup+32p ...
		ld	a, (Temp_OpYM)	; get register offset
		zor	b		; or to	register
; End of function WriteYMchRAMop


; =============== S U B	R O U T	I N E =======================================


WriteYMchRAMa:				; CODE XREF: ProcessHwCh-FBp
					; ProcessHwCh+341p
		ld	b, a
; End of function WriteYMchRAMa


; =============== S U B	R O U T	I N E =======================================


WriteYMchRAM:				; CODE XREF: StopChPtr+4Ap
					; StopChPtr+4Fp ...
		ld	a, (ChannelID)
; End of function WriteYMchRAM


; =============== S U B	R O U T	I N E =======================================


WriteYMch:				; CODE XREF: WriteChOp+2p
		zor	b		; add channel to address
		ld	b, a		; copy back to b
; End of function WriteYMch


; =============== S U B	R O U T	I N E =======================================

; b = address
; c = data

WriteYM:				; CODE XREF: WriteFrequency+56p
					; WriteFrequency+5Cj
		ld	a, (YMpartAddr)
		push	hl
		ld	l, a
		ld	h, 40h ; '@'    ; get 4000 or 4002

@delay:					; CODE XREF: WriteYM+Bj
		ld	a, (4000h)	; get flags
		zor	a		; check	if busy
		jp	m, @delay	; if is, wait
		ld	(hl), b		; set address
		inc	l		; go to	data port
		jr	@wait

@wait:					; write	data to	addr
		ld	(hl), c
		pop	hl		; restore hl
		ret
; End of function WriteYM


; =============== S U B	R O U T	I N E =======================================


KeyOffFM:				; CODE XREF: StopChPtr+63p
					; ProcessHwCh+42j ...
		ld	b, 28h ; '('    ; key off/on
		ld	c, a		; copy a to c
		ld	a, (ChannelID)	; get ch id
		cp	3		; check	if lower than 3	(if so,	set carry)
		adc	a, 0FFh		; convert 456 to 012
		zor	c		; or c to a
		ld	c, a		; copy a to c
		ld	a, (YMpartAddr)	; get part addr
		bit	1, a		; check	if its 2
		jr	z, WriteYM1	; if not, branch
		zset	2, c		; else set to part 2 ch
; End of function KeyOffFM


; =============== S U B	R O U T	I N E =======================================

; b = address
; c = data

WriteYM1:				; CODE XREF: sub_1+80p	sub_1+87p ...
		ld	a, (4000h)	; get flags from YM
		zor	a		; test msb
		jp	m, WriteYM1	; jump if busy
		ld	a, b		; a = address
		ld	(4000h), a	; load address
		jr	@wait1

@wait1:
		jr	@wait2

@wait2:					; load data
		ld	a, c
		ld	(4001h), a	; put in YM
		ret
; End of function WriteYM1


; =============== S U B	R O U T	I N E =======================================


ProcessHwChs:				; CODE XREF: sub_1+D4p
		ld	ix, ChannelRAM	; get channel RAM to ix
		xor	a		; clear	a
		ld	(ModFreqBasePos), a ; clear

@dofmchs:				; CODE XREF: ProcessHwChs+2Cj
		ld	(ChannelID), a	; set channel ID
		xor	a		; clear	a

@dopt1pt2:				; CODE XREF: ProcessHwChs+24j
		ld	(YMpartAddr), a	; set part to 0	or 2
		bit	7, (ix+0)	; check	if running
		call	nz, ProcessHwCh	; if running, call this	sub
		ld	de, 40h	; '@'   ; prepare ch size
		zadd	ix, de		; go to	next channel
		ld	hl, ModFreqBasePos ; channel counter?
		inc	(hl)		; increment it once
		ld	a, (YMpartAddr)	; get the part
		xor	2		; swap parts
		jr	nz, @dopt1pt2	; if we	are on part 2, branch
		ld	a, (ChannelID)	; get channel ID
		inc	a		; increment
		cp	3		; check	if 3 or	higher
		jr	c, @dofmchs	; if not, branch
		xor	a		; reset	a

@dopsgchs:				; CODE XREF: ProcessHwChs+48j
		ld	(ChannelID), a	; clear	channel	ID
		bit	7, (ix+0)	; check	if running
		call	nz, ProcessHwCh	; if so, call this sub
		ld	de, 40h	; '@'   ; prepare ch size
		zadd	ix, de		; go to	next ch
		ld	hl, ModFreqBasePos ; get channel counter
		inc	(hl)		; increment
		ld	a, (ChannelID)	; get channel ID
		inc	a		; increment it
		cp	3		; check	if we have done	all PSG	channels
		jr	c, @dopsgchs	; if not, branch
		ret
; End of function ProcessHwChs


; =============== S U B	R O U T	I N E =======================================


ProcessHwCh:				; CODE XREF: ProcessHwChs+13p
					; ProcessHwChs+36p

; FUNCTION CHUNK AT 05BA SIZE 000000AD BYTES
; FUNCTION CHUNK AT 0A08 SIZE 000000FC BYTES

		bit	6, (ix+HwCh.bitfield) ;	check if its been initialized yet
		jr	nz, @initdone	; if yes, branch
		zset	6, (ix+HwCh.bitfield) ;	set initialization bit
		ld	hl, @initdone	; get routine
		push	hl		; run it last
		ld	a, (ix+HwCh.type) ; get	channel	type to	a
		zsub	2		; sub 2	from it
		jp	c, InitFM	; branch if FM
		jp	z, InitPSG	; branch if PSG
		jp	InitPSG4	; PSG4
; ---------------------------------------------------------------------------

@initdone:				; CODE XREF: ProcessHwCh+4j
					; DATA XREF: ProcessHwCh+Ao
		ld	a, 1		; a = 1
		bit	5, (ix+HwCh.bitfield) ;	check if this is music
		jr	z, @sfx		; if not, branch
		ld	a, (TempoAcc+1)	; get accumulated value	to a instead

@sfx:					; CODE XREF: ProcessHwCh+22j
		zadd	a, (ix+HwCh.TempoAcc) ;	add tempo accumulator
		ld	(ix+HwCh.TempoAcc), a ;	save it
		jr	nc, @nokeyoff	; if it	hasnt wrapped around, branch
		inc	(ix+HwCh.TempoTimer) ; increment some timer
		jp	z, StopCh	; if it	reached	0, branch
		jp	po, @nokeyoff	; if odd number, branch
		zset	0, (ix+HwCh.bitfield) ;	set release bit
		ld	a, (ix+HwCh.type) ; load type
		zor	a		; check	if FM
		jr	nz, @notfm	; if not, branch
		jp	KeyOffFM	; key off fm
; ---------------------------------------------------------------------------

@notfm:					; CODE XREF: ProcessHwCh+40j
		ld	a, (ix+HwCh.type) ; load type
		zor	a		; is it	an FM channel?
		call	z, KeyOffFM	; if so, key off FM

@nokeyoff:				; CODE XREF: ProcessHwCh+2Dj
					; ProcessHwCh+35j
		dec	(ix+HwCh.ModTempo) ; decrease timer
		jp	nz, @domodulation ; if it's still running, branch
		ld	a, (ix+HwCh.ModTempoBack) ; reset timer
		ld	(ix+HwCh.ModTempo), a ;	''
		ld	a, (ix+HwCh.ModBaseFreq) ; add frequency offset	to base	frequency
		zadd	a, (ix+HwCh.ModOffFreq)	; ''
		ld	(ix+HwCh.ModBaseFreq), a ; ''
		ld	a, (ix+HwCh.ModBaseFreq+1) ; ''
		adc	a, (ix+HwCh.ModOffFreq+1) ; ''
		ld	(ix+HwCh.ModBaseFreq+1), a ; ''
		ld	a, (ix+HwCh.ModTrackTimer) ; load tracker timer
		zor	a		; has it reached 0?
		jp	z, @domodulation ; if so, branch
		dec	(ix+HwCh.ModTrackTimer)	; dec tracker timer
		jp	nz, @domodulation ; if it hasn't JUST reached 0 now, branch
		ld	(ix+HwCh.ModShiftCount), 0 ; clear counter
		ld	l, (ix+HwCh.ModTrackAddr) ; load mod tracker addr
		ld	h, (ix+HwCh.ModTrackAddr+1) ;	''

@modtrackloop:				; CODE XREF: ProcessHwCh+94j
					; ProcessHwCh+9Bj ...
		ld	a, (hl)		; load value
		inc	hl		; advance address
		zor	a		; is it	0?
		jp	z, @domodulation ; if so, branch
		cp	0F8h		; is it	a flag?
		jr	c, @setmodoffset ; if not, branch
		cpl			; convert to positive
		dec	a		; minus	1
		jp	p, @modFE	; if it	wasn't FF, branch
		ld	a, (hl)		; load jump address
		inc	hl		; ''
		ld	h, (hl)		; ''
		ld	l, a		; ''
		jr	@modtrackloop	; loop
; ---------------------------------------------------------------------------

@modFE:					; CODE XREF: ProcessHwCh+8Dj
		jr	nz, @modFD
		dec	(ix+HwCh.ModLoopCtr) ; decrement loop ctr
		jr	z, @modtrackloop ; if 0, branch
		ld	l, (ix+HwCh.ModLoopAddr) ; load	loop address to	hl
		ld	h, (ix+HwCh.ModLoopAddr+1) ; ''
		jr	@modtrackloop
; ---------------------------------------------------------------------------

@modFD:					; CODE XREF: ProcessHwCh:@modFEj
		dec	a
		jr	nz, @modFC
		ld	a, (hl)		; load a byte
		inc	hl
		ld	(ix+HwCh.ModLoopCtr), a	; save as loop counter
		ld	(ix+HwCh.ModLoopAddr), l ; save	tracker	address
		ld	(ix+HwCh.ModLoopAddr+1), h ; ''
		jr	@modtrackloop
; ---------------------------------------------------------------------------

@modFC:					; CODE XREF: ProcessHwCh+A6j
		dec	a
		jr	nz, @modFB
		zsub	(ix+HwCh.ModOffFreq) ; negate modulation offset
		ld	(ix+HwCh.ModOffFreq), a	; save it in RAM
		ld	a, 0
		sbc	a, (ix+HwCh.ModOffFreq+1) ; sub with carry
		ld	(ix+HwCh.ModOffFreq+1), a ; save it in RAM
		ld	a, (hl)		; load timer/counter
		inc	hl
		jr	@setmodtimer
; ---------------------------------------------------------------------------

@modFB:					; CODE XREF: ProcessHwCh+B6j
		dec	a
		jr	nz, @modFA
		ld	a, (hl)		; load frequency
		inc	hl
		ld	(ix+HwCh.ModBaseFreq), a ; save	frequency
		ld	a, (hl)
		inc	hl
		ld	(ix+HwCh.ModBaseFreq+1), a ; ''
		jr	@modtrackloop
; ---------------------------------------------------------------------------

@modFA:					; CODE XREF: ProcessHwCh+CBj
		dec	a
		jr	nz, @modF9
		ld	(ix+HwCh.ModOffFreq), a	; clear	frequency offset
		ld	(ix+HwCh.ModOffFreq+1), a ; ''
		ld	(ix+HwCh.ModTrackTimer), a ; clear timer
		jr	@domodulation
; ---------------------------------------------------------------------------

@modF9:					; CODE XREF: ProcessHwCh+DAj
		dec	a
		jr	nz, @modF8
		ld	a, (hl)		; load timer
		inc	hl
		ld	(ix+HwCh.ModTempo), a ;	load tempo timer for modulation
		ld	(ix+HwCh.ModTempoBack),	a ; load tempo backup timer
		jr	@modtrackloop
; ---------------------------------------------------------------------------

@modF8:					; CODE XREF: ProcessHwCh+E8j
		xor	a
		ld	(ix+HwCh.ModOffFreq), a	; clear	modulation offset
		ld	(ix+HwCh.ModOffFreq+1), a ; ''
		ld	a, (hl)		; load byte from tracker
		inc	hl
		ld	(ix+HwCh.ModShiftCount), a ; set modulation shift counter
		ld	a, (hl)		; load timer/counter
		inc	hl
		jr	@setmodtimer
; ---------------------------------------------------------------------------

@setmodoffset:				; CODE XREF: ProcessHwCh+89j
		ld	c, (hl)		; set modulation offset
		inc	hl
		ld	(ix+HwCh.ModOffFreq), c	; ''
		ld	c, (hl)		; ''
		inc	hl
		ld	(ix+HwCh.ModOffFreq+1), c ; ''

@setmodtimer:				; CODE XREF: ProcessHwCh+C8j
					; ProcessHwCh+102j
		ld	(ix+HwCh.ModTrackTimer), a ; update timer/counter
		ld	(ix+HwCh.ModTrackAddr),	l ; update address
		ld	(ix+HwCh.ModTrackAddr+1), h ;	''

@domodulation:				; CODE XREF: ProcessHwCh+4Fj
					; ProcessHwCh+6Ej ...
		ld	l, (ix+HwCh.CurrModFreq) ; get current frequency
		ld	h, (ix+HwCh.CurrModFreq+1) ; ''
		bit	4, (ix+HwCh.bitfield) ;	check if we are	doing modulation
		jr	z, @nomods	; if not, branch
		ld	c, (ix+HwCh.ModSpeed) ;	get modulation speed
		ld	b, (ix+HwCh.ModSpeed+1) ; ''
		zadd	hl, bc		; add that to hl
		ld	e, (ix+HwCh.ModFreqTgt)	; load target frequency
		ld	d, (ix+HwCh.ModFreqTgt+1) ; ''
		ld	a, h		; copy high byte to a
		cp	d
		jr	nz, @notsame	; if are not same, branch
		ld	a, l		; copy low to a
		cp	e		; check	against	destination low	byte
		jr	z, @modend	; if same, branch

@notsame:				; CODE XREF: ProcessHwCh+132j
		bit	7, b		; check	if we are going	downwards
		jr	z, @forwards	; if not, branch
		ccf			; clear	carry

@forwards:				; CODE XREF: ProcessHwCh+13Aj
		jr	c, @savefreq	; if we	have not shot over the destination, branch
		ex	de, hl		; hl = destination

@modend:				; CODE XREF: ProcessHwCh+136j
		res	4, (ix+HwCh.bitfield) ;	clear modulation flag

@savefreq:				; CODE XREF: ProcessHwCh:@forwardsj
		ld	(ix+HwCh.CurrModFreq), l ; save	current	frequency
		ld	(ix+HwCh.CurrModFreq+1), h ; ''

@nomods:				; CODE XREF: ProcessHwCh+121j
		ld	a, (ix+HwCh.ModShiftCount) ; get mod shift counter
		zor	a		; check	if 0
		jr	z, @counter0	; if so, branch
		ld	b, a		; copy a to b
		push	hl
		call	CalcModFreqBase	; load shift counter
		pop	de
		ld	l, a		; copy shift counter to	l
		zand	80h ; '€'       ; check high bit
		jr	z, @nobit7	; if not negative, branch
		ld	a, 0FFh		; high byte = 0FFh

@nobit7:				; CODE XREF: ProcessHwCh+159j
		ld	h, a		; copy high byte to a

@shiftleft:				; CODE XREF: ProcessHwCh+15Fj
		zadd	hl, hl		; shift	hl left	once
		djnz	@shiftleft	; loop til done
		jr	@calcfreq
; ---------------------------------------------------------------------------

@counter0:				; CODE XREF: ProcessHwCh+14Ej
		ld	e, (ix+HwCh.ModBaseFreq) ; load	base frequency
		ld	d, (ix+HwCh.ModBaseFreq+1) ; ''

@calcfreq:				; CODE XREF: ProcessHwCh+161j
		zadd	hl, de		; add counter and something together
		ld	e, (ix+HwCh.ModFreqOff)	; load some frequency offset value
		ld	d, (ix+HwCh.ModFreqOff+1) ; ''
		zadd	hl, de		; add it to frequency
		ld	(ix+HwCh.ModFreqFinal),	l ; save freq
		ld	(ix+HwCh.ModFreqFinal+1), h ;	''
		dec	(ix+HwCh.LFOtempo) ; sub 1 from	LFO tempo timer
		jp	nz, @envfreqvol	; if not 0, branch
		ld	a, (ix+HwCh.LFOtempoBack) ; load stored	LFO tempo
		ld	(ix+HwCh.LFOtempo), a ;	reset LFO tempo	timer
		ld	a, (ix+HwCh.LFOvol) ; get volume
		zadd	a, (ix+HwCh.LFOoff) ; add volume offset
		ld	(ix+HwCh.LFOvol), a ; save volume
		ld	a, (ix+HwCh.LFOtimer) ;	get tracker timer
		zor	a		; check	if 0
		jr	z, @envfreqvol	; branch if so
		dec	(ix+HwCh.LFOtimer) ; else sub 1	from it
		jr	nz, @envfreqvol	; branch if not	reached	0
		ld	l, (ix+HwCh.LFOtrackAddr) ; load LFO tracker address
		ld	h, (ix+HwCh.LFOtrackAddr+1) ;	to hl

@LFOtrackerloop:			; CODE XREF: ProcessHwCh+1AFj
					; ProcessHwCh+1B6j ...
		ld	a, (hl)		; load tracker data
		inc	hl
		zor	a		; check	if 0
		jr	z, @envfreqvol	; branch if 0
		cp	0F9h		; check	if its a flag
		jr	c, @setLFOoffset ; if not, branch
		cpl			; convert to positive
		dec	a		; sub 1
		jp	p, @LFOFE	; branch if not	FF
		ld	a, (hl)		; load a byte
		inc	hl
		ld	h, (hl)		; load a byte
		ld	l, a		; hl = new address
		jr	@LFOtrackerloop
; ---------------------------------------------------------------------------

@LFOFE:					; CODE XREF: ProcessHwCh+1A8j
		jr	nz, @LFOFD	; branch if not	FE
		dec	(ix+HwCh.LFOloopCtr) ; decrement 1 from	loop counter
		jr	z, @LFOtrackerloop ; if	not z, branch
		ld	l, (ix+HwCh.LFOloopAddr) ; set current address to loop back point
		ld	h, (ix+HwCh.LFOloopAddr+1)
		jr	@LFOtrackerloop
; ---------------------------------------------------------------------------

@LFOFD:					; CODE XREF: ProcessHwCh:@LFOFEj
		dec	a
		jr	nz, @LFOFC	; branch if not	FD
		ld	a, (hl)		; get loop counter
		inc	hl
		ld	(ix+HwCh.LFOloopCtr), a	; save it to RAM
		ld	(ix+HwCh.LFOloopAddr), l ; save	loop position
		ld	(ix+HwCh.LFOloopAddr+1), h ; from current address
		jr	@LFOtrackerloop
; ---------------------------------------------------------------------------

@LFOFC:					; CODE XREF: ProcessHwCh+1C1j
		dec	a
		jr	nz, @LFOFB	; branch if not	FC
		xor	a
		zsub	(ix+HwCh.LFOoff) ; negate LFO
		ld	(ix+HwCh.LFOoff), a ; ''
		ld	a, (hl)		; read a timer value
		inc	hl
		jr	@setLFOtimer
; ---------------------------------------------------------------------------

@LFOFB:					; CODE XREF: ProcessHwCh+1D1j
		dec	a
		jr	nz, @LFOFA	; branch if not	FB
		ld	a, (hl)		; get a	byte
		inc	hl
		ld	(ix+HwCh.LFOvol), a ; save the volume
		jr	@LFOtrackerloop
; ---------------------------------------------------------------------------

@LFOFA:					; CODE XREF: ProcessHwCh+1DFj
		dec	a
		jr	nz, @LFOF9	; branch if not	FA
		xor	a
		ld	(ix+HwCh.LFOoff), a ; clear offset
		ld	(ix+HwCh.LFOtimer), a ;	clear timer
		jr	@envfreqvol
; ---------------------------------------------------------------------------

@LFOF9:					; CODE XREF: ProcessHwCh+1E9j
		ld	a, (hl)
		inc	hl
		ld	(ix+HwCh.LFOtempo), a ;	load tempo
		ld	(ix+HwCh.LFOtempoBack),	a ; ''
		jr	@LFOtrackerloop
; ---------------------------------------------------------------------------

@setLFOoffset:				; CODE XREF: ProcessHwCh+1A4j
		ld	c, (hl)		; load a byte
		inc	hl
		ld	(ix+HwCh.LFOoff), c ; save LFO offset

@setLFOtimer:				; CODE XREF: ProcessHwCh+1DCj
		ld	(ix+HwCh.LFOtimer), a ;	save timer value
		ld	(ix+HwCh.LFOtrackAddr),	l ; save tracker address
		ld	(ix+HwCh.LFOtrackAddr+1), h ;	''

@envfreqvol:				; CODE XREF: ProcessHwCh+17Aj
					; ProcessHwCh+190j ...
		ld	a, (ix+HwCh.type) ; get	channel	type into a
		zor	a		; check	if FM
		jr	z, @isfm	; if is, branch
		call	ProcessEnvelopes ; process envelopes
		bit	7, (ix+HwCh.bitfield) ;	check if running
		ret	z		; if not, branch

@isfm:					; CODE XREF: ProcessHwCh+210j
		call	WriteFrequency	; write	current	frequency
		jp	UpdateVolume	; write	current	volume
; End of function ProcessHwCh


; =============== S U B	R O U T	I N E =======================================


ProcessEnvelopes:			; CODE XREF: ProcessHwCh+212p
		bit	1, (ix+HwCh.bitfield) ;	check if resting
		jr	nz, @checkrelease ; if so, branch
		bit	0, (ix+HwCh.bitfield) ;	check if we are	releasing
		jr	z, @readenvelop	; if not, branch
		zset	1, (ix+HwCh.bitfield) ;	set resting
		ld	a, (ix+HwCh.RelDestVol)	; get release destination vol
		zor	a		; check	if its 0
		jr	z, @dorelease	; if so, branch
		cp	(ix+HwCh.CurrChVol) ; check if a is more than hardware volume
		jr	nc, @dorelease	; if so, branch
		zset	2, (ix+HwCh.bitfield) ;	stop releasing
		jr	@notimer
; ---------------------------------------------------------------------------

@checkrelease:				; CODE XREF: ProcessEnvelopes+4j
		bit	2, (ix+HwCh.bitfield) ;	check if releasing is done
		jr	nz, @notimer	; if yes, branch
		dec	(ix+HwCh.EnvTimer) ; decrement timer
		jr	nz, @notimer	; if not over, branch

@dorelease:				; CODE XREF: ProcessEnvelopes+14j
					; ProcessEnvelopes+19j
		ld	a, (ix+HwCh.CurrChVol) ; get channel volume
		zadd	a, (ix+HwCh.RelVolSpeed) ; add volume speed
		ld	c, (ix+HwCh.RelDestVol)	; load volume destination
		inc	c		; check	if its 0
		dec	c		; ''
		jr	nz, @notzero	; if not, branch
		zor	a		; check	if volume is negative
		jp	m, StopCh	; if so, stop channel
		jr	@noforce
; ---------------------------------------------------------------------------

@notzero:				; CODE XREF: ProcessEnvelopes+37j
		zor	a		; check	if volume is positive
		jp	p, @checkdest	; if so, branch
		jr	@forcevol	; force	volume
; ---------------------------------------------------------------------------

@checkdest:				; CODE XREF: ProcessEnvelopes+40j
		cp	c		; check	if volume reached destination
		jr	c, @noforce	; if not, branch

@forcevol:				; CODE XREF: ProcessEnvelopes+43j
		ld	a, c		; force	volume to dest
		zset	2, (ix+HwCh.bitfield) ;	stop releasing

@noforce:				; CODE XREF: ProcessEnvelopes+3Dj
					; ProcessEnvelopes+46j
		ld	c, (ix+HwCh.EnvTimerBack) ; get	envelope timer backup
		ld	(ix+HwCh.EnvTimer), c ;	save to	envelope timer
		jr	@nocap
; ---------------------------------------------------------------------------

@readenvelop:				; CODE XREF: ProcessEnvelopes+Aj
		ld	a, (ix+HwCh.EnvTimer) ;	get the	timer
		zor	a		; check	if its not running
		jr	z, @notimer	; if not, branch
		dec	(ix+HwCh.EnvTimer) ; decrement timer
		jr	nz, @notimer	; if not over, branch
		ld	l, (ix+HwCh.EnvAddr) ; load envelope address to	hl
		ld	h, (ix+HwCh.EnvAddr+1)
		ld	a, (hl)		; load next byte
		cp	0F0h ; 'ð'      ; check if volume is mute, and timer set to 0
		jp	z, StopCh	; if so, stop the channel
		inc	hl
		ld	c, a		; copy a to c
		zand	0Fh		; keep in range
		ld	(ix+HwCh.EnvTimer), a ;	set the	timer
		ld	(ix+HwCh.EnvAddr), l ; save envelope address
		ld	(ix+HwCh.EnvAddr+1), h ; ''
		ld	a, c		; load c back to a
		rrca			; shift	1 bit out of the way
		zand	78h ; 'x'       ; get only volume bits
		zadd	a, (ix+HwCh.MainVol) ; add main	volume
		jp	p, @nocap	; if positive, branch
		ld	a, 7Fh ; ''    ; cap volume

@nocap:					; CODE XREF: ProcessEnvelopes+53j
					; ProcessEnvelopes+80j
		ld	(ix+HwCh.CurrChVol), a ; save actual volume

@notimer:				; CODE XREF: ProcessEnvelopes+1Fj
					; ProcessEnvelopes+25j	...
		ld	a, (ix+HwCh.CurrChVol) ; load current volume
		zadd	a, (ix+HwCh.LFOvol) ; add LFO volume
		ld	(ix+HwCh.CurrHwVol), a ; save hardware volume
		ret
; End of function ProcessEnvelopes

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ProcessHwCh

InitFM:					; CODE XREF: ProcessHwCh+13j
		ld	l, (ix+HwCh.instrument)	; get instrument
		ld	h, 0
		ld	e, l
		ld	d, h
		zadd	hl, hl
		ex	de, hl
		zadd	hl, de
		ex	de, hl
		zadd	hl, hl
		zadd	hl, hl
		zadd	hl, hl
		zadd	hl, de		; 13 bytes per instrument
		ld	de, InstrumentTable
		zadd	hl, de		; get final address
		ld	a, (hl)		; get byte
		inc	hl
		cp	(ix+HwCh.algorithm) ; check if algorithm changed
		jr	z, @noalgo	; if not, branch
		ld	(ix+HwCh.algorithm), a ; save algo
		ld	c, a
		ld	b, 0B0h	; '°'   ; YM algorithm + feedback
		call	WriteYMchRAM

@noalgo:				; CODE XREF: ProcessHwCh+2CAj
		ld	a, (hl)		; load next byte
		inc	hl
		ld	(ix+HwCh.KeyOnOps), a ;	save as	key on operators
		ld	a, (ix+HwCh.PanCtrl) ; get panning control bits
		zand	0C0h ; 'À'      ; get only panning
		ld	c, a		; copy to c
		jr	z, @controlgot	; branch if panning is not overridden
		ld	a, 0C0h	; 'À'   ; make instrument be not in control

@controlgot:				; CODE XREF: ProcessHwCh+2E0j
		cpl			; set all bits on. If overridden, panning bits are clear
		zand	(hl)		; control AMS/FMS bits
		inc	hl
		zor	c		; copy overridden panning bits
		cp	(ix+HwCh.PanAF)	; has it changed?
		jr	z, @nopan	; if not, branch
		ld	(ix+HwCh.PanAF), a ; save the value
		ld	c, a
		ld	b, 0B4h	; '´'   ; YM panning
		call	WriteYMchRAM

@nopan:					; CODE XREF: ProcessHwCh+2EBj
		push	ix		; push channel
		pop	de		; pop into de
		ex	de, hl		; swap with hl
		ld	bc, HwCh.CurrHwVol
		zadd	hl, bc		; advance to TL	values
		ex	de, hl		; swap to de
		xor	a		; op1
		call	DoInstrumentGroup
		ld	a, 8		; op3
		call	DoInstrumentGroup
		ld	a, 4		; op2
		call	DoInstrumentGroup
		ld	a, 0Ch		; op4
		call	DoInstrumentGroup
		ld	a, (hl)		; load some frequency offset
		inc	hl
		ld	(ix+HwCh.ModFreqOff), a	; save it
		ld	a, (hl)		; ''
		inc	hl
		ld	(ix+HwCh.ModFreqOff+1), a ; ''
		call	LoadTrackers	; load trackers
		call	GetSlotOpAddr	; get slot operator addresses
		ld	e, (hl)		; load data
		push	ix		; save channel RAM
		pop	hl		; pop as hl
		ld	bc, HwCh.CurrHwVol ; first TL value
		zadd	hl, bc		; get it into hl
		ld	d, b		; only write non-slot operators

@oploop:				; CODE XREF: ProcessHwCh+34Aj
		ld	a, (hl)		; load TL
		inc	hl
		srl	e		; check	if this	is a slot op
		jr	c, @nextoper	; branch if slot op
		cp	(hl)		; check	last value
		jr	z, @nextoper	; if same, skip
		ld	(hl), a		; save last value
		ld	c, a		; store	as value
		ld	a, d		; Routine decides which	TL operator slot to write to:
					; 40 - Operator	1 - Register "d" = 00000000
					; 44 - Operator	2 - Register "d" = 00000001
					; 48 - Operator	3 - Register "d" = 00000010
					; 4C - Operator	4 - Register "d" = 00000011
					; Sound	driver uses a binary slot system (like most Z80	drivers), and so, operators 2 and 3
					; are swapped.	Operators 2 and	4 both have bit	0 of the "d" register counter set to 1, and
					; so they get given +8 (the "or  2" below).  Operators 1 and 3 do not, so they are not +8.
					;
					; Basicallly bits 0 and	1 of "d" are swapped, and then multiplied by 4:
					; (((d >> 1) | ((d & 1)	<< 1)) << 2) | 40 = operator slot 40, 44, 48, 4C
		srl	a		; halve, and set carry
		jr	nc, @opgot	; if not operators 2 or	4, branch
		zor	2		; if op	2 or 4,	add 8

@opgot:					; CODE XREF: ProcessHwCh+339j
		rlca			; shift	bits into place	(to bits 2 and 3) for 0, 4, 8 or C
		rlca			; ''
		zor	40h ; '@'       ; set YM address (TL operators)
		call	WriteYMchRAMa	; write	non-slot TL to YM2612

@nextoper:				; CODE XREF: ProcessHwCh+32Fj
					; ProcessHwCh+332j
		inc	hl		; skip over irrelevant crap
		inc	hl
		inc	hl
		inc	d		; next operator
		bit	2, d		; check	if all 4 ops are written
		jr	z, @oploop	; if not, loop for operators
		ld	a, (ix+HwCh.KeyOnOps) ;	get key	on ops
		call	KeyOffFM	; key on
		ret
; ---------------------------------------------------------------------------

InitPSG4:				; CODE XREF: ProcessHwCh+19j
		ld	(ix+HwCh.PreHwVol), 78h	; 'x' ; set last volume to mute
		ld	a, 0DFh	; 'ß'   ; mute PSG3
		ld	(7F11h), a	; ''

InitPSG:				; CODE XREF: ProcessHwCh+16j
		ld	l, (ix+HwCh.instrument)	; get envelope
		ld	h, 0		; clear	high byte
		ld	e, l		; copy to de
		ld	d, h		; ''
		zadd	hl, hl		; double
		zadd	hl, de		; add de. 3x
		zadd	hl, hl		; double hl. 6x
		ld	de, EnvelopeData ; get array to	de
		zadd	hl, de		; offset by hl
		ld	a, (hl)		; load a byte
		inc	hl
		ld	(ix+HwCh.RelDestVol), a	; save release destination volume
		ld	a, (hl)		; load a byte
		inc	hl
		ld	(ix+HwCh.EnvTimerBack),	a ; save timer
		ld	a, (hl)		; load a byte
		inc	hl
		ld	(ix+HwCh.RelVolSpeed), a ; save	release	volume speed
		ld	a, (hl)		; load tracker id
		inc	hl
		push	hl		; push hl
		ld	l, a		; copy id to l
		ld	h, 0
		zadd	hl, hl		; double id
		ld	de, EnvelopeTracker ; get tracker array
		zadd	hl, de		; offset by hl
		ld	a, (hl)		; load low byte
		inc	hl
		ld	h, (hl)		; load high byte of address
		ld	l, a		; fuse
		ld	a, (hl)		; load first tracker byte
		inc	hl
		ld	(ix+HwCh.EnvAddr), l ; save envelope address
		ld	(ix+HwCh.EnvAddr+1), h ; ''
		ld	e, a		; copy a to e
		zand	0Fh		; keep in range
		ld	(ix+HwCh.EnvTimer), a ;	save timer
		ld	a, e		; copy back to a
		rrca			; rotate right once
		zand	78h ; 'x'       ; get base volume
		zadd	a, (ix+HwCh.MainVol) ; add main	volume
		jp	p, @nocap	; branch if positive
		ld	a, 7Fh ; ''    ; force to max of 7F

@nocap:					; CODE XREF: ProcessHwCh+39Dj
		ld	(ix+HwCh.CurrChVol), a ; save volume
		pop	hl		; pop table
		ld	(ix+HwCh.ModFreqOff), 0	; clear
		ld	(ix+HwCh.ModFreqOff+1), 0E8h ; 'è' ; frequency offset
; END OF FUNCTION CHUNK	FOR ProcessHwCh

; =============== S U B	R O U T	I N E =======================================


LoadTrackers:				; CODE XREF: ProcessHwCh+31Cp
		ld	a, (hl)		; load mod id
		inc	hl
		push	hl		; store	instrument table
		ld	l, a
		ld	h, 0
		zadd	hl, hl		; double id
		ld	bc, ModTrackerdata
		zadd	hl, bc		; get table offset
		ld	a, (hl)		; load offset
		inc	hl
		ld	(ix+HwCh.ModTrackAddr),	a ; save
		ld	a, (hl)		; ''
		inc	hl
		ld	(ix+HwCh.ModTrackAddr+1), a ;	''
		pop	hl		; get instrument table back
		ld	l, (hl)		; load LFO id
		ld	h, 0
		zadd	hl, hl		; double id
		ld	bc, LFOtrackerData
		zadd	hl, bc		; get LFO table	address
		ld	a, (hl)		; load address
		inc	hl
		ld	(ix+HwCh.LFOtrackAddr),	a ; save address
		ld	a, (hl)		; ''
		inc	hl
		ld	(ix+HwCh.LFOtrackAddr+1), a ;	''
		xor	a		; clear	a
		ld	(ix+HwCh.ModBaseFreq), a
		ld	(ix+HwCh.ModBaseFreq+1), a
		ld	(ix+HwCh.ModOffFreq), a
		ld	(ix+HwCh.ModOffFreq+1), a
		ld	(ix+HwCh.LFOvol), a
		ld	(ix+HwCh.LFOoff), a
		ld	(ix+HwCh.ModShiftCount), a
		inc	a
		ld	(ix+HwCh.ModTrackTimer), a
		ld	(ix+HwCh.ModTempoBack),	a
		ld	(ix+HwCh.ModTempo), a
		ld	(ix+HwCh.LFOtimer), a
		ld	(ix+HwCh.LFOtempoBack),	a
		ld	(ix+HwCh.LFOtempo), a
		call	GetModFreqBase
		ld	(hl), 32h ; '2'
		ret
; End of function LoadTrackers


; =============== S U B	R O U T	I N E =======================================


GetModFreqBase:				; CODE XREF: LoadTrackers+51p
					; CalcModFreqBasep
		ld	a, (ModFreqBasePos) ; load modulation base offset (1 byte per channel)
		ld	hl, ModFreqBaseData ; get table	ptr
		zadd	a, l		; add channel to counter RAM addr
		ld	l, a		; save back
		ret	nc		; if no	carry, return
		inc	h		; if carry, add	100h
		ret
; End of function GetModFreqBase


; =============== S U B	R O U T	I N E =======================================


CalcModFreqBase:			; CODE XREF: ProcessHwCh+152p
		call	GetModFreqBase
		ld	a, (hl)		; load freq base
		ld	c, a
		sla	c
		sla	c
		zadd	a, c
		sla	c
		sla	c
		zadd	a, c
		sla	c
		zadd	a, c
		sla	c
		zadd	a, c
		zadd	a, 7Fh ; ''    ; (base*75h)+7Fh
		ld	(hl), a		; save a to freq base
		ret
; End of function CalcModFreqBase


; =============== S U B	R O U T	I N E =======================================


ProcessSlotChs:				; CODE XREF: sub_1+DDp
		ld	ix, SlotChannels ; get slot channels to	ix
		xor	a		; clear	a

@slotloop:				; CODE XREF: ProcessSlotChs+1Aj
		ld	(SlotCounter), a ; store slot
		bit	7, (ix+SlotCh)	; check	if channel is running
		call	nz, ProcessSlotCh ; if so, process slot	channel
		ld	de, 20h	; ' '   ; prepare ch size
		zadd	ix, de		; go to	next channel
		ld	a, (SlotCounter) ; get slot
		inc	a		; next slot
		cp	0Ah		; check	if we have dona	all slots
		jr	c, @slotloop	; if not, loop
		ret
; End of function ProcessSlotChs


; =============== S U B	R O U T	I N E =======================================


ProcessSlotCh:				; CODE XREF: ProcessSlotChs+Cp
		bit	7, (ix+SlotCh.priority)	; check	if this	is music
		jr	z, @nopause	; if not, branch
		ld	a, (Paused)	; get some bitfield
		bit	0, a		; is music paused?
		ret	nz		; if so, return

@nopause:				; CODE XREF: ProcessSlotCh+4j
		bit	6, (ix+SlotCh)	; check	if channel is initialized
		jr	nz, @initdone	; if is, branch
		zset	6, (ix+SlotCh)	; set as initialized
		xor	a		; clear	a
		ld	(ix+SlotCh.timer), a ; clear timer
		ld	(ix+SlotCh.timer+1), a ; ''
		ld	(ix+SlotCh.loopoff), a
		ld	(ix+SlotCh.notectr), a
		ld	(ix+SlotCh.notesplayed), a
		ld	(ix+SlotCh.section), a ; clear section variable
		ld	(ix+SlotCh.Instrument),	a
		ld	(ix+SlotCh.hwmask), 0Fh	; set hardware channel mask to all possible channels
		ld	(ix+SlotCh.TempoDiv), 8	; set tempo divider to 8
		ld	(ix+SlotCh.freq), a ; clear frequency
		ld	(ix+SlotCh.freq+1), a	; ''
		ld	(ix+SlotCh.volume), a
		ld	a, (ix+SlotCh.Panning)
		zand	1
		ld	(ix+SlotCh.Panning), a
		jr	@timerexpired
; ---------------------------------------------------------------------------

@initdone:				; CODE XREF: ProcessSlotCh+10j
		ld	l, (ix+SlotCh.timer) ; load timer
		ld	h, (ix+SlotCh.timer+1) ; ''
		ld	e, 9		; load 9 into e
		bit	7, (ix+SlotCh.priority)	; is this music?
		jr	z, @sfx		; if not, branch
		ld	a, (TempoCount)	; load tempo counter variable
		ld	e, a		; into e

@sfx:					; CODE XREF: ProcessSlotCh+53j
		xor	a		; clear	a and carry
		ld	d, a		; clear	d
		sbc	hl, de		; sub a	value from timer
		ld	(ix+SlotCh.timer), l ; save timer
		ld	(ix+SlotCh.timer+1), h ; ''
		jr	z, @timerexpired ; if timer hit	0, branch
		ret	nc		; if timer is positive,	return

@timerexpired:				; CODE XREF: ProcessSlotCh+45j
					; ProcessSlotCh+63j
		ld	e, (ix+SlotCh.TrackerAddr) ; load tracker to de
		ld	d, (ix+SlotCh.TrackerAddr+1) ; ''
		xor	a		; clear	a
		ld	(Temp_Attack), a
		ld	(Temp_NotesNum), a ; clear num of notes
		ld	l, (ix+SlotCh.timerback) ; load	timer backup to	hl
		ld	h, (ix+SlotCh.timerback+1) ; ''
		ld	(Temp_Timer), hl ; load	to this	flag too

ReadTracker:				; CODE XREF: ProcessSlotCh+9Fj
					; ProcessSlotCh+AEj ...
		ld	a, (de)		; load byte from tracker
		inc	de
		cp	0E0h ; 'à'      ; check if its a flag
		jr	c, @notflag	; branch if not
		zadd	a, a		; double command
		zand	3Eh ; '>'       ; keep in range
		zadd	a, TrackerCmd&0FFh ; add low byte of command array
		ld	l, a		; put in l
		ld	a, 0		; clear	a
		adc	a, TrackerCmd>>8 ; set high byte with carry to a
		ld	h, a		; put in h
		ld	a, (hl)		; get high byte	of address
		inc	hl
		ld	h, (hl)		; get low byte of address
		ld	l, a		; fuse
		ld	bc, ReadTracker	; return back to tracker reader
		push	bc		; ''
		jp	(hl)		; call command
; ---------------------------------------------------------------------------

@notflag:				; CODE XREF: ProcessSlotCh+80j
		cp	0D8h ; 'Ø'
		jr	c, @notloopgo
		zsub	0D7h ; '×'      ; flag-D7 is loop count?
		call	SaveLoopData	; set loop data?
		jr	ReadTracker
; ---------------------------------------------------------------------------

@notloopgo:				; CODE XREF: ProcessSlotCh+98j
		cp	0D0h ; 'Ð'
		jr	c, @notloopback
		zsub	0CFh ; 'Ï'
		call	SaveLoopData
		ex	de, hl		; get tracker to hl
		ld	e, (hl)		; load de as the new tracker address
		inc	hl
		ld	d, (hl)
		jr	ReadTracker
; ---------------------------------------------------------------------------

@notloopback:				; CODE XREF: ProcessSlotCh+A3j
		cp	0C0h ; 'À'
		jr	c, @nottimer
		zand	0Fh		; get offset
		ld	c, a		; load it to c
		ld	b, 0		; clear	b
		ld	hl, TimerTable	; load timer table to hl
		zadd	hl, bc		; add offset to	hl
		ld	l, (hl)		; load timer byte
		ld	h, 0		; clear	h
		ld	c, l		; copy to bc
		ld	b, h		; ''
		zadd	hl, hl		; double hl
		zadd	hl, bc		; timer	is multiplied by 3
		ld	(Temp_Timer), hl ; store to this flag
		ld	(ix+SlotCh.timerback), l ; save	to timer backup
		ld	(ix+SlotCh.timerback+1), h ; ''
		jr	ReadTracker
; ---------------------------------------------------------------------------

@nottimer:				; CODE XREF: ProcessSlotCh+B2j
		cp	60h ; '`'
		jr	c, @playnote
		zsub	60h ; '`'       ; make 0-based
		call	PlayNoteFreeCh
		jr	ReadTracker
; ---------------------------------------------------------------------------

@playnote:				; CODE XREF: ProcessSlotCh+D1j
		call	PlayNoteFreeCh

EndTrackerRead:				; CODE XREF: ROM:0F42j
		ld	(ix+SlotCh.TrackerAddr), e ; set tracker address
		ld	(ix+SlotCh.TrackerAddr+1), d ; ''
		ld	a, (Temp_Timer)	; get the low byte of timer
		zadd	a, (ix+SlotCh.timer) ; add low byte of timer to	a
		ld	(ix+SlotCh.timer), a ; save to mem
		ld	a, (Temp_Timer+1) ; get	high byte of timer
		adc	a, (ix+SlotCh.timer+1) ; add high byte with carry
		ld	(ix+SlotCh.timer+1), a ; save	it in
		ld	a, (Temp_NotesNum) ; get num of	notes played this frame
		ld	(ix+SlotCh.notesplayed), a ; save it to	a counter
		res	4, (ix+SlotCh)	; clear	no attack flag(?)
		ld	a, (Temp_Attack) ; check if we were attacking next note(?)
		zor	a		; ''
		ret	z		; return if not
		zset	4, (ix+SlotCh)	; set no attack	flag(?)
		ret
; End of function ProcessSlotCh


; =============== S U B	R O U T	I N E =======================================


PlayNoteFreeCh:				; CODE XREF: ProcessSlotCh+D5p
					; ProcessSlotCh:@playnotep
		push	de		; store	tracker	address
		bit	0, (ix+SlotCh.Panning) ; check if bit 0	of panning is set
		jp	nz, @nochannel	; if is, branch
		bit	0, (ix+SlotCh)	; check	some special flag
		jr	z, @haschannel	; if not, branch
		ld	l, a		; multiply by 3
		zadd	a, a		; ''
		zadd	a, l		; ''
		ld	l, a		; ''
		ld	h, 0		; clear	h
		rl	h		; shift	carry of x3 into h
		zadd	hl, hl		; multiply by size of word
		ld	de, DrumMaps	; load drum channel mappings list
		zadd	hl, de		; advance to correct entry in table
		ld	a, (hl)		; load section
		inc	hl
		ld	(Temp_Section),	a ; save section
		ld	a, (hl)		; load ch mask
		inc	hl
		ld	(Temp_ChMask), a ; save	channel	mask
		ld	a, (ix+SlotCh.priority)	; get priority
		zand	7Fh ; ''       ; ignore music bit
		ld	(Temp_Priority), a ; ''
		push	hl
		call	GetLowPrioHwCh	; find a channel we can	override
		pop	hl
		jp	nz, @nochannel	; if z is not set, we found not	valid channel
		ld	a, (hl)		; load instrument
		inc	hl
		ld	(iy+HwCh.instrument), a
		ld	a, (hl)		; load panning
		inc	hl
		ld	c, a		; copy to c
		zand	3Fh ; '?'       ; get only tempo divider
		ld	e, (hl)		; load modulation frequency
		inc	hl
		ld	d, (hl)		; ''
		ex	de, hl		; swap de and hl
		jp	@savemodfreq
; ---------------------------------------------------------------------------

@haschannel:				; CODE XREF: PlayNoteFreeCh+Cj
		zadd	a, (ix+SlotCh.freq+1)	; flag + frequency high	byte
		ld	h, a		; is high byte
		ld	l, (ix+SlotCh.freq) ; get low byte of freq
		ld	(Temp_Frequency), hl ; store frequency
		ld	a, (ix+SlotCh.section)
		ld	(Temp_Section),	a ; save section (0 = FM, 1 = PSG, 2 = PSG4)
		bit	5, (ix+SlotCh)	; check	if we are modulating
		jr	z, @nomod	; if not, branch
		call	FindChNoteHw	; fin the channel playing this note
		jr	c, @obtainhw	; if not, branch
		bit	4, (ix+SlotCh)	; check	if no-attack bit(?)
		jr	nz, @nostop	; if set, branch
		push	iy		; push hw channel
		ex	(sp), ix	; swap ix with iy
		call	StopChPtr	; stop hw channel
		pop	ix		; restore ix

@nostop:				; CODE XREF: PlayNoteFreeCh+65j
		ld	hl, (Temp_Frequency)
		ld	(iy+HwCh.ModFreqTgt), l	; set mod freq target
		ld	(iy+HwCh.ModFreqTgt+1), h ; ''
		ld	e, (iy+HwCh.CurrModFreq) ; get modulation frequency
		ld	d, (iy+HwCh.CurrModFreq+1) ; ''
		zor	a		; clear	carry (for sbc)
		sbc	hl, de		; sub current freq from	target freq
		push	af		; push flags into stack
		jr	nc, @abs	; keep hl positive
		xor	a		; negate value
		zsub	l		; negate l
		ld	l, a		; ''
		ld	a, 0		; clear	a without affecting flags
		sbc	a, h		; negate h
		ld	h, a		; ''

@abs:					; CODE XREF: PlayNoteFreeCh+83j
		xor	a		; the code below does signed division of difference between current and	target frequency, with mod speed divider
		ld	b, 10h		; 10 bits of hl
		ld	c, (ix+SlotCh.ModSpeedDiv) ; divider

@divloop:				; CODE XREF: PlayNoteFreeCh:@nolsbj
		zadd	hl, hl		; shift	hl left
		rla			; shift	msb to a
		cp	c		; compare a with c
		jr	c, @nolsb	; branch if c is higher	than a
		zsub	c		; sub c	again
		inc	l		; set bit 0 of hl

@nolsb:					; CODE XREF: PlayNoteFreeCh+95j
		djnz	@divloop	; loop for all bits
		pop	af		; restore flags
		jr	nc, @noneg	; if value was positive, branch
		xor	a		; negate value
		zsub	l
		ld	l, a
		ld	a, 0
		sbc	a, h
		ld	h, a

@noneg:					; CODE XREF: PlayNoteFreeCh+9Cj
		ld	(iy+HwCh.ModSpeed), l ;	save modulation	speed
		ld	(iy+HwCh.ModSpeed+1),	h ; ''
		bit	4, (ix+SlotCh)	; check	if no-attack bit(?)
		jr	nz, @noattack	; if is	set, branch
		ld	(iy+HwCh), 80h ; '€' ; set as running
		ld	a, (ix+SlotCh.TempoDiv)
		ld	c, (ix+SlotCh.Panning)
		jr	@panandtempo
; ---------------------------------------------------------------------------

@nomod:					; CODE XREF: PlayNoteFreeCh+5Aj
		bit	4, (ix+SlotCh)	; check	if no-attack bit(?)
		jr	z, @obtainhw	; if is	not set, branch
		call	FindChNoteHw	; check	if we can find the hardware channel for	us
		jr	c, @obtainhw	; branch if we failed to find it
		ld	hl, (Temp_Frequency) ; load frequency
		ld	(iy+HwCh.CurrModFreq), l ; save	it to hw channel
		ld	(iy+HwCh.CurrModFreq+1), h ; ''

@noattack:				; CODE XREF: PlayNoteFreeCh+AFj
		call	GetCorrectVol	; get volume to	hw channel
		ld	a, (ix+SlotCh.notectr) ; get the note counter
		ld	(iy+HwCh.notectr), a ; save to hw channel
		jp	@nochannel	; stop channel process
; ---------------------------------------------------------------------------

@obtainhw:				; CODE XREF: PlayNoteFreeCh+5Fj
					; PlayNoteFreeCh+C1j ...
		ld	a, (ix+SlotCh.hwmask) ;	load channel mask
		ld	(Temp_ChMask), a ; save	to tep reg
		ld	a, (ix+SlotCh.priority)	; load priority
		zand	7Fh ; ''       ; ignore msb
		ld	(Temp_Priority), a ; save priority
		call	GetLowPrioHwCh	; find a channel
		jp	nz, @nochannel	; if channel was not found, branch
		ld	a, (ix+SlotCh.Instrument)
		ld	(iy+HwCh.instrument), a
		ld	a, (ix+SlotCh.TempoDiv)
		ld	c, (ix+SlotCh.Panning)
		ld	hl, (Temp_Frequency)

@savemodfreq:				; CODE XREF: PlayNoteFreeCh+43j
		ld	(iy+HwCh.CurrModFreq), l ; save	modulation frequency from hl
		ld	(iy+HwCh.CurrModFreq+1), h ; ''

@panandtempo:				; CODE XREF: PlayNoteFreeCh+BBj
		ld	(iy+HwCh.PanCtrl), c ; save panning
		call	GetCorrectVol	; get correct hw volume
		ld	hl, Temp_Attack
		bit	0, (hl)
		jr	z, @dotempodiv
		xor	a
		ld	(iy+HwCh.TempoAcc), a ;	clear tempo
		jr	@gottempo
; ---------------------------------------------------------------------------

@dotempodiv:				; CODE XREF: PlayNoteFreeCh+111j
		ld	b, 5		; 6 bits of a to do
		ld	de, (Temp_Timer) ; channel tempo
		ld	hl, 0		; reset	hl

@loop:					; CODE XREF: PlayNoteFreeCh:@nocarryj
		srl	h		; divide tempo by 2
		rr	l		; ''
		rra			; rotate bit of	a into carry
		jr	nc, @nocarry	; if bit was not set in	a, branch
		zadd	hl, de		; add channel tempo to hl

@nocarry:				; CODE XREF: PlayNoteFreeCh+127j
		djnz	@loop
		xor	a
		zsub	l		; negate low byte and set carry	if not 0
		ld	(iy+HwCh.TempoAcc), a ;	store it
		ld	a, 80h ; '€'    ; load 80
		sbc	a, h		; sub h	and carry form 80h

@gottempo:				; CODE XREF: PlayNoteFreeCh+117j
		ld	(iy+HwCh.TempoTimer), a	; save
		ld	a, (Temp_Section) ; load section into a
		zor	a		; check	if its 0 (FM)
		jr	z, @isFM	; branch if so
		ld	(iy+HwCh.type),	a ; load into ch type

@isFM:					; CODE XREF: PlayNoteFreeCh+13Bj
		ld	c, 10000000b	; set running
		ld	a, (ix+SlotCh.priority)	; get priority
		zor	a		; check	it
		jp	p, @sfx		; branch if sfx
		zand	7Fh ; ''       ; clear msb
		ld	c, 10100000b	; running and running a	music track

@sfx:					; CODE XREF: PlayNoteFreeCh+146j
		bit	5, (ix+SlotCh)	; check	if we are modulating
		jr	z, @modgot	; branch if not
		bit	7, (iy+HwCh)	; check	if running
		jr	z, @modgot	; branch if not
		zset	4, c		; enable hardware modulation

@modgot:				; CODE XREF: PlayNoteFreeCh+151j
					; PlayNoteFreeCh+157j
		ld	(iy+HwCh.priority), a ;	save priority
		ld	(iy+HwCh), c	; set channel bitfield
		ld	a, (SlotCounter) ; get slot counter
		ld	(iy+HwCh.SlotID), a ; save slot	ID, so we can find this	channel	later
		ld	a, (ix+SlotCh.notectr) ; get note counter
		ld	(iy+HwCh.notectr), a ; save the	value of counter when we started to play a note

@nochannel:				; CODE XREF: PlayNoteFreeCh+5j
					; PlayNoteFreeCh+32j ...
		pop	de		; pop de again
		inc	(ix+SlotCh.notectr) ; increment	each time we read a note
		ld	hl, Temp_NotesNum
		inc	(hl)		; increment num	of notes played
		ret
; End of function PlayNoteFreeCh


; =============== S U B	R O U T	I N E =======================================


GetCorrectVol:				; CODE XREF: PlayNoteFreeCh:@noattackp
					; PlayNoteFreeCh+109p
		ld	hl, VolTable_FM	; load FM volume table
		ld	b, (iy+HwCh.type) ; load type
		inc	b		; set z	flag accordingly
		dec	b		; ''
		jr	z, @VolFM	; if it's an FM channel, branch
		ld	hl, VolTable_PSG ; load	PSG volume table instead

@VolFM:					; CODE XREF: GetCorrectVol+8j
		ld	e, (ix+SlotCh.volume) ;	Volume position
		srl	e		; divide by 2
		ld	d, 0		; de = volume position
		zadd	hl, de		; advance to correct entry in table
		ld	l, (hl)		; load volume
		ld	(iy+HwCh.MainVol), l ; save volume to hardware channel
		ret
; End of function GetCorrectVol

; ---------------------------------------------------------------------------
TimerTable:	db  6, 9,0Ch,12h,18h,24h,30h,48h,60h,90h,0C0h, 8,10h,20h
					; DATA XREF: ProcessSlotCh+B9o
		db 3Ch,78h

; =============== S U B	R O U T	I N E =======================================


GetLoopSlot:				; CODE XREF: SaveLoopData+1p
					; ROM:FlagFE_LoopBackp
		ld	a, (ix+SlotCh.loopoff) ; load loop offset/entry

GetLoopSlot_a:				; CODE XREF: ROM:0F77p
		ld	l, a		; multiply by 3	(3 bytes per entry)
		zadd	a, a		; ''
		zadd	a, l		; ''
		zadd	a, SlotCh.loopdata ; advance to	loop data
		push	ix		; copy ix to hl
		pop	hl		; ''
		zadd	a, l		; advance to correct loop entry
		ld	l, a		; ''
		ret	nc		; if it	hasn't passed FF, return
		inc	h		; carry	to h
		ret			; return
; End of function GetLoopSlot


; =============== S U B	R O U T	I N E =======================================


SaveLoopData:				; CODE XREF: ProcessSlotCh+9Cp
					; ProcessSlotCh+A7p
		ld	c, a		; store	loop count (1 -	8)
		call	GetLoopSlot	; get the next available slot
		ld	(hl), e		; store	loop destination tracker address here
		inc	hl		; ''
		ld	(hl), d		; ''
		inc	hl		; ''
		ld	(hl), c		; store	loop count
		inc	(ix+SlotCh.loopoff) ; increase loop entry position
		ret			; return
; End of function SaveLoopData

; ---------------------------------------------------------------------------
TrackerCmd:	dw FlagE0_EnableMod	; DATA XREF: ProcessSlotCh+85t
					; ProcessSlotCh+8At
					; E0 - Enable modulation
		dw FlagE1_DisableMod	; E1 - Disable modulation
		dw FlagE2_SetTimerByte	; E2 - Set timer to a byte value
		dw FlagE3_SetTimerWord	; E3 - Set timer to a word value
		dw FlagE4_LoadTempo	; E4 - Set tempo
		dw FlagXX_Null		; E5 - nop. Used in later games	to load	extra sound effects
		dw FlagXX_Null		; E6 - nop
		dw FlagXX_Null		; E7 - nop
		dw FlagXX_Null		; E8 - nop
		dw FlagXX_Null		; E9 - nop
		dw FlagXX_Null		; EA - nop
		dw FlagXX_Null		; EB - nop
		dw FlagXX_Null		; EC - nop
		dw FlagXX_Null		; ED - nop
		dw FlagXX_Null		; EE - nop
		dw FlagXX_Null		; EF - nop
		dw FlagF0_SetInstrument	; F0 - Set instrument or envelope ID
		dw FlagF1_SetTempoDiv	; F1 - Set tempo divider
		dw FlagF2_LoadFreq	; F2 - load frequency (2 bytes)
		dw FlagF3_AddFreq	; F3 - add to current frequency	(2 bytes)
		dw FlagF4_LoadVol	; F4 - load volume
		dw FlagF5_AddVol	; F5 - Add to volume
		dw FlagF6_SelectType	; F6 - Select channel type
		dw FlagF7_SetChMask	; F7 - Set custom hardware mask
		dw FlagF8_DrumCh	; F8 - Enable drum channel behavior
		dw FlagF9_Pan		; F9 - Set Panning
		dw FlagFA_FinishRead	; FA - Stops reading the tracker until next timer end(?)
		dw FlagFB_StopHw	; FB - stop hardware channel
		dw loc_F4B
		dw FlagFD_Jump		; FD - jump to offset (2-byte offset)
		dw FlagFE_LoopBack	; FE - loop until counter is clear
		dw FlagFF_LoopGoEnd	; FF - loop until counter is clear, jump to address if not clear
; ---------------------------------------------------------------------------

FlagE0_EnableMod:			; DATA XREF: ROM:TrackerCmdo
		ld	a, (de)		; load a byte
		inc	de
		ld	(ix+SlotCh.ModSpeedDiv), a ; save the divider
		zset	5, (ix+SlotCh)	; enable modulation

FlagXX_Null:				; DATA XREF: ROM:0E6Co	ROM:0E6Eo ...
		ret
; ---------------------------------------------------------------------------

FlagE1_DisableMod:			; DATA XREF: ROM:0E64o
		res	5, (ix+SlotCh)
		ret
; ---------------------------------------------------------------------------

FlagE2_SetTimerByte:			; DATA XREF: ROM:0E66o
		ld	a, (de)		; load a byte
		inc	de
		ld	l, a		; set as low byte
		ld	h, 0		; clear	high byte
		jr	FlagE2E3
; ---------------------------------------------------------------------------

FlagE3_SetTimerWord:			; DATA XREF: ROM:0E68o
		ex	de, hl		; swap de and hl
		ld	e, (hl)		; load low byte
		inc	hl
		ld	d, (hl)		; load high byte
		inc	hl
		ex	de, hl		; swap de and hl

FlagE2E3:				; CODE XREF: ROM:0EB6j
		ld	c, l		; copy to bc
		ld	b, h		; ''
		zadd	hl, hl		; double hl
		zadd	hl, bc		; triple hl
		ld	(Temp_Timer), hl ; save	as a timer
		ld	(ix+SlotCh.timerback), l ; backup the timer
		ld	(ix+SlotCh.timerback+1), h
		ret
; ---------------------------------------------------------------------------

FlagE4_LoadTempo:			; DATA XREF: ROM:0E6Ao
		ld	a, (de)
		inc	de
		ld	(MainTempo), a
		ld	a, (de)
		inc	de
		ld	(MainTempo+1), a
		ret
; ---------------------------------------------------------------------------

FlagF0_SetInstrument:			; DATA XREF: ROM:0E82o
		ld	a, (de)
		inc	de
		ld	(ix+SlotCh.Instrument),	a
		ret
; ---------------------------------------------------------------------------

FlagF1_SetTempoDiv:			; DATA XREF: ROM:0E84o
		ld	a, (de)
		inc	de
		ld	(ix+SlotCh.TempoDiv), a
		ret
; ---------------------------------------------------------------------------

FlagF2_LoadFreq:			; DATA XREF: ROM:0E86o
		ld	a, (de)		; load frequency
		inc	de
		ld	(ix+SlotCh.freq), a
		ld	a, (de)
		inc	de
		ld	(ix+SlotCh.freq+1), a
		ret
; ---------------------------------------------------------------------------

FlagF3_AddFreq:				; DATA XREF: ROM:0E88o
		ld	a, (de)
		inc	de
		zadd	a, (ix+SlotCh.freq)
		ld	(ix+SlotCh.freq), a
		ld	a, (de)
		inc	de
		adc	a, (ix+SlotCh.freq+1)
		ld	(ix+SlotCh.freq+1), a
		ret
; ---------------------------------------------------------------------------

FlagF4_LoadVol:				; DATA XREF: ROM:0E8Ao
		ld	a, (de)
		inc	de
		ld	(ix+SlotCh.volume), a
		ret
; ---------------------------------------------------------------------------

FlagF5_AddVol:				; DATA XREF: ROM:0E8Co
		ld	a, (de)
		inc	de
		zadd	a, (ix+SlotCh.volume)
		ld	(ix+SlotCh.volume), a
		ret
; ---------------------------------------------------------------------------

FlagF6_SelectType:			; DATA XREF: ROM:0E8Eo
		ld	a, (de)		; load a byte
		inc	de
		ld	(ix+SlotCh.section), a ; load slot section
		zsub	2		; sub 2	from it
		ld	a, 3Fh ; '?'    ; FM channel mask 6 channels
		jr	c, @fm		; branch if FM
		jr	z, @psg		; branch if PSG
		ld	a, 1		; PSG4 channel mask
		jr	@fm
; ---------------------------------------------------------------------------

@psg:					; CODE XREF: ROM:0F19j
		ld	a, 7		; PSG channel mask 3 channels

@fm:					; CODE XREF: ROM:0F17j	ROM:0F1Dj
		ld	(ix+SlotCh.hwmask), a ;	set channel mask
		ret
; ---------------------------------------------------------------------------

FlagF7_SetChMask:			; DATA XREF: ROM:0E90o
		ld	a, (de)
		inc	de
		ld	(ix+SlotCh.hwmask), a
		ret
; ---------------------------------------------------------------------------

FlagF8_DrumCh:				; DATA XREF: ROM:0E92o
		ld	a, (ix+SlotCh)	; get bitfield
		xor	1		; enable drum channel
		ld	(ix+SlotCh), a	; copy back
		ret
; ---------------------------------------------------------------------------

FlagF9_Pan:				; DATA XREF: ROM:0E94o
		ld	a, (ix+SlotCh.Panning)
		zand	3Fh ; '?'
		ld	c, a
		ld	a, (de)		; load a byte
		inc	de
		zor	c		; or with original value
		ld	(ix+SlotCh.Panning), a ; save back
		ret
; ---------------------------------------------------------------------------

FlagFA_FinishRead:			; DATA XREF: ROM:0E96o
		pop	hl		; skip return address
		jp	EndTrackerRead
; ---------------------------------------------------------------------------

FlagFB_StopHw:				; DATA XREF: ROM:0E98o
		push	de
		call	StopHwCh
		pop	de
		ret
; ---------------------------------------------------------------------------

loc_F4B:				; DATA XREF: ROM:0E9Ao
		ld	a, 1
		ld	(Temp_Attack), a
		ret
; ---------------------------------------------------------------------------

FlagFD_Jump:				; DATA XREF: ROM:0E9Co
		ex	de, hl
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		ret
; ---------------------------------------------------------------------------

FlagFE_LoopBack:			; DATA XREF: ROM:0E9Eo
		call	GetLoopSlot	; load slot address (must read backwarrs.b due to	stack effect)
		dec	hl		; go back to loop count
		dec	(hl)		; decrease loop	counter
		jr	nz, @ContLoop	; if the counter is still running, branch
		dec	(ix+SlotCh.loopoff) ; decrease loop entry counter
		ret			; return (loop finished)
; ---------------------------------------------------------------------------

@ContLoop:				; CODE XREF: ROM:0F5Bj
		dec	hl		; load loop jump address
		ld	d, (hl)		; ''
		dec	hl		; ''
		ld	e, (hl)		; ''
		ret			; return (now at loop address)
; ---------------------------------------------------------------------------

FlagFF_LoopGoEnd:			; DATA XREF: ROM:0EA0o
		ld	a, (ix+SlotCh.loopoff) ; load loop entry position
		zor	a		; are there any	loop entries left?
		jp	nz, @nostop	; if so, branch	and process loop
		pop	hl		; skip return address
		call	StopHwCh	; stop hardware	channel
		ld	(ix+SlotCh), 0	; disable slot channel
		ret
; ---------------------------------------------------------------------------

@nostop:				; CODE XREF: ROM:0F6Aj
		dec	a		; go back a slot
		call	GetLoopSlot_a	; get the slot
		ld	e, (hl)		; load loop destination	address
		inc	hl		; ''
		ld	d, (hl)		; ''
		inc	hl		; ''
		dec	(hl)		; decrease loop	count
		jr	nz, @contloop	; if it	hasn't finished, branch
		dec	(ix+1)		; decrease loop	entry/offset count
		inc	de		; skip over loop address
		inc	de		; ''
		ret			; return (continue)
; ---------------------------------------------------------------------------

@contloop:				; CODE XREF: ROM:0F7Fj
		ex	de, hl		; load loop destination	address
		ld	e, (hl)		; ''
		inc	hl		; ''
		ld	d, (hl)		; ''
		ret			; return (now at loop address)

; =============== S U B	R O U T	I N E =======================================


DebugStuff:				; CODE XREF: ROM:0023j	ROM:002Bj ...
		ld	(DebugBC), bc
		ld	(DebugDE), de
		ld	(DebugHL), hl
		ld	(DebugIX), ix
		ld	(DebugIY), iy
		pop	hl		; get return addr
		ld	(DebugRet), hl
		ld	(DebugStack), sp
		push	af
		pop	hl
		ld	(DebugAF), hl
		ex	af, af
		push	af
		ex	af, af
		pop	hl
		ld	(DebugAF2), hl
		exx
		ld	(DebugBC2), bc
		ld	(DebugDE2), de
		ld	(DebugHL2), hl
		exx
		ld	a, (DebugSizeCopy1) ; get copy size
		zor	a		; check	if 0
		jr	z, @nocopy1	; branch if 0
		ld	c, a		; bc = size to copy
		ld	b, 0
		ld	hl, DebugBufferCopy1 ; hl = source to copy from
		ld	de, (DebugAddrCopy1) ; de = dest to copy to
		ldir			; copy data

@nocopy1:				; CODE XREF: DebugStuff+38j
		ld	a, (DebugSizeCopy2) ; same as above
		zor	a
		jr	z, @nocopy2
		ld	c, a
		ld	b, 0
		ld	hl, DebugBufferCopy2
		ld	de, (DebugAddrCopy2)
		ldir

@nocopy2:				; CODE XREF: DebugStuff+4Aj
		ld	a, (DebugSizeCopy3) ; same as above
		zor	a
		jr	z, @nocopy3
		ld	c, a
		ld	b, 0
		ld	hl, DebugBufferCopy3
		ld	de, (DebugAddrCopy3)
		ldir

@nocopy3:				; CODE XREF: DebugStuff+5Cj
		ld	a, 1
		ld	(Debug68kAccess), a
		ld	(DebugZ80Access), a

@waitaccess:				; CODE XREF: DebugStuff+76j
		ld	a, (DebugZ80Access) ; wait for access token
		zor	a		; ''
		jr	nz, @waitaccess	; branches if not 0
		ld	a, (DebugSizeCopy1) ; get size
		zor	a
		jr	z, @nocopyback1	; skip if 0
		ld	c, a		; bc = size
		ld	b, 0
		ld	hl, (DebugAddrCopy1) ; hl = source
		ld	de, DebugBufferCopy1 ; de = destination
		ldir			; copy data back
		ld	hl, (DebugAddrCopy1) ; get the address again
		ld	(hl), 0E7h ; 'ç' ; rst 20h

@fillloop1:				; CODE XREF: DebugStuff+94j
		inc	hl		; skip a byte
		dec	a		; sub 1	from size
		jr	z, @nocopyback1	; if 0,	branch
		ld	(hl), 0		; fill with nops
		jr	@fillloop1	; loop til done
; ---------------------------------------------------------------------------

@nocopyback1:				; CODE XREF: DebugStuff+7Cj
					; DebugStuff+90j
		ld	a, (DebugSizeCopy2) ; same as above
		zor	a
		jr	z, loc_1040
		ld	c, a
		ld	b, 0
		ld	hl, (DebugAddrCopy2)
		ld	de, DebugBufferCopy2
		ldir
		ld	hl, (DebugAddrCopy2)
		ld	(hl), 0EFh ; 'ï' ; rst 28h

loc_1038:				; CODE XREF: DebugStuff+B2j
		inc	hl
		dec	a
		jr	z, loc_1040
		ld	(hl), 0
		jr	loc_1038
; ---------------------------------------------------------------------------

loc_1040:				; CODE XREF: DebugStuff+9Aj
					; DebugStuff+AEj
		ld	a, (DebugSizeCopy3) ; same as above
		zor	a
		jr	z, loc_105E
		ld	c, a
		ld	b, 0
		ld	hl, (DebugAddrCopy3)
		ld	de, DebugBufferCopy3
		ldir
		ld	hl, (DebugAddrCopy3)
		ld	(hl), 0F7h ; '÷' ; rst 30h

loc_1056:				; CODE XREF: DebugStuff+D0j
		inc	hl
		dec	a
		jr	z, loc_105E
		ld	(hl), 0
		jr	loc_1056
; ---------------------------------------------------------------------------

loc_105E:				; CODE XREF: DebugStuff+B8j
					; DebugStuff+CCj
		ld	bc, (DebugBC)
		ld	de, (DebugDE)
		ld	sp, (DebugStack)
		ld	hl, (DebugRet)
		push	hl
		ld	hl, (DebugAF)
		push	hl
		ld	hl, (DebugHL)
		xor	a
		ld	(Debug68kAccess), a
		pop	af
		ret
; End of function DebugStuff

; ---------------------------------------------------------------------------
FreqFM:		dw 28Eh, 293h, 297h, 29Ch, 2A1h, 2A6h ;	DATA XREF: WriteFrequency+4Ao
		dw 2ABh, 2B0h, 2B5h, 2BAh, 2BFh, 2C4h
		dw 2C9h, 2CEh, 2D4h, 2D9h, 2DEh, 2E3h
		dw 2E9h, 2EEh, 2F4h, 2F9h, 2FFh, 304h
		dw 30Ah, 30Fh, 315h, 31Bh, 320h, 326h
		dw 32Ch, 332h, 338h, 33Eh, 344h, 34Ah
		dw 350h, 356h, 35Ch, 363h, 369h, 36Fh
		dw 376h, 37Ch, 383h, 389h, 390h, 396h
		dw 39Dh, 3A4h, 3AAh, 3B1h, 3B8h, 3BFh
		dw 3C6h, 3CDh, 3D4h, 3DBh, 3E2h, 3E9h
		dw 3F1h, 3F8h, 3FFh, 407h, 40Eh, 416h
		dw 41Dh, 425h, 42Dh, 434h, 43Ch, 444h
		dw 44Ch, 454h, 45Ch, 464h, 46Ch, 474h
		dw 47Dh, 485h, 48Dh, 496h, 49Eh, 4A7h
		dw 4AFh, 4B8h, 4C1h, 4CAh, 4D3h, 4DBh
		dw 4E4h, 4EEh, 4F7h, 500h, 509h, 513h
		dw 51Ch
FreqPSG:	dw 349h, 343h, 33Dh, 337h, 331h, 32Bh ;	DATA XREF: WriteFrequency+Do
		dw 326h, 320h, 31Ah, 314h, 30Fh, 309h
		dw 303h, 2FEh, 2F8h, 2F3h, 2EDh, 2E8h
		dw 2E3h, 2DDh, 2D8h, 2D3h, 2CEh, 2C8h
		dw 2C3h, 2BEh, 2B9h, 2B4h, 2AFh, 2AAh
		dw 2A5h, 2A0h, 29Ch, 297h, 292h, 28Dh
		dw 289h, 284h, 27Fh, 27Bh, 276h, 272h
		dw 26Dh, 269h, 264h, 260h, 25Bh, 257h
		dw 253h, 24Eh, 24Ah, 246h, 242h, 23Eh
		dw 239h, 235h, 231h, 22Dh, 229h, 225h
		dw 221h, 21Dh, 219h, 216h, 212h, 20Eh
		dw 20Ah, 206h, 203h, 1FFh, 1FBh, 1F8h
		dw 1F4h, 1F0h, 1EDh, 1E9h, 1E6h, 1E2h
		dw 1DFh, 1DBh, 1D8h, 1D5h, 1D1h, 1CEh
		dw 1CAh, 1C7h, 1C4h, 1C1h, 1BDh, 1BAh
		dw 1B7h, 1B4h, 1B1h, 1AEh, 1ABh, 1A7h
		dw 1A4h
byte_11FF:	db 0			; DATA XREF: ROM:1A75o
VolTable_FM:	db  0, 0, 0, 0,	1, 1, 1, 2, 2, 3, 3, 4,	5, 5, 6, 7, 8
					; DATA XREF: GetCorrectVolo
		db  9,0Ah,0Bh,0Dh,0Fh,10h,12h,14h,18h,18h,1Ah,1Ch,1Fh
		db 21h,23h,26h,28h,2Ah,2Ch,2Eh,30h,32h,34h,36h,38h,3Ah
		db 3Ch,40h,41h,42h,43h,44h,45h,46h,47h,48h,49h,4Ah,4Bh
		db 4Bh,4Bh,4Ch,4Ch,4Dh,4Dh,4Eh,7Fh
VolTable_PSG:	db  0, 0, 8, 8,	8,10h,10h,18h,18h,18h,20h,20h,28h,28h
					; DATA XREF: GetCorrectVol+Ao
		db 28h,30h,30h,30h,38h,38h,38h,38h,38h,40h,40h,40h,40h
		db 40h,40h,48h,48h,48h,48h,48h,48h,48h,50h,50h,50h,50h
		db 50h,50h,50h,50h,58h,58h,58h,58h,58h,58h,58h,58h,58h
		db 60h,60h,60h,60h,60h,60h,60h,68h,68h,70h,78h
		db 33h			; num of entries for instrument	table
InstrumentTable: db 0Ch,0F0h,0C0h,21h, 2, 5, 8, 1, 6,24h,77h, 5,0Ch,72h,	6, 0,0F4h, 0, 0
					; DATA XREF: ProcessHwCh+2C1o
		db  5,0F0h,0C0h,18h, 4,	7,18h, 3, 7,13h, 2, 7,13h, 1, 7, 0,0F4h, 5, 0
		db 3Ch,0F0h,0C0h,14h, 1, 8,18h,	2, 9,1Fh, 1,0Ah,18h, 2,	9, 0,0F4h, 5, 0
		db  5,0F0h,0C0h,2Bh, 1,	7,14h, 8,0Bh,17h, 4,0Bh,11h, 1,0Bh, 0,0F4h, 0, 0
		db 34h,0F0h,0C0h,1Fh,3Fh,0Ch,0Fh, 1,0Dh,1Fh, 1,0Eh,16h,	1,0Fh, 0,0F4h, 0, 0
		db 34h,0F0h,0C0h,1Ah,31h,10h,11h,52h,11h,20h,50h,12h,0Bh,30h,11h, 0,0F4h, 5, 0
		db 33h,0F0h,0C0h,16h, 1,13h,13h, 2,14h,1Dh, 1,15h, 5, 2,16h, 0,0E8h, 0,	0
		db  3,0F0h,0C0h,26h,0Ah,13h,25h, 3,17h,	8, 2,18h,0Ch, 1,19h, 0,0E8h, 0,	0
		db 38h,0F0h,0C0h,25h, 2,1Ah,0Bh, 0,1Bh,0Dh, 0,1Ch,0Ch, 1,1Dh, 0,0F4h, 0, 0
		db  9,0F0h,0C0h,16h,0Fh,1Eh,30h, 4,1Fh,20h, 1,20h,0Ch, 1,21h, 0,0E8h, 0, 0
		db 3Bh,0F0h,0C0h, 1,14h,22h,15h, 3,23h,	8, 2,24h,10h, 1,25h, 0,0F4h, 0,	0
		db 3Ch,0F0h,0C0h,28h,0Eh,26h,15h, 2,27h,1Eh, 4,28h,0Ch,	2,29h, 0,0F4h, 0, 0
		db  3,0F0h,0C0h,0Bh, 2,2Ah,0Dh,	1,2Bh,23h,0Bh,2Ah, 0, 1,2Ch, 0,	0, 0, 0
		db 3Dh,0F0h,0C0h,10h, 1,2Dh, 0,	1,2Eh, 3, 2,2Fh, 7, 9,2Fh, 0, 0, 0, 0
		db 2Bh,0F0h,0C0h,1Dh,61h,30h,20h, 2,30h,36h,23h,30h, 0,	2,31h, 0, 0, 0,	0
		db  4,0F0h,0C0h,16h, 7,32h, 0, 5,33h,20h,79h,32h, 0,71h,33h, 0,	0, 0, 0
		db 3Ch,0F0h,0C0h, 7,0Fh,34h, 8,	0,35h,16h, 2,36h, 0, 0,37h, 0, 0, 0, 0
		db  0,0F0h,0C0h,2Dh, 2,38h,1Dh,0Fh,39h,10h, 3,3Ah, 7, 1,3Bh, 0,	0, 2, 0
		db 3Bh,0F0h,0C0h, 5,0Ch,3Ch,0Ah, 7,3Dh,1Dh,79h,3Eh, 0,72h,3Fh, 0, 0, 0,	0
		db 39h,0D0h,0C0h, 0, 1,40h,7Fh,	0, 0,2Eh,79h,41h,0Ch,78h,42h, 0, 0, 0, 0
		db 39h,0B0h,0C0h, 0, 1,40h,7Fh,	0, 0,2Ch,79h,41h, 8,78h,43h, 0,	0, 0, 0
		db 3Ch,0F0h,0C0h,28h, 2,44h,0Ch, 1,45h,28h,72h,44h,18h,71h,45h,	0, 0, 0, 0
		db  4,0F0h,0C0h,12h,14h,46h,16h,14h,47h,12h, 8,46h,16h,	4,47h, 0, 0, 0,	0
		db  4,0F0h,0C0h, 7, 6,48h, 3, 1,49h,15h, 1,4Ah,	3, 0,4Bh, 0, 0,	2, 0
		db 3Bh,0F0h,0C0h, 0, 8,4Ch,20h,0Fh,4Dh,3Dh,0Fh,4Eh, 4,0Ch,4Fh, 0, 0, 0,	0
		db 3Bh,0F0h,0C0h, 0, 8,4Ch,20h,0Fh,4Dh,3Dh,0Fh,4Eh, 6,0Ch,50h, 0, 0, 0,	0
		db 3Bh,0F0h,0C0h, 4, 3,4Ch, 6, 1,4Dh,22h, 4,4Eh, 5, 0,51h, 0, 0, 0, 0
		db 39h,0F0h,0C0h,10h,0Dh,52h,25h, 6,52h,23h, 1,52h, 0, 1,53h, 0, 0, 0, 0
		db 14h,0F0h,0C0h,2Ah,0Dh,54h,10h, 4,55h,2Ch,76h,54h,10h,71h,55h, 0,0F4h, 1, 0
		db 0Ch,0F0h,0C0h,2Ch, 3, 5,10h,	1,56h,24h,7Eh, 5, 8,48h,57h, 0,0F4h, 1,	0
		db 39h,0D0h,0C0h, 0, 1,40h,7Fh,	0, 0,2Ch,79h,41h, 8,78h,43h, 0,	0, 0, 0
		db 0Ch,0F0h,0C0h,22h,44h,58h,13h,43h,59h,1Ch,72h,59h,10h, 1,5Ah, 0,0F4h, 0, 0
		db 14h,0F0h,0C0h,1Ah, 1,5Bh,10h,61h,5Ch,1Ch,67h,5Dh,10h, 1,5Eh,	0,0F4h,	0, 0
		db 3Ch,0F0h,0C0h,1Ch,72h,5Fh,13h,72h,60h,21h,34h,5Fh,13h,32h,60h, 0,0E8h, 1, 0
		db 22h,0F0h,0C0h,28h,75h,61h,32h,43h,62h,1Ah,20h,61h,10h,30h,63h, 0, 0,	1, 0
		db 12h,0F0h,0C0h,20h,51h,64h,2Bh, 5,65h,28h,30h,66h,0Ch,30h,67h, 0, 0, 0, 0
		db 3Ch,0F0h,0C0h,2Ah,3Ch,68h,12h,21h,69h,20h,31h,68h,10h,71h,6Ah, 0,0F4h, 0, 0
		db 12h,0F0h,0C0h,2Fh,51h,64h,28h, 5,65h,24h,30h,66h,0Fh,31h,6Bh, 0, 0, 0, 0
		db  4,0F0h,0C0h, 7, 6,48h,0Ch, 1,49h,15h, 1,4Ah,0Ch, 0,4Bh, 0,0F4h, 1, 0
		db 28h,0F0h,0C0h,1Fh, 8,6Ch,22h,33h,6Dh,28h, 3,5Eh,0Ch,	1,5Ch, 0,0F4h, 1, 0
		db 3Ah,0F0h,0C0h,20h,34h,6Eh,18h,62h,6Fh,18h,34h,70h,12h,32h,71h, 0,0E8h, 5, 0
		db 3Eh,0F0h,0C0h,24h,74h,72h,16h, 1,73h,0Fh,71h,73h,0Fh, 2,73h,	0,0F4h,	5, 0
		db 12h,0F0h,0C0h,2Fh,51h,64h,28h, 5,65h,24h,30h,66h,0Fh,31h,6Bh, 0, 0, 8, 0
		db 3Eh,0F0h,0C0h,24h,74h,72h,16h, 1,73h,0Fh,71h,73h,0Fh, 2,73h,	0,0F4h,	9, 0
		db 3Bh,0F0h,0C0h, 1,14h,22h,15h, 3,23h,	8, 2,24h,0Ch, 1,25h, 0,0F4h,0Ah, 0
		db 3Ch,0F0h,0C0h,15h, 3,34h, 6,	6,35h,16h,0Bh,36h, 2, 1,37h, 0,	0, 0, 0
		db 30h,0F0h,0C0h,10h,30h,74h, 4,31h,75h,20h,31h,75h, 4,31h,39h,	0,0Ch, 0, 0
		db  4,0F0h,0C0h,1Ch, 6,48h, 4, 1,76h,15h, 1,4Ah, 4, 0,76h, 0,0F4h,0Ah, 0
		db 33h,0F0h,0C0h,16h, 1,13h,13h, 2,14h,1Dh, 1,15h, 5, 2,16h, 0,	0,0Bh, 0
		db 33h,0F0h,0C0h,16h, 1,13h,23h, 2,14h,1Dh,0Fh,15h, 0,0Fh,16h, 0, 0,0Ch, 0
		db 38h,0F0h,0C0h, 0, 7,57h, 0, 3,44h, 0, 1,57h,	8, 0,52h, 0, 0,0Ah, 0
		db 5Fh			; not a	number of entries for the table	below
InstrumentRateList: db  0, 0, 0,	0	; DATA XREF: DoInstrumentGroup+1Co
		db 1Fh,	4, 4,35h
		db 1Fh,12h, 4,64h
		db 1Fh,18h, 0,2Eh
		db  0, 0, 0, 0
		db 1Fh,	4, 4,35h
		db 1Fh,12h, 4,64h
		db 1Fh,18h, 0,2Eh
		db 1Ah,12h, 0,29h
		db 1Dh,80h, 0,4Bh
		db 1Fh,87h, 0,99h
		db 50h,0Eh, 0,18h
		db 1Fh,11h, 4,8Bh
		db 1Bh,	8,0Ch,87h
		db 1Eh,	7, 4,47h
		db 1Eh,0Bh, 0,0F8h
		db 1Fh,1Fh, 0, 3
		db 11h,1Fh, 0, 7
		db 11h,1Fh, 0,0Fh
		db 97h,0Fh, 0,0C0h
		db 97h,11h,11h,4Eh
		db 5Fh,	7, 7,0BFh
		db 1Fh,18h, 9,29h
		db 5Fh,0Fh, 2,96h
		db 9Bh,15h, 4,76h
		db 1Fh,1Ch, 6, 8
		db 5Ah,0Dh, 3,5Ch
		db 58h,17h,0Eh,3Ah
		db 9Eh,17h, 7,58h
		db 9Eh,0Dh,0Ch,37h
		db 5Fh,18h, 0,0FFh
		db 1Fh,0Bh, 0,0FFh
		db 5Fh,	7, 2,88h
		db 1Fh,	9, 2,88h
		db 17h,97h, 3,77h
		db 1Fh,87h, 1,94h
		db 5Bh,94h, 1,74h
		db 1Fh,97h, 1, 8
		db 56h,0Dh, 3,5Ch
		db 94h,17h,0Eh,0Ah
		db 9Eh,0Fh, 5,67h
		db 5Bh,0Ch,0Ah,36h
		db 1Fh,17h,0Fh,0Dh
		db 5Fh,17h,0Fh,2Eh
		db 5Fh,0Dh,0Dh,2Ah
		db 97h,0Fh, 4,48h
		db 1Dh,	1, 1,18h
		db 1Dh,	1, 1,28h
		db 19h,	3, 0,22h
		db 0Dh,	5, 0,27h
		db 1Fh,	7, 0,0A0h
		db 1Fh,0Fh, 4,37h
		db 1Fh,16h, 4,18h
		db 1Ah,11h,11h,9Ch
		db 1Dh,12h,13h,98h
		db 1Bh,0Fh,0Fh,29h
		db 1Fh,0Eh,0Ch,5Bh
		db 1Bh,	9, 6,74h
		db 9Fh,0Dh, 4,54h
		db 18h,0Fh,0Bh,36h
		db 1Fh,18h,1Bh,7Fh
		db 1Fh,	2, 1,2Dh
		db 1Fh,	7, 0,0A7h
		db 1Ah,12h,16h,3Dh
		db 1Fh,18h,1Bh,7Fh
		db 1Fh,	7, 0,0A7h
		db 1Dh,10h, 0,8Dh
		db 1Fh,12h,12h,5Dh
		db 1Fh,0Ch,0Ch,0DFh
		db 1Fh,14h,1Ah,0DDh
		db 1Fh,	9, 2,0CBh
		db 1Fh,10h,14h,0DBh
		db 1Fh,1Bh, 7,89h
		db 1Fh,13h,11h,39h
		db 1Fh,11h, 2,25h
		db 1Fh,11h,0Bh,45h
		db 1Fh,1Fh, 0,16h
		db 1Fh,1Fh, 4,16h
		db 1Fh,1Ch, 0, 6
		db 5Fh,11h, 4,0D8h
		db 5Fh,14h,0Bh,18h
		db 5Fh,10h,10h,5Dh
		db 1Fh,0Ch,0Ah,1Fh
		db 1Bh,15h,17h,0CFh
		db 59h,0Fh,0Eh,79h
		db 57h,10h, 8,47h
		db 1Dh,11h, 2,46h
		db 5Fh,12h, 2,96h
		db 1Fh,1Fh, 5,56h
		db 12h,11h, 8,27h
		db 12h,10h, 7, 7
		db 59h,1Ch, 0,0E6h
		db 5Fh,0Ch, 0,0E6h
		db 5Fh,	3, 0,0E6h
		db 1Fh,0Eh, 0,0E7h
		db 1Fh,	1, 1,14h
		db 10h,	3, 1,26h
		db 12h,	4, 3,25h
		db 0Dh,	8, 0,37h
		db 10h,	8, 0, 6
		db 58h,	1, 3, 5
		db 0DBh, 5, 1, 5
		db 96h,	1, 1,0D6h
		db 96h,0Ah, 1,36h
		db 9Ah,	4, 9,25h
		db 9Ah,0Ch, 8,26h
		db 96h,	9, 7,27h
		db 4Fh,	1, 5,0D6h
		db 5Fh,	9, 0, 6
		db 5Fh,0Ah, 0, 9
		db 1Fh,14h, 6, 5
		db 1Fh,10h, 0, 9
		db 1Fh,	5, 5,86h
		db 5Ch,1Ah, 0, 6
		db 1Fh,	0, 6, 4
		db 0Fh,	8, 8, 7
		db 1Fh,	8, 8,3Eh
		db 1Fh,	5, 6,2Eh
		db 1Fh,0Ch,14h,45h
		db 11h			; num of entries for the table below
EnvelopeData:	db 4Fh,	1, 1, 0, 0, 0	; DATA XREF: ProcessHwCh+366o
		db 60h,	11h, 15h, 1, 1,	0
		db 68h,	18h, 8,	1, 0, 0
		db 60h,	3, 1, 5, 0, 0
		db 70h,	2, 5, 2, 0, 0
		db 7Fh,	5, 1, 1, 0, 0
		db 68h,	1, 1, 1, 3, 0
		db 68h,	1, 1, 2, 4, 0
		db 68h,	1, 1, 2, 6, 0
		db 68h,	1, 8, 6, 0, 0
		db 68h,	1, 8, 3, 7, 0
		db 60h,	3, 2, 6, 0Ah, 0
		db 68h,	1, 4, 3, 0Ah, 0
		db 68h,	1, 1, 0, 0Bh, 0
		db 68h,	1, 4, 0, 0Ah, 0
		db 68h,	1, 11h,	3, 3, 0
		db 68h,	1, 11h,	7, 0Dh,	0
		db 8			; num of entries for the table below
EnvelopeTracker: dw byte_189F, byte_18AD, byte_18B6, byte_18C6, byte_18DA, byte_18E2
					; DATA XREF: ProcessHwCh+380o
		dw byte_18F3, byte_18F7
byte_189F:	db 7, 15h, 25h,	35h, 45h, 5Fh ;	DATA XREF: ROM:EnvelopeTrackero
		db 6Fh,	7Fh, 8Fh, 9Fh, 0AFh, 0BFh
		db 0CFh, 0D0h
byte_18AD:	db 32h,	22h, 12h, 8, 14h, 24h ;	DATA XREF: ROM:EnvelopeTrackero
		db 34h,	44h, 50h
byte_18B6:	db 3, 13h, 23h,	31h, 41h, 51h ;	DATA XREF: ROM:EnvelopeTrackero
		db 61h,	71h, 81h, 91h, 0A1h, 0B1h
		db 0C1h, 0D1h, 0E1h, 0F0h
byte_18C6:	db 41h,	31h, 21h, 11h, 8, 1Fh ;	DATA XREF: ROM:EnvelopeTrackero
		db 1Fh,	2Fh, 2Fh, 3Fh, 3Fh, 4Fh
		db 5Fh,	6Fh, 7Fh, 8Fh, 9Fh, 0AFh
		db 0BFh, 0C0h
byte_18DA:	db 0, 0, 0, 0, 0, 0	; DATA XREF: ROM:EnvelopeTrackero
		db 0, 0
byte_18E2:	db 1, 0F1h, 1, 0F1h, 1,	0F1h ; DATA XREF: ROM:EnvelopeTrackero
		db 1, 0F1h, 1, 0F1h, 1,	0F1h
		db 1, 0F1h, 1, 0F1h, 0
byte_18F3:	db 3, 13h, 23h,	30h	; DATA XREF: ROM:EnvelopeTrackero
byte_18F7:	db 0A2h, 92h, 84h, 74h,	68h, 58h ; DATA	XREF: ROM:EnvelopeTrackero
		db 48h,	38h, 20h
		db 0Eh			; num of entries for the table below
ModTrackerdata:	dw byte_191D, byte_191E, byte_192B, byte_192F, byte_193F, byte_1952
					; DATA XREF: LoadTrackers+7o
		dw byte_197D, byte_199E, byte_19A7, byte_19B2, byte_19BE, byte_19C7
		dw byte_19CD, byte_19D3
byte_191D:	db 0			; DATA XREF: ROM:ModTrackerdatao
byte_191E:	db 0F9h, 4, 4, 0, 0, 8	; DATA XREF: ROM:ModTrackerdatao
		db 0FFh, 0FFh, 0FCh, 10h, 0FFh,	26h
		db 19h
byte_192B:	db 40h,	0F8h, 0FFh, 0FAh ; DATA	XREF: ROM:ModTrackerdatao
byte_192F:	db 12h,	0F0h, 0FFh, 4, 12h, 0 ;	DATA XREF: ROM:ModTrackerdatao
		db 4, 22h, 0, 4, 32h, 0
		db 35h,	42h, 0,	0FAh
byte_193F:	db 1, 1Fh, 0, 1, 22h, 5	; DATA XREF: ROM:ModTrackerdatao
		db 1, 11h, 2, 1, 22h, 0FFh
		db 1, 30h, 3, 1, 30h, 0FFh
		db 0FAh
byte_1952:	db 5, 0, 0, 0F9h, 2, 0FDh ; DATA XREF: ROM:ModTrackerdatao
		db 4, 0Ch, 0FFh, 0FFh, 0Ch, 1
		db 0, 0FEh, 0FDh, 4, 0Ch, 0FFh
		db 0FFh, 0Ch, 1, 0, 0FEh, 0F9h
		db 1, 0FDh, 4, 18h, 0FEh, 0FFh
		db 18h,	2, 0, 0FEh, 18h, 0FDh
		db 0FFh, 18h, 3, 0, 0FFh, 74h
		db 19h
byte_197D:	db 1, 0E0h, 0FEh, 1, 10h, 7 ; DATA XREF: ROM:ModTrackerdatao
		db 1, 10h, 0FAh, 1, 0B0h, 1
		db 1, 0D0h, 0FEh, 1, 0,	6
		db 1, 0D0h, 0F4h, 1, 50h, 0FEh
		db 1, 0B0h, 4, 1, 0, 0FCh
		db 0FFh, 7Dh, 19h
byte_199E:	db 0F8h, 3, 0FFh, 0F8h,	3, 0FFh	; DATA XREF: ROM:ModTrackerdatao
		db 0FFh, 9Eh, 19h
byte_19A7:	db 0F9h, 4, 1, 0, 0Ch, 1 ; DATA	XREF: ROM:ModTrackerdatao
		db 0, 0F4h, 0FFh, 0A9h,	19h
byte_19B2:	db 0FBh, 80h, 0FEh, 0Ch, 20h, 0	; DATA XREF: ROM:ModTrackerdatao
		db 20h,	0, 0, 0FFh, 60h, 19h
byte_19BE:	db 0F8h, 5, 0F0h, 0F8h,	5, 0F0h	; DATA XREF: ROM:ModTrackerdatao
		db 0FFh, 0BEh, 19h
byte_19C7:	db 35h,	0, 0FFh, 0FFh, 0C7h, 19h ; DATA	XREF: ROM:ModTrackerdatao
byte_19CD:	db 65h,	90h, 0FFh, 0FFh, 0CDh, 19h ; DATA XREF:	ROM:ModTrackerdatao
byte_19D3:	db 85h,	3, 0, 0FAh	; DATA XREF: ROM:ModTrackerdatao
		db 3			; number of entried for	the table below
LFOtrackerData:	dw byte_19DE, byte_19DF, byte_19E8 ; DATA XREF:	LoadTrackers+1Ao
byte_19DE:	db 0			; DATA XREF: ROM:LFOtrackerDatao
byte_19DF:	db 0F9h, 4, 4, 0FFh, 0FCh, 0Ah ; DATA XREF: ROM:LFOtrackerDatao
		db 0FFh, 0E3h, 19h
byte_19E8:	db 0F9h, 2, 10h, 0FFh, 0FCh, 20h ; DATA	XREF: ROM:LFOtrackerDatao
		db 0FFh, 0ECh, 19h
DrumMaps:	db  0,20h,17h,10h	; DATA XREF: PlayNoteFreeCh+17o
					; ch ram to use	(0 = FM	| 1 = PSG | 2 =	PSG4), channels	to check. 1 bit	per channel, instrument, panning + tempo divider
		dw 400h			; base frequency
		db  0,10h,1Bh,50h, 0,48h
		db  0,10h,0Ch,10h, 0,1Ch
		db  0,20h,0Ch,10h, 0,20h
		db  0,10h,0Ch,10h, 0,24h
		db  0,20h,10h,10h, 0,0Eh
		db  0,20h,12h,10h, 0, 3
		db  0,10h,13h, 9, 0, 7
		db  0,10h,14h,90h, 0,0Eh
		db  0,20h,15h,50h, 0,54h
		db  0,10h,16h,50h, 0,48h
		db  0,10h,16h,10h, 0,54h
		db  0,20h,17h,50h, 0,14h
		db  0,20h,17h,10h, 0,1Ah
		db  0,20h,17h,90h, 0,22h
		db  0,10h,18h,8Ah, 0,47h
		db  0,10h,19h,8Eh, 0,47h
		db  0,20h,1Ah,10h, 0,12h
		db  0,10h,1Eh,50h, 0, 9
		db  0,10h,2Ah,50h, 0,5Fh
		db  0,20h,11h,90h, 0,0Fh
		db  0,20h,11h,50h, 0, 8
		dw byte_11FF
; end of 'ROM'

; ===========================================================================
; Segment type:	Regular
	;	segment	RAM
ramstart =	*
		rsset *
		rs.b 109h
DebugAF:	rs.b 2			; DATA XREF: sub_1:inito
					; DebugStuff+1Dw ...
DebugBC:	rs.b 2			; DATA XREF: DebugStuffw
					; DebugStuff:loc_105Er
DebugDE:	rs.b 2			; DATA XREF: DebugStuff+4w
					; DebugStuff+D6r
DebugHL:	rs.b 2			; DATA XREF: DebugStuff+8w
					; DebugStuff+E6r
DebugIX:	rs.b 2			; DATA XREF: DebugStuff+Bw
DebugIY:	rs.b 2			; DATA XREF: DebugStuff+Fw
DebugRet:	rs.b 2			; DATA XREF: DebugStuff+14w
					; DebugStuff+DEr
DebugStack:	rs.b 2			; DATA XREF: DebugStuff+17w
					; DebugStuff+DAr
DebugAF2:	rs.b 2			; DATA XREF: DebugStuff+24w
DebugBC2:	rs.b 2			; DATA XREF: DebugStuff+28w
DebugDE2:	rs.b 2			; DATA XREF: DebugStuff+2Cw
DebugHL2:	rs.b 2			; DATA XREF: DebugStuff+30w
Debug68kAccess:	rs.b 1			; DATA XREF: DebugStuff+6Cw
					; DebugStuff+EAw
DebugZ80Access:	rs.b 1			; DATA XREF: SyncTimerBr
					; DebugStuff+6Fw ...
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
DebugAddrCopy1:	rs.b 2			; DATA XREF: DebugStuff+40r
					; DebugStuff+81r ...
DebugSizeCopy1:	rs.b 1			; DATA XREF: DebugStuff+34r
					; DebugStuff+78r
DebugBufferCopy1:rs.b 5			; DATA XREF: DebugStuff+3Do
					; DebugStuff+84o
DebugAddrCopy2:	rs.b 2			; DATA XREF: DebugStuff+52r
					; DebugStuff+9Fr ...
DebugSizeCopy2:	rs.b 1			; DATA XREF: DebugStuff:@nocopy1r
					; DebugStuff:@nocopyback1r
DebugBufferCopy2:rs.b 5			; DATA XREF: DebugStuff+4Fo
					; DebugStuff+A2o
DebugAddrCopy3:	rs.b 2			; DATA XREF: DebugStuff+64r
					; DebugStuff+BDr ...
DebugSizeCopy3:	rs.b 1			; DATA XREF: DebugStuff:@nocopy2r
					; DebugStuff:loc_1040r
DebugBufferCopy3:rs.b 5			; DATA XREF: DebugStuff+61o
					; DebugStuff+C0o
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
ModFreqBasePos:	rs.b 1			; DATA XREF: ProcessHwChs+5w
					; ProcessHwChs+1Bo ...
ModFreqBaseData:rs.b 9			; DATA XREF: GetModFreqBase+3o
SndQueueAccess:	rs.b 1			; DATA XREF: sub_1+ACw	LoadSound+2w ...
		rs.b 1
MainLoopCtr:	rs.b 1			; DATA XREF: sub_1:ProcessHww
					; sub_1+D7r
Paused:		rs.b 1			; DATA XREF: SyncTimerB+Er ROM:02DCo ...
TimerBctr:	rs.b 2			; DATA XREF: SyncTimerB+1Er
					; SyncTimerB+22w
					; unused
TempoCount:	rs.b 1			; DATA XREF: sub_1+B0w	sub_1+CFo ...
SlotCounter:	rs.b 1			; DATA XREF: ROM:@chloopw ROM:02D4r ...
TempVol:	rs.b 1			; DATA XREF: ProcessHwCh:@volcapnow
					; ProcessHwCh-114r
FadeCounter:	rs.b 1			; DATA XREF: VolumeControl:FadeControlr
					; VolumeControl+24w ...
FadeAmount:	rs.b 1			; DATA XREF: VolumeControl+12r
					; VolumeControl:@ContFadingw ...
MasterVol:	rs.b 1			; DATA XREF: VolumeControl+9w
					; VolumeControl+27w ...
FadeSpeed:	rs.b 2			; DATA XREF: VolumeControl+15r
					; VolumeControl+42w ...
FadeListPos:	rs.b 2			; DATA XREF: VolumeControl+33r
					; VolumeControl+3Fw ...
YMpartAddr:	rs.b 1			; DATA XREF: WriteGroupOpsw
					; StopChPtr+17w ...
ChannelID:	rs.b 1			; DATA XREF: StopChPtr+9w
					; StopChPtr+10w ...
Temp_OpYM:	rs.b 1			; DATA XREF: DoInstrumentGroupw
					; WriteYMchRAMopr
VolPSG4:	rs.b 1			; DATA XREF: StopChPtr+39w
					; ProcessHwCh:UpdatePSG4Volr ...
MainTempo:	rs.b 2			; DATA XREF: sub_1+C6r	LoadSound+60w ...
TempoAcc:	rs.b 2			; DATA XREF: sub_1+C1r	sub_1+CBw ...
Temp_Timer:	rs.b 2			; DATA XREF: ProcessSlotCh+79w
					; ProcessSlotCh+C4w ...
Temp_Attack:	rs.b 1			; DATA XREF: ProcessSlotCh+6Dw
					; ProcessSlotCh+FFr ...
Temp_NotesNum:	rs.b 1			; DATA XREF: ProcessSlotCh+70w
					; ProcessSlotCh+F5r ...
		rs.b 1			; used in later	games
		rs.b 1
		rs.b 1
		rs.b 1
Temp_Section:	rs.b 1			; DATA XREF: GetLowPrioHwChr
					; PlayNoteFreeCh+1Dw ...
Temp_ChMask:	rs.b 1			; DATA XREF: GetLowPrioHwCh+14r
					; PlayNoteFreeCh+22w ...
Temp_Priority:	rs.b 1			; DATA XREF: GetLowPrioHwCh+27r
					; PlayNoteFreeCh+2Aw ...
YM27val:	rs.b 1			; DATA XREF: sub_1+8Cw	SyncTimerB+25r
Temp_Frequency:	rs.b 2			; DATA XREF: PlayNoteFreeCh+4Dw
					; PlayNoteFreeCh:@nostopr ...
Temp_Tempo:	rs.b 2			; DATA XREF: GetLowPrioHwCh+45r
					; GetLowPrioHwCh+53w ...
Priority:	rs.b 1			; DATA XREF: LoadSound+48w
					; LoadSound+81r ...
		rs.b 1			; used in later	games
VolumeCtrl:	rs.b 2			; DATA XREF: VolumeControlr
					; LoadSound+59w ...
		rs.b 1
MusicSpeedCtrl:	rs.b 1			; DATA XREF: sub_1+A8w	SyncTimerB+7o
SndQueuePos:	rs.b 1			; DATA XREF: LoadSound+13r
					; LoadSound+20w
SndQueueCount:	rs.b 1			; DATA XREF: LoadSound+5r
					; LoadSound+10w
SndQueue:	rs.b 10h		; DATA XREF: LoadSound+19o
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
		rs.b 1
ChannelRAM:	rs.b 240h			; DATA XREF: sub_1+4Co	StopHwCh+5o ...
SlotChannels:	rs.b 140h			; DATA XREF: LoadSound+6Fo
					; LoadSound+A6o ...
; end of 'RAM'
