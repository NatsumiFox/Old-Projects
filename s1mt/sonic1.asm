; /=========================================================================\
; ยบ	This file is generated by The Interactive Disassembler (IDA)	    ยบ
; ยบ	Copyright (c) 2003 by DataRescue sa/nv,	<ida@datarescue.com>	    ยบ
; \=========================================================================/
;
; Disassembly created by Hivebrain
; thanks to drx and Stealth

; Processor:	    68000
; Target Assembler: 680x0 Assembler in MRI compatible mode
; This file should be compiled with "as	-M"

; ===========================================================================
	org 0
align macro
	cnop 0,\1
	endm
	include "equ.asm"

	ChkNext_Obj 		; tell if Next_Obj is not $40

StartOfRom:
Vectors:	dc.l 'COCK', ('S'<<24)|EntryPoint, ('N'<<24)|BusError, ('D'<<24)|AddressError
		dc.l ('I'<<24)|IllegalInstr, ('C'<<24)|ZeroDivide, ('K'<<24)|ChkInstr, ('S'<<24)|TrapvInstr
ErrorTrap:	bra.w *
		dc.l Trace, Line1010Emu, Line1111Emu
		; 64 bytes
loc_348_
		lea	($FFFFFE00).w,a6; 4
		move.w	#$7F,d6		; 4
loc_348:	; 56 bytes
		move.l	d7,(a6)+	; 2
		dbf	d6,loc_348	; 4

		move.b	($A10001).l,d0	; 6
		andi.b	#$C0,d0		; 4
		move.b	d0,HW_Version.w	; 4
		; 36 bytes
GameInit:
		lea	($FF0000).l,a6	; 6
		moveq	#0,d7		; 2
		move.w	#$3F7F,d6	; 4
		; 24 bytes
GameClrRAM:
		move.l	d7,(a6)+	; 2
		dbf	d6,GameClrRAM	; fill RAM ($0000-$FDFF) with $0	; 4
		; 18 bytes

		lea	InterruptMain(pc),a6	; 4
		bsr.w	LoadJump		; 4
		; 10 bytes
		bsr.w	VDPSetupGame		; 4
		bra.w	InitMisc		; 4
		nop				; 2

		dc.l HBlankJump, ErrorTrap, VBlankJump
		; 132 bytes
EntryPoint_:	; 118 bytes
		lea	SetupValues(pc),a5	; 4
		movem.w	(a5)+,d5-d7		; 4
		movem.l	(a5)+,a0-a4		; 4
		move.b	-$10FF(a1),d0	; get hardware version	; 4
		andi.b	#$F,d0			; 4
		beq.s	SkipSecurity		; 2
		move.l	Console.w,$2F00(a1)	; 6

SkipSecurity:	; 86 bytes
		move.w	(a4),d0		; check	if VDP works	; 2

		tst.l	($A10008).l	; test port A control	; 6
		bne.s	PortA_Ok				; 2
		tst.w	($A1000C).l	; test port C control	; 6

PortA_Ok:
		bne.s	PortC_Ok		; 2
		moveq	#0,d0		; 2
		movea.l	d0,a6		; 2
		move.l	a6,usp		; set usp to $0	; 2
		moveq	#$17,d1		; 2

VDPInitLoop:	; 76 bytes
		move.b	(a5)+,d5	; add $8000 to value	; 2
		move.w	d5,(a4)		; move value to	VDP register	; 2
		add.w	d7,d5		; next register	; 2
		dbf	d1,VDPInitLoop	; 4
		; 68 bytes
		move.l	(a5)+,(a4)				; 2
		move.w	d0,(a3)		; clear	the screen	; 2
		move.w	d7,(a1)		; stop the Z80		; 2
		move.w	d7,(a2)		; reset	the Z80		; 2

WaitForZ80:	; 60 bytes
		btst	d0,(a1)		; has the Z80 stopped?	; 2
		bne.s	WaitForZ80	; if not, branch	; 2
		; 56 bytes
		moveq	#$25,d2		; 2

Z80InitLoop:	; 54 bytes
		move.b	(a5)+,(a0)+	; 2
		dbf	d2,Z80InitLoop	; 4
		; 48 bytes
		move.w	d0,(a2)
		move.w	d0,(a1)		; start	the Z80
		move.w	d7,(a2)		; reset	the Z80

ClrRAMLoop:	; 42 bytes
		move.l	d0,-(a6)
		dbf	d6,ClrRAMLoop	; clear	the entire RAM	; 4
		; 36 bytes
		move.l	(a5)+,(a4)
		moveq	#$13,d4

ClrVDPStuff:	; 32 bytes
		move.l	d0,(a3)
		dbf	d4,ClrVDPStuff
		moveq	#3,d5

PSGInitLoop:	; 24 bytes
		move.b	(a5)+,$11(a3)	; reset	the PSG		; 4
		dbf	d5,PSGInitLoop				; 4
		move.w	d0,(a2)					; 2
		movem.l	(a6),d0-a6	; clear	all registers	; 4
		move	#$2700,sr	; set the sr		; 4

PortC_Ok:	; 6 bytes
		moveq	#0,d7		; 2
		bra.w	loc_348_	; 4

		org $100
Console:	dc.b 'SEGA' ; Hardware system ID
		; 12 bytes
LoadJump:
		lea	VBlankJump.w,a5	; 4
		move.l	(a6)+,(a5)+	; 2
		move.l	(a6)+,(a5)+	; 2
		move.l	(a6)+,(a5)+	; 2
		rts			; 2

Date:		include "currentbuild.asm"
		org $120
		; 48 bytes
GameModeArray:	; 36 bytes big
		dc.l	Segascreen	; Sega Screen ($00)
; ===========================================================================
		dc.l	TitleScreen	; Title	Screen ($04)
; ===========================================================================
		dc.l	TrumpScreen	; Demo Mode ($08)
; ===========================================================================
		dc.l	Level		; Normal Level ($0C)
; ===========================================================================
		dc.l	SpecialStage	; Special Stage	($10)
; ===========================================================================
		dc.l	ContinueScreen	; Continue Screen ($14)
; ===========================================================================
		dc.l	EndingSequence	; End of game sequence ($18)
; ===========================================================================
		dc.l	Credits		; Credits ($1C)
; ===========================================================================
		dc.l	BetterGame	; Better Game ($20)
; ===========================================================================
		; 12 bytes
InterruptMain:	jmp	VBlank.l	; 12
		jmp	PalToCRAM.l

Title_Int:	dc.b 'SonicMT.bin                                     ' ; International name
		; 14 bytes
EntryPoint:
		move.l	#$FFFE00,sp	; 6
		bra.w	EntryPoint_	; 2

		illegal
		dc.l $AC1D

Checksum:	dc.w 0
		; 16 bytes
InitMisc:

		bsr.w	SoundDriverLoad	; 4

	SRAMEnable	; 8
		bra.s	SRAM_do		; 2
	; 2
RomStartLoc:	dc.l StartOfRom		; ROM start
RomEndLoc:	dc.l EndOfRom-1		; ROM end
RamStartLoc:	dc.l $FF0000		; RAM start
RamEndLoc:	dc.l $FFFFFF		; RAM end
SRAMSupport:	dc.w 'RA', $F820	; change to $5241F820 (NOT $5241E020) to create SRAM
		dc.l SRAM_Start		; SRAM start
		dc.l SRAM_End		; SRAM end
SRAM_do:	; 52 bytes
		bsr	SRAMInitialize		; make sure the save slot is not deleted while the save is selected	; 4
	SRAMDisable	; 8

		bsr.w	JoypadInit	; 4
		move.b	#0,$FFFFF600.w		; set Game Mode to Sega Screen	; 6
		move.l	#$40000080,DMAQueueMode.w

		; 22 bytes
MainGameLoop:
		move.b	$FFFFF600.w,d0 ; load Game Mode		; 4
		and.w	#$7C,d0		; 4
		lea	GameModeArray.w,a0	; 4
		movea.l	(a0,d0.w),a0	 ; get address	; 4
		jsr	(a0)		 ; jump	; 2
		bra.s	MainGameLoop	; 2
; ===========================================================================
SetupValues:	dc.w $8000		; XREF: PortA_Ok
		dc.w $3FFF
		dc.w $100		; 6

		dc.l $A00000		; start	of Z80 RAM
		dc.l $A11100		; Z80 bus request
		dc.l $A11200		; Z80 reset
		dc.l $C00000
		dc.l $C00004		; address for VDP registers	; 24

		dc.b 4,	$14, $30, $3C	; values for VDP registers
		dc.b 7,	$6C, 0,	0
		dc.b 0,	0, $FF,	0
		dc.b $81, $37, 0, 1
		dc.b 1,	0, 0, $FF
		dc.b $FF, 0, 0,	$80	; 48

		dc.l $40000080		; 52

		dc.b $AF, 1, $D9, $1F, $11, $27, 0, $21, $26, 0, $F9, $77 ; Z80	instructions
		dc.b $ED, $B0, $DD, $E1, $FD, $E1, $ED,	$47, $ED, $4F
		dc.b $D1, $E1, $F1, 8, $D9, $C1, $D1, $E1, $F1,	$F9, $F3
		dc.b $ED, $56, $36, $E9, $E9	; 90

		dc.w $8104		; value	for VDP	display	mode
		dc.w $8F02		; value	for VDP	increment
		dc.l $C0000000		; value	for CRAM write mode
		dc.l $40000010		; 102

		dc.b $9F, $BF, $DF, $FF	; values for PSG channel volumes	; 106

; ===========================================================================
; ---------------------------------------------------------------------------
; Main game mode array
; ---------------------------------------------------------------------------

SRAMInitialize:
		moveq	#0,d5
		moveq	#0,d2
		lea	SRAM_Start,a0		; get first byte of SRAM
		movep.l	SRAM_Initver(a0),d0

		cmp.l	StartOfRom.w,d0		; Check if current SRAM version is same as the one in SRAM file
		bne	SRAMClear		; if different, branch

		movep.w	SRAM_CheckSum(a0),d0	; push it properly to d0
		cmp.w	Checksum.w,d0		; check if same with current SRAM
		beq.s	SRAMend			; if are same, go ahead and check if SRAM is valid

SRAMClear:
		moveq	#(SRAM_Lenght/8),d0	; get right lenght of SRAM fill

SRAMClear2:
		lea	SRAM_InitList(pc),a1

.loop		move.l	(a1)+,d1
		movep.l	d1,0(a0)		; fill 8 bytes with $FF
		addq.l	#8,a0			; get next 8 bytes
		dbf	d0,.loop		; loop until 0

		lea	SRAM_Start,a0		; get first byte of SRAM
		move.w	Checksum.w,d0		; move checksum to d0
		movep.w	d0,SRAM_CheckSum(a0)	; move d0 to SRAM Checksum
		move.l	StartOfRom.w,d0
		movep.l	d0,SRAM_Initver(a0)	; set the init version to right one
		move.l	Console.w,d0
		movep.l	d0,SRAM_Sega(a0)	; set the init version to right one

		; check if SRAM works!
		movep.l	SRAM_Sega(a0),d0
		cmp.l	Console.w,d0
		beq.s	SRAMend
		moveq	#-1,d5
SRAMend:
		rts
; ===========================================================================

SRAM_InitList:
		dc.b 'YIFFING TIME DOESN''T LIKE WHEN YOU TAMPER WITH ROM AND SRAM!'
		dc.b 0,3,0,0,0
		dc.l Start_Rings,0
		even
; ===========================================================================
ArtNem_Title_SonicSprites:	incbin 's3k/Nemesis Art/S3 Sonic Sprites.bin'
	even
ArtNem_TitleScreenText:		incbin 's3k/Nemesis Art/SK Screen Text.bin'
	even
ArtNem_Title_ANDKnuckles:	incbin 's3k/Nemesis Art/SK ANDKnuckles.bin'
	even
ArtNem_Title_S3Banner:		incbin 's3k/Nemesis Art/S3 Banner.bin'
	even
MapEni_S3TitleBg:		incbin 's3k/Enigma Map/S3 BG.bin'
	even

MapEni_S3TitleSonic1:		incbin 's3k/Enigma Map/S3 Sonic 1.bin'
	even
MapEni_S3TitleSonic2:		incbin 's3k/Enigma Map/S3 Sonic 2.bin'
	even
MapEni_S3TitleSonic3:		incbin 's3k/Enigma Map/S3 Sonic 3.bin'
	even
MapEni_S3TitleSonic4:		incbin 's3k/Enigma Map/S3 Sonic 4.bin'
	even
MapEni_S3TitleSonic5:		incbin 's3k/Enigma Map/S3 Sonic 5.bin'
	even
MapEni_S3TitleSonic6:		incbin 's3k/Enigma Map/S3 Sonic 6.bin'
	even
MapEni_S3TitleSonic7:		incbin 's3k/Enigma Map/S3 Sonic 7.bin'
	even
MapEni_S3TitleSonic8:		incbin 's3k/Enigma Map/S3 Sonic 8.bin'
	even
MapEni_S3TitleSonic9:		incbin 's3k/Enigma Map/S3 Sonic 9.bin'
	even
MapEni_S3TitleSonicA:		incbin 's3k/Enigma Map/S3 Sonic A.bin'
	even
MapEni_S3TitleSonicB:		incbin 's3k/Enigma Map/S3 Sonic B.bin'
	even
MapEni_S3TitleSonicC:		incbin 's3k/Enigma Map/S3 Sonic C.bin'
	even
MapEni_S3TitleSonicD:		incbin 's3k/Enigma Map/S3 Sonic D.bin'
	even

Pal_Title:			incbin 's3k/Palettes/S3.bin'
	even
Pal_TitleSonic1:		incbin 's3k/Palettes/S3 sonic 1.bin'
	even
Pal_TitleSonic2:		incbin 's3k/Palettes/S3 sonic 2.bin'
	even
Pal_TitleSonic3:		incbin 's3k/Palettes/S3 sonic 3.bin'
	even
Pal_TitleSonic4:		incbin 's3k/Palettes/S3 sonic 4.bin'
	even
Pal_TitleSonic5:		incbin 's3k/Palettes/S3 sonic 5.bin'
	even
Pal_TitleSonic6:		incbin 's3k/Palettes/S3 sonic 6.bin'
	even
Pal_TitleSonic7:		incbin 's3k/Palettes/S3 sonic 7.bin'
	even
Pal_TitleSonic8:		incbin 's3k/Palettes/S3 sonic 8.bin'
	even
Pal_TitleSonic9:		incbin 's3k/Palettes/S3 sonic 9.bin'
	even
Pal_TitleSonicA:		incbin 's3k/Palettes/S3 sonic A.bin'
	even
Pal_TitleSonicB:		incbin 's3k/Palettes/S3 sonic B.bin'
	even
Pal_TitleSonicC:		incbin 's3k/Palettes/S3 sonic C.bin'
	even
Pal_TitleSonicD:		incbin 's3k/Palettes/S3 sonic D.bin'
	even

; ===========================================================================
	include 's3l/inc.asm'
	include 'thebettergame.asm'
	include 'dos.asm'
; ===========================================================================

BusError:
		move.b	#2,($FFFFFC44).w
		bra.s	loc_43A
; ===========================================================================

AddressError:
		move.b	#4,($FFFFFC44).w
		bra.s	loc_43A
; ===========================================================================

IllegalInstr:
		move.b	#6,($FFFFFC44).w
		addq.l	#2,2(sp)
		bra.s	loc_462
; ===========================================================================

ZeroDivide:
		move.b	#8,($FFFFFC44).w
		bra.s	loc_462
; ===========================================================================

ChkInstr:
		move.b	#$A,($FFFFFC44).w
		bra.s	loc_462
; ===========================================================================

TrapvInstr:
		move.b	#$C,($FFFFFC44).w
		bra.s	loc_462
; ===========================================================================

PrivilegeViol:
		move.b	#$E,($FFFFFC44).w
		bra.s	loc_462
; ===========================================================================

Trace:
		move.b	#$10,($FFFFFC44).w
		bra.s	loc_462
; ===========================================================================

Line1010Emu:
		move.b	#$12,($FFFFFC44).w
		addq.l	#2,2(sp)
		bra.s	loc_462
; ===========================================================================

Line1111Emu:
		move.b	#$14,($FFFFFC44).w
		addq.l	#2,2(sp)
		bra.s	loc_462
; ===========================================================================

ErrorExcept:
		move.b	#0,($FFFFFC44).w
		bra.s	loc_462
; ===========================================================================

loc_43A:
		move	#$2700,sr
		addq.w	#2,sp
		move.l	(sp)+,($FFFFFC40).w
		addq.w	#2,sp
		movem.l	d0-a7,DestroyTable.w
		bsr.w	ShowErrorMsg
		move.l	2(sp),d0
		bsr.w	sub_5BA
		move.l	($FFFFFC40).w,d0
		bsr.w	sub_5BA
		bra.s	loc_478
; ===========================================================================

loc_462:
		move	#$2700,sr
		movem.l	d0-a7,DestroyTable.w
		bsr.w	ShowErrorMsg
		move.l	2(sp),d0
		bsr.w	sub_5BA

loc_478:
		bsr.w	ErrorWaitForC
		movem.l	DestroyTable.w,d0-a7
		move	#$2300,sr
		rte

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ShowErrorMsg:				; XREF: loc_43A; loc_462
		lea	VDP_Data_Port,a6

		move.w	#$8B00+%00000000,VDP_Control_Port; VScroll off, HScroll off
		move.w	#$8164+%00000000,VDP_Control_Port; enable disp

		move.l	#$7C000003,VDP_Control_Port
		move.l	#0,(a6)
		move.l	#$40000010,VDP_Control_Port
		move.l	#0,(a6)

		move.l	#$C0200000,VDP_Control_Port ; position
		moveq	#($60/4)-1,d0
		moveq	#0,d1

.loop		move.l	d1,(a6)
		dbf	d0,.loop

		move.l	#$40200000,VDP_Control_Port
		lea	Art_Text,a0
		move.w	#$27F,d1

Error_LoadGfx:
		move.w	(a0)+,(a6)
		dbf	d1,Error_LoadGfx

		moveq	#0,d0		; clear	d0
		move.b	$FFFFFC44.w,d0 	; load error code
		move.w	ErrorText(pc,d0.w),d0
		lea	ErrorText(pc,d0.w),a0
		move.l	#$46040003,VDP_Control_Port ; position
		moveq	#$12,d1		; number of characters

Error_LoopChars:
		moveq	#0,d0
		move.b	(a0)+,d0
		addi.w	#$8001-$30,d0
		move.w	d0,(a6)
		dbf	d1,Error_LoopChars ; repeat for	number of characters
		rts

; End of function ShowErrorMsg

; ===========================================================================
ErrorText:	dc.w asc_4E8-ErrorText,	asc_4FB-ErrorText ; XREF: ShowErrorMsg
		dc.w asc_50E-ErrorText,	asc_521-ErrorText
		dc.w asc_534-ErrorText,	asc_547-ErrorText
		dc.w asc_55A-ErrorText,	asc_56D-ErrorText
		dc.w asc_580-ErrorText,	asc_593-ErrorText
		dc.w asc_5A6-ErrorText
asc_4E8:	dc.b 'ERROR EXCEPTION    '
asc_4FB:	dc.b 'BUS ERROR          '
asc_50E:	dc.b 'ADDRESS ERROR      '
asc_521:	dc.b 'ILLEGAL INSTRUCTION'
asc_534:	dc.b '@ERO DIVIDE        '
asc_547:	dc.b 'CHK INSTRUCTION    '
asc_55A:	dc.b 'TRAPV INSTRUCTION  '
asc_56D:	dc.b 'PRIVILEGE VIOLATION'
asc_580:	dc.b 'TRACE              '
asc_593:	dc.b 'LINE 1010 EMULATOR '
asc_5A6:	dc.b 'LINE 1111 EMULATOR '
		even

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_5BA:				; XREF: loc_43A; loc_462
		move.w	#$800B,(a6)
		moveq	#7,d2

loc_5C0:
		rol.l	#4,d0
		bsr.s	sub_5CA
		dbf	d2,loc_5C0
		rts
; End of function sub_5BA


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_5CA:				; XREF: sub_5BA
		move.w	d0,d1
		andi.w	#$F,d1
		cmpi.w	#$A,d1
		blo.s	loc_5D8
		addq.w	#7,d1

loc_5D8:
		addi.w	#$8001,d1
		move.w	d1,(a6)
		rts
; End of function sub_5CA


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ErrorWaitForC:				; XREF: loc_478
		bsr.w	ReadJoypads
		cmpi.b	#$20,($FFFFF605).w ; is	button C pressed?
		bne.w	ErrorWaitForC	; if not, branch
		jmp	EntryPoint
; End of function ErrorWaitForC

; ===========================================================================

Art_Text:	incbin	artunc\menutext.bin	; text used in level select and debug mode
		even

; ===========================================================================

VBlank:				; XREF: Vectors
		movem.l	d0-a6,-(sp)
		tst.b	VBlank_Routine.w
		beq	loc_B88
		move.w	VDP_Control_Port,d0
		move.l	#$40000010,VDP_Control_Port
		move.l	($FFFFF616).w,VDP_Data_Port
		btst	#6,HW_Version.w
		beq.s	loc_B42
		move.w	#$700,d0

loc_B3E:
		dbf	d0,loc_B3E

loc_B42:
		move.b	VBlank_Routine.w,d0
		sf	VBlank_Routine.w
		st	$FFFFF64F.w
		andi.w	#$3E,d0
		move.w	off_B6E(pc,d0.w),d0
		jsr	off_B6E(pc,d0.w)

loc_B5E:				; XREF: loc_B88
		move    #$2300,sr               ; enable interrupts (we can accept horizontal interrupts from now on)
                bset    #0,Music_Updating.w	; set "SMPS running flag"
                bne.s   loc_B64			; if it was set already, don't call another instance of SMPS
                jsr     UpdateMusic             ; run SMPS
                sf	Music_Updating.w	; reset "SMPS running flag"

		bsr	PlayMusicFromFade
		bsr	PaletteModification

loc_B64:				; XREF: loc_D50
		addq.l	#1,($FFFFFE0C).w
		movem.l	(sp)+,d0-a6
		rte
; ===========================================================================
off_B6E:	dc.w loc_B88-off_B6E, loc_C32-off_B6E
		dc.w loc_C44-off_B6E, loc_C5E-off_B6E
		dc.w loc_C6E-off_B6E, loc_DA6-off_B6E
		dc.w loc_E72-off_B6E, loc_F8A-off_B6E
		dc.w loc_C64-off_B6E, loc_F9A-off_B6E
		dc.w loc_C36-off_B6E, loc_FA6-off_B6E
		dc.w loc_E72-off_B6E, titleint-off_b6e
		dc.w GHZ2BossInt-off_B6E, VBetterGame-off_b6e
; ===========================================================================

loc_B88:				; XREF: VBlank; off_B6E
		addq.b	#1,Freecycles+3.w
		cmpi.b	#$8C,($FFFFF600).w
		beq.s	loc_B9A
		cmpi.b	#$C,($FFFFF600).w
		bne.w	loc_B5E

loc_B9A:
		tst.l	Water_Array.w	; check if has water
		bmi.w	loc_B5E		; if not, branch
		move.w	VDP_Control_Port,d0
		btst	#6,HW_Version.w		; is NTSC
		beq.s	loc_BBA			; if is, branch
		move.w	#$700,d0

loc_BB6:
		dbf	d0,loc_BB6

loc_BBA:
		st	$FFFFF64F.w
		tst.b	($FFFFF64E).w
		bne.s	loc_BFE
		dma68kToVDP	Palette_NCurr,0,$80,CRAM
		bra.s	loc_C22
; ===========================================================================

loc_BFE:
		dma68kToVDP	Palette_UCurr,0,$80,CRAM

loc_C22:				; XREF: loc_BC8
		move.w	($FFFFF624).w,(a5)
		bra.w	loc_B5E
; ===========================================================================

loc_C32:				; XREF: off_B6E
		bsr.w	sub_106E

loc_C36:				; XREF: off_B6E
		tst.w	($FFFFF614).w
		beq.w	locret_C42
		subq.w	#1,($FFFFF614).w

locret_C42:
		rts
; ===========================================================================

loc_C44:				; XREF: off_B6E
		bsr.w	sub_106E
		jsr	sub_6886
		bsr.w	sub_1642
		tst.w	($FFFFF614).w
		beq.w	locret_C5C
		subq.w	#1,($FFFFF614).w

locret_C5C:
		rts
; ===========================================================================

loc_C5E:				; XREF: off_B6E
		bsr.w	sub_106E
		rts
; ===========================================================================
VBetterGame:
		bra.w	ReadJoypads

GHZ2BossInt:
		dma68kToVDP	VScroll_RAM,0,$50,VSRAM
		bra.s	loc_C6E

titleint:
		bsr.w	TitleAnim_FlipBuffer

loc_C64:				; XREF: off_B6E
		cmpi.b	#$10,($FFFFF600).w ; is	game mode = $10	(special stage)	?
		beq.w	loc_DA6		; if yes, branch

loc_C6E:				; XREF: off_B6E
		bsr.w	ReadJoypads
		tst.b	($FFFFF64E).w
		bne.s	loc_CB0
		dma68kToVDP	Palette_NCurr,0,$80,CRAM
		bra.s	loc_CD4
; ===========================================================================

loc_CB0:
		dma68kToVDP	Palette_UCurr,0,$80,CRAM

loc_CD4:				; XREF: loc_C76
		move.w	($FFFFF624).w,(a5)
		lea	VDP_Control_Port,a5
		move.l	#$940193C0,(a5)
		move.l	#$96E69500,(a5)
		move.w	#$977F,(a5)
		move.w	#$7C00,(a5)
		move.w	#$83,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		lea	VDP_Control_Port,a5
		move.l	#$94019340,(a5)
		move.l	#$96FC9500,(a5)
		move.w	#$977F,(a5)
		move.w	#$7800,(a5)
		move.w	#$83,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		jsr	(ProcessDMAQueue).l

loc_D50:
		movem.l	($FFFFF700).w,d0-d7
		movem.l	d0-d7,($FFFFFF10).w
		movem.l	($FFFFF754).w,d0-d1
		movem.l	d0-d1,($FFFFFF30).w

; ---------------------------------------------------------------------------
; Subroutine to	run a demo for an amount of time
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Demo_Time:				; XREF: loc_D50; PalToCRAM
		jsr	LoadTilesAsYouMove
		jsr	AniArt_Load
		jsr	HudUpdate
		bsr.w	sub_165E
		tst.w	($FFFFF614).w	; is there time	left on	the demo?
		beq.s	Demo_TimeEnd	; if not, branch
		bmi.s	Demo_TimeEnd	; if negative, branch
		subq.w	#1,($FFFFF614).w ; subtract 1 from time	left

Demo_TimeEnd:
		rts
; End of function Demo_Time

; ===========================================================================

loc_DA6:				; XREF: off_B6E
		bsr.w	ReadJoypads
		lea	VDP_Control_Port,a5
		move.l	#$94009340,(a5)
		move.l	#$96FD9580,(a5)
		move.w	#$977F,(a5)
		move.w	#$C000,(a5)
		move.w	#$80,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		lea	VDP_Control_Port,a5
		move.l	#$94019340,(a5)
		move.l	#$96FC9500,(a5)
		move.w	#$977F,(a5)
		move.w	#$7800,(a5)
		move.w	#$83,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		lea	VDP_Control_Port,a5
		move.l	#$940193C0,(a5)
		move.l	#$96E69500,(a5)
		move.w	#$977F,(a5)
		move.w	#$7C00,(a5)
		move.w	#$83,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		jsr	(ProcessDMAQueue).l

loc_E64:
		tst.w	($FFFFF614).w
		beq.w	locret_E70
		subq.w	#1,($FFFFF614).w

locret_E70:
		rts
; ===========================================================================

loc_E72:				; XREF: off_B6E
		bsr.w	ReadJoypads
		tst.b	($FFFFF64E).w
		bne.s	loc_EB4
		dma68kToVDP	Palette_NCurr,0,$80,CRAM
		bra.s	loc_ED8
; ===========================================================================

loc_EB4:
		dma68kToVDP	Palette_UCurr,0,$80,CRAM

loc_ED8:				; XREF: loc_E7A
		move.w	($FFFFF624).w,(a5)
		lea	VDP_Control_Port,a5
		move.l	#$940193C0,(a5)
		move.l	#$96E69500,(a5)

loc_White:
		move.w	#$977F,(a5)
		move.w	#$7C00,(a5)
		move.w	#$83,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		lea	VDP_Control_Port,a5
		move.l	#$94019340,(a5)
		move.l	#$96FC9500,(a5)
		move.w	#$977F,(a5)
		move.w	#$7800,(a5)
		move.w	#$83,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		jsr	(ProcessDMAQueue).l

loc_F54:
		movem.l	($FFFFF700).w,d0-d7
		movem.l	d0-d7,($FFFFFF10).w
		movem.l	($FFFFF754).w,d0-d1
		movem.l	d0-d1,($FFFFFF30).w
		bsr.w	LoadTilesAsYouMove
		jsr	AniArt_Load
		jsr	HudUpdate
		bsr.w	sub_1642
		rts
; ===========================================================================

loc_F8A:				; XREF: off_B6E
		bsr.w	sub_106E
		addq.b	#1,($FFFFF628).w
		move.b	#$E,(VBlank_Routine).w
		rts
; ===========================================================================

loc_F9A:				; XREF: off_B6E
		bsr.w	sub_106E
		move.w	($FFFFF624).w,(a5)
		bra.w	sub_1642
; ===========================================================================

loc_FA6:				; XREF: off_B6E
		bsr.w	ReadJoypads
		dma68kToVDP	Palette_NCurr,0,$80,CRAM
		dma68kToVDP	$FFFFF800,$F800,$280,VRAM
		dma68kToVDP	$FFFFCC00,$FC00,$380,VRAM
		jsr	ProcessDMAQueue

loc_1060:
		tst.w	($FFFFF614).w
		beq.w	locret_106C
		subq.w	#1,($FFFFF614).w

locret_106C:
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_106E:				; XREF: loc_C32; et al
		bsr.w	ReadJoypads
		tst.b	($FFFFF64E).w
		bne.s	loc_10B0
		dma68kToVDP	Palette_NCurr,0,$80,CRAM
		bra.s	loc_10D4
; ===========================================================================

loc_10B0:
		dma68kToVDP	Palette_UCurr,0,$80,CRAM

loc_10D4:				; XREF: sub_106E
		lea	VDP_Control_Port,a5
		move.l	#$94019340,(a5)
		move.l	#$96FC9500,(a5)
		move.w	#$977F,(a5)
		move.w	#$7800,(a5)
		move.w	#$83,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		lea	VDP_Control_Port,a5
		move.l	#$940193C0,(a5)
		move.l	#$96E69500,(a5)
		move.w	#$977F,(a5)
		move.w	#$7C00,(a5)
		move.w	#$83,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		rts
; End of function sub_106E

; ---------------------------------------------------------------------------
; Subroutine to	move pallets from the RAM to CRAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalToCRAM:
		move	#$2700,sr
		tst.b	$FFFFF64F.w
		bpl	locret_119C
		sf	$FFFFF64F.w
		movem.l	a0-a1,-(sp)
		lea	VDP_Data_Port,a1
		lea	Palette_UCurr.w,a0 ; load	pallet from RAM
		move.l	#$C0000000,4(a1) ; set VDP to CRAM write

		rept	32		; move pallet to CRAM
		move.l	(a0)+,(a1)
		endr
		move.w	#$8ADF,4(a1)
		movem.l	(sp)+,a0-a1

locret_119C:
		rte
; End of function PalToCRAM

; ---------------------------------------------------------------------------
; Subroutine to	initialise joypads
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


JoypadInit:				; XREF: GameClrRAM
		move.w	#$100,($A11100).l ; stop the Z80

Joypad_WaitZ80:
		btst	#0,($A11100).l	; has the Z80 stopped?
		bne.s	Joypad_WaitZ80	; if not, branch
		moveq	#$40,d0
		move.b	d0,($A10009).l	; init port 1 (joypad 1)
		move.b	d0,($A1000B).l	; init port 2 (joypad 2)
		move.b	d0,($A1000D).l	; init port 3 (extra)
		move.w	#0,($A11100).l	; start	the Z80
		rts
; End of function JoypadInit

; ---------------------------------------------------------------------------
; Subroutine to	read joypad input, and send it to the RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ReadJoypads:
		lea	($FFFFF604).w,a0 ; address where joypad	states are written
		lea	($A10003).l,a1	; first	joypad port
		bsr.s	Joypad_Read	; do the first joypad
		addq.w	#2,a1		; do the second	joypad
		bsr.s	Joypad_read
		move.l	$FFFFF604,d0
		swap	d0
		add.l	d0,$FFFFF636.w
		rts

Joypad_Read:
		move.b	#0,(a1)
		nop
		nop
		move.b	(a1),d0
		lsl.b	#2,d0
		andi.b	#$C0,d0
		move.b	#$40,(a1)
		nop
		nop
		move.b	(a1),d1
		andi.b	#$3F,d1
		or.b	d1,d0
		not.b	d0
		move.b	(a0),d1
		eor.b	d0,d1
		move.b	d0,(a0)+
		and.b	d0,d1
		move.b	d1,(a0)+
		rts
; End of function ReadJoypads


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


VDPSetupGame:				; XREF: GameClrRAM; ChecksumError
		lea	VDP_Control_Port,a0
		lea	VDP_Data_Port,a1
		lea	(VDPSetupArray).l,a2
		moveq	#$12,d7

VDP_Loop:
		move.w	(a2)+,(a0)
		dbf	d7,VDP_Loop	; set the VDP registers

		move.w	(VDPSetupArray+2).l,d0
		move.w	d0,($FFFFF60C).w
		move.w	#$8ADF,($FFFFF624).w
		moveq	#0,d0
		move.l	#$C0000000,VDP_Control_Port ; set VDP to CRAM write
		move.w	#$3F,d7

VDP_ClrCRAM:
		move.w	d0,(a1)
		dbf	d7,VDP_ClrCRAM	; clear	the CRAM

		clr.l	($FFFFF616).w
		clr.l	($FFFFF61A).w
		move.l	d1,-(sp)
		lea	VDP_Control_Port,a5
		move.w	#$8F01,(a5)
		move.l	#$94FF93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$40000080,(a5)
		move.w	#0,VDP_Data_Port	; clear	the screen

loc_128E:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_128E

		move.w	#$8F02,(a5)
		move.l	(sp)+,d1
		rts
; End of function VDPSetupGame

; ===========================================================================
VDPSetupArray:	dc.w $8004, $8134, $8230, $8328	; XREF: VDPSetupGame
		dc.w $8407, $857C, $8600, $8700
		dc.w $8800, $8900, $8A00, $8B00
		dc.w $8C81, $8D3F, $8E00, $8F02
		dc.w $9001, $9100, $9200

; ---------------------------------------------------------------------------
; Subroutine to	clear the screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ClearScreen:
		fillVRAM	0,$FFF,$C000 ; clear foreground namespace

.waitFillDone	move.w	(a5),d1
		btst	#1,d1
		bne.s	.waitFillDone

		move.w	#$8F02,(a5)
		fillVRAM	0,$FFF,$E000 ; clear background namespace

.waitFillDone2	move.w	(a5),d1
		btst	#1,d1
		bne.s	.waitFillDone2

		move.w	#$8F02,(a5)
		move.l	#0,($FFFFF616).w
		move.l	#0,($FFFFF61A).w
		lea	($FFFFF800).w,a1
		moveq	#0,d0
		move.w	#$A0-1,d1

.clr		move.l	d0,(a1)+
		dbf	d1,.clr

		lea	($FFFFCC00).w,a1
		moveq	#0,d0
		move.w	#$100-1,d1

.clr2		move.l	d0,(a1)+
		dbf	d1,.clr2
		rts
; End of function ClearScreen

; ---------------------------------------------------------------------------
; Subroutine to	load the sound driver
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

SoundDriverLoad:			; XREF: GameClrRAM; TitleScreen
		move.w	#$100,d0
		move.w	d0,($A11100).l
		move.w	d0,($A11200).l
		lea	MegaPCM,a0
		lea	$A00000,a1
		move.w	#(MegaPCM_End-MegaPCM)-1,d1

.Load		move.b	(a0)+,(a1)+
		dbf	d1,.Load
		moveq	#0,d1
		move.w	d1,($A11200).l
		nop
		nop
		nop
		nop
 		move.w	d0,($A11200).l
		move.w	d1,($A11100).l
		rts
; End of function SoundDriverLoad

; ---------------------------------------------------------------------------
; Subroutine to play a DAC sample
; ---------------------------------------------------------------------------
Playsample2:
		btst	#3,Music_EnabledChans.w
		beq.s	PlaySample_common
		rts

PlaySample:
		btst	#3,Music_EnabledChans.w
		bne.s	PlaySample_end

		buytest	Used_AirHorn
		beq.s	PlaySample_common
		add.b	#DAC_NormSample,d0

PlaySample_common:
		move.b	d0,Music_StoreDAC.w
	stopZ80
		move.b	d0,($A01FFF).l
	startZ80
PlaySample_end:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	play a sound or	music track
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

PlayMusic:
		move.b	d0,Music_StorePrevID.w
Playmusic_speed:
		move.b	d0,$FFFFF00A.w
		rts

PlayBossMusic:
		st	BossMode.w
		moveq	#$FFFFFF8C,d0
		buytest	Used_AltMusic
		beq.s	PlayMusicFade
		moveq	#Music_Boss,d0

PlayMusicFade:
		move.b	d0,$FFFFF60E.w
		move.b	d0,Music_StorePrevID.w
		move.b	#$E0,$FFFFF00A.w

.rts		rts
; End of function PlayMusic

PlayMusicFromFade:
		tst.b	$FFFFF60E.w	; music to be played flag
		beq.s	.rts		; if 0, branch
		tst.b	v_snddriver_ram+v_fadeout_counter; check if fadeout is complete
		bne.s	.rts		; if not 0, branch

		move.b	$FFFFF60E.w,$FFFFF00A.w
		sf	$FFFFF60E.w
.rts		rts

; ---------------------------------------------------------------------------
; Subroutine to	play a special sound/music (E0-E4)
;
; E0 - Fade out
; E1 - Sega
; E2 - Speed up
; E3 - Normal speed
; E4 - Stop
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

PlaySound:
		move.b	d0,$FFFFF00B.w
		rts
; End of function PlaySound

; ===========================================================================
; ---------------------------------------------------------------------------
; Unused sound/music subroutine
; ---------------------------------------------------------------------------

PlaySound2:
		move.b	d0,$FFFFF00C.w
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; used to queue played music/sound effects (will select highest priority
; ---------------------------------------------------------------------------
Playsound_Queue:
		move.l	a0,-(sp)
		lea	$FFFFF00A.w,a0
		moveq	#2,d7

.priorityloop	tst.b	(a0)+
		bne	.SlotFound

		move.b	DefaultVBIRoutine.w,VBlank_Routine.w
		bsr.w	DelayProgram
		lea	$FFFFF00A+1.w,a0

.SlotFound	move.b	d0,-1(a0)
		move.l	(sp)+,a0
rts_123:	rts

; ===========================================================================
; ---------------------------------------------------------------------------
; sekrit code to fuck with palettes
; ---------------------------------------------------------------------------
PaletteModification:
		buytest	Used_Boobs
		beq.s	rts_123			; if you havent activated this, skip

		lea	Palette_Mods.w,a6	; get the proper address for this
		moveq	#Palette_ModsSize-1,d7	; 4 repeats
		move.w	d7,a4			; set a bullshit address to a4

.loop		move.w	#Palette_NCurr+$FE,d6	; normal palette
.loop2		tst.w	(a6)			; test for empty slot
		bne.s	.notempty		; skip this slot if its empty

		jsr	RandomNumber		; generate a random number
		move.w	d0,(a6)			; copy random number
		lea	2(a6),a6		; skip the blank entry
		dbf	d7,.loop2		; loop
		bra.w	.new			; new color

.notempty	move.b	(a6)+,d5	; get the offset of the data
		and.b	d5,d6		; get the proper address
		move.w	d6,a5		; set to address register

		move.b	(a6)+,d6	; get description fields
		move.b	d6,d5		; copy description fields

		; blue
		and.b	#%11000000,d6	; leave 2 last bits remaining
		beq.s	.green		; if 0, skip blue
		move.w	#$E00,d6	; test for max value
		move.w	#-$200,d4	; set d4 to blue

		btst	#0,-2(a6)	; is bit negative bit set?
		bne.s	.bsub		; if not dont negate
		neg.w	d4		; negate
		sf	d6		; test for min value

.bsub		sub.b	#%01000000,-1(a6); sub from length
		move.w	(a5),d3		; get current value
		andi.w	#$E00,d3	; get blue
		cmp.w	d3,d6		; check if tested value
		beq.s	.green		; if so skip fade
		sub.w	d4,(a5)		; sub from the color


		; green
.green		move.b	d5,d6		; copy description fields
		and.b	#%00011000,d6	; filter out green
		beq.s	.red		; if 0, skip green
		moveq	#-$20,d4	; set d4 to green
		moveq	#$FFFFFFE0,d6	; test for max value

		btst	#5,-1(a6)	; is bit negative bit set?
		bne.s	.gsub		; if not dont negate
		moveq	#$20,d4		; set d4 to negative green
		sf	d6		; test for min value

.gsub		sub.b	#%00001000,-1(a6); sub from length
		move.w	(a5),d3		; get current value
		andi.b	#$E0,d3		; get green
		cmp.b	d3,d6		; check if tested value
		beq.s	.red		; if so skip fade
		sub.b	d4,1(a5)	; sub from the color

		; red
.red		and.b	#%00000011,d5	; filter out red
		beq.s	.next		; if 0, skip red
		moveq	#2,d4		; set d4 to red
		moveq	#$E,d6		; test for max value

		btst	#2,-1(a6)	; is bit negative bit set?
		bne.s	.rsub		; if not dont negate
		addq.b	#4,d4		; set d4 to negative red
		sf	d6		; test for min value

.rsub		sub.b	#%00000001,-1(a6); sub from length
		move.w	(a5),d3		; get current value
		andi.b	#$E,d3		; get red
		cmp.b	d3,d6		; check if tested value
		beq.s	.next		; if so skip fade
		sub.b	d4,1(a5)	; sub from the color

.next		move.b	-1(a6),d6	; get the fade amount
		andi.b	#%11011011,d6	; get only fade bits
		tst.b	d6		; is null?
		bne.s	.dbf		; if not skip
		move.w	#0,-2(a6)	; clear bytes
.dbf		dbf	d7,.loop	; loop

.new		rts
		move.b	$FFFFFE0C+3.w,d0; get the VBlank counter
		andi.b	#$1F,d0		; has 8 frames passed?
		bne	.rts		; if not, branch
		jsr	RandomNumber	; next random number
		lsr.w	#8,d0		; shift right 8 bits
		and.w	#3,d0		; max of 8 objects
		move.w	d0,d7		; copy to loop counter

.loop3		jsr	SingleObjLoad		; load new object
		bne	.rts			; if all slots are full, end
		jsr	RandomNumber		; next random number
		andi.w	#$1F3F,d0		; and the result properly

		move.l	#$370427B2,(a1)		; load bouncing	ring object
		move.l	#Map_obj25,Mappings_Offset(a1)
		addq.b	#2,Routine(a1)
		move.l	#$8080300,Y_Radius(a1)
		move.b	#$47,Coll(a1)
		addq.b	#8,X_Visible(a1)	; CRUD THIS IS $1F SO CANT DO WORD :I
		st	$FFFFFEC6.w		; <- #-1

		move.w	$FFFFF704.w,Y_Pos(a1)	; get Y-pos
		add.w	#$10,Y_Pos(a1)		; move upwards
		move.b	d0,d1			; copy d0 to d1
		ext.w	d1			; extend
		add.w	d1,Y_Pos(a1)		; finally add to the Y-position
		lsr.l	#8,d0			; next byte

		move.w	$FFFFF700.w,X_Pos(a1)	; get Y-pos
		addi.w	#320,X_Pos(a1)		; set to end of the screen
		move.b	d0,d1			; copy d0 to d1
		ext.w	d1			; extend
		add.w	d1,X_Pos(a1)		; finally add to the Y-position
		lsr.l	#8,d0			; next byte

		move.w	#-$400,X_Vel(a1)	;
		sub.b	d0,X_Vel+1(a1)		;
		lsr.w	#8,d0			; next byte

		move.w	#0,Y_Vel(a1)		;
		sub.b	d0,Y_Vel+1(a1)		;
		dbf	d7,.loop3
.rts		rts

; ---------------------------------------------------------------------------
; Subroutine to	pause the game
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PauseGame:				; XREF: Level_MainLoop; et al
		cmpi.b	#6,Object_RAM+Routine; Are you dead?
		bhs	Unpause	         ; if you are, dont cheat!
		tst.b	($FFFFFE12).w	; do you have any lives	left?
		beq	Unpause		; if not, branch
		tst.w	($FFFFF63A).w	; is game already paused?
		bne	loc_13BE	; if yes, branch
		btst	#7,($FFFFF605).w ; is Start button pressed?
		beq	Pause_DoNothing	; if not, branch

loc_13BE:
		move.w	#1,($FFFFF63A).w ; freeze time
		move.b	#1,($FFFFF003).w ; pause music

loc_13CA:
		move.b	#$10,(VBlank_Routine).w
		bsr.w	DelayProgram
		buytest	Bought_LevSel
		beq.s	Pause_ChkStart
		btst	#6,($FFFFF605).w ; is button A pressed?
		beq	Pause_ChkStart	; if not, branch
		move.b	#4,$FFFFF600.w
		bra	loc_1404
; ===========================================================================

Pause_ChkBC:				; XREF: PauseGame

Pause_ChkStart:				; XREF: PauseGame
		btst	#7,($FFFFF605).w ; is Start button pressed?
		beq	loc_13CA	; if not, branch

loc_1404:				; XREF: PauseGame
		move.b	#$80,($FFFFF003).w

Unpause:				; XREF: PauseGame
		move.w	#0,($FFFFF63A).w ; unpause the game

Pause_DoNothing:			; XREF: PauseGame
		rts

; End of function PauseGame


; Subroutine for queueing VDP commands (seems to only queue transfers to VRAM),
; to be issued the next time ProcessDMAQueue is called.
; Can be called a maximum of 18 times before the buffer needs to be cleared
; by issuing the commands (this subroutine DOES check for overflow)
; ---------------------------------------------------------------------------
; In case you wish to use this queue system outside of the spin dash, this is the
; registers in which it expects data in:
; d1.l: Address to data (In 68k address space) (REMEMBER TO KEEP HIGH BYTE CLEAR)
; d2.w: Destination in VRAM
; d3.w: Length of data in words
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; sub_144E: DMA_68KtoVRAM: QueueCopyToVRAM: QueueVDPCommand: Add_To_DMA_Queue:
QueueDMATransfer:
		movea.l	DMA_Buffer_End.w,a1
		cmpa.w	#DMA_Buffer_End-$FFFF0000,a1
		beq.s	QueueDMATransfer_Done ; return if there's no more room in the buffer

		; piece together some VDP commands and store them for later...
		move.w	#$9300,d0 ; command to specify DMA transfer length & $00FF
		move.b	d3,d0
		move.w	d0,(a1)+ ; store command

		move.w	#$9400,d0 ; command to specify DMA transfer length & $FF00
		lsr.w	#8,d3
		move.b	d3,d0
		move.w	d0,(a1)+ ; store command

		move.w	#$9500,d0 ; command to specify source address & $0001FE
		lsr.l	#1,d1
		move.b	d1,d0
		move.w	d0,(a1)+ ; store command

		move.w	#$9600,d0 ; command to specify source address & $01FE00
		lsr.l	#8,d1
		move.b	d1,d0
		move.w	d0,(a1)+ ; store command

		move.w	#$9700,d0 ; command to specify source address & $01FE0000
		lsr.l	#8,d1
		move.b	d1,d0
		move.w	d0,(a1)+ ; store command

		andi.l	#$FFFF,d2 ; command to specify destination address and begin DMA
		lsl.l	#2,d2
		lsr.w	#2,d2
		swap	d2
		or.l	DMAQueueMode.w,d2 ; set bits to specify VRAM transfer
		move.l	d2,(a1)+ ; store command

		move.l	a1,DMA_Buffer_End.w ; set the next free slot address
		cmpa.w	#DMA_Buffer_End-$FFFF0000,a1
		beq.s	QueueDMATransfer_Done ; return if there's no more room in the buffer
		move.w	#0,(a1) ; put a stop token at the end of the used part of the buffer
; return_14AA:
QueueDMATransfer_Done:
		rts
; End of function QueueDMATransfer


; ---------------------------------------------------------------------------
; Subroutine for issuing all VDP commands that were queued
; (by earlier calls to QueueDMATransfer)
; Resets the queue when it's done
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; sub_14AC: CopyToVRAM: IssueVDPCommands: Process_DMA: Process_DMA_Queue:
ProcessDMAQueue:
		lea	VDP_Control_Port,a5
		lea	DMA_Buffer_Start.w,a1
; loc_14B6:
ProcessDMAQueue_Loop:
		move.w	(a1)+,d0
		beq.s	ProcessDMAQueue_Done ; branch if we reached a stop token
		; issue a set of VDP commands...
		move.w	d0,(a5)		; transfer length
		move.w	(a1)+,(a5)	; transfer length
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; destination
		move.w	(a1)+,(a5)	; destination
		cmpa.w	#DMA_Buffer_End-$FFFF0000,a1
		bne.s	ProcessDMAQueue_Loop ; loop if we haven't reached the end of the buffer
; loc_14CE:
ProcessDMAQueue_Done:
		move.w	#0,DMA_Buffer_Start.w
		move.l	#DMA_Buffer_Start,DMA_Buffer_End.w
		rts
; End of function ProcessDMAQueue
; ---------------------------------------------------------------------------
; Subroutine to load DPLC's
; Input: a2 - DPLC file, d4 - VRAM address, d6 - Art file
; ---------------------------------------------------------------------------
Load_DPLC:
                moveq	#0,d0
		move.b	Anim_Frame(a0),d0; load frame number
		cmp.b	Off2C(a0),d0	; check if equal with $3A (can be changed to other)
		beq	DPLC_End	; if is, don't load new DPLC
		move.b	d0,Off2C(a0)	; put frame number to $3A
Load_DPLC2:
		add.w	d0,d0		; get frame index id
		adda.w	(a2,d0.w),a2	; get frame data
		moveq	#0,d5		; clear d5
		move.b	(a2)+,d5	; get amount of pieces
		subq.w	#1,d5		; sub 1
		bmi.s	DPLC_End	; if negative, branch away
DPLC_ReadEntry:
		moveq	#0,d1		; clear d1
		move.b	(a2)+,d1	; move first byte of the data to d1
		lsl.w	#8,d1		; low byte to high byte
		move.b	(a2)+,d1 	; move second byte to d1
		move.w	d1,d3		; move d1 to d3
		lsr.w	#8,d3		; divide by 256(?)
		andi.w	#$F0,d3		; only allow high nibble
		addi.w	#$10,d3		; 1 more tile?
		andi.w	#$FFF,d1
		lsl.l	#5,d1		; tiles to bytes
		add.l	d6,d1		; add the art address to d1
		move.w	d4,d2		; get VRAM location
		add.w	d3,d4		; add half bytes amount (/2) to VRAM address
		add.w	d3,d4		; add half bytes amount (/2) to VRAM address again
		jsr	QueueDMATransfer; Save it to the DMA queue
		dbf	d5,DPLC_ReadEntry; repeat for number of requests

DPLC_End:
		rts
; ---------------------------------------------------------------------------
; Subroutine to	display	patterns via the VDP
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ShowVDPGraphics:			; XREF: SegaScreen; TitleScreen; SS_BGLoad
		lea	VDP_Data_Port,a6
		move.l	#$800000,d4

loc_142C:
		move.l	d0,4(a6)
		move.w	d1,d3

loc_1432:
		move.w	(a1)+,(a6)
		dbf	d3,loc_1432
		add.l	d4,d0
		dbf	d2,loc_142C
SVDPG_rts:
		rts


ShowVDPGraphics2:			; XREF: SegaScreen; TitleScreen; SS_BGLoad
		lea	VDP_Data_Port,a6
		move.l	#$400000,d4
		bra.s	loc_142C
; End of function ShowVDPGraphics

; ==============================================================================
; ------------------------------------------------------------------------------
; Nemesis decompression routine
; ------------------------------------------------------------------------------
; Optimized by vladikcomper
; ------------------------------------------------------------------------------

NemDec_RAM:
        movem.l d0-a1/a3-a6,-(sp)
        lea     NemDec_WriteRowToRAM(pc),a3
        bra.s   NemDec_Main

; ------------------------------------------------------------------------------
NemDec:
        movem.l d0-a1/a3-a6,-(sp)
        lea     $C00000,a4              ; load VDP Data Port
        lea     NemDec_WriteRowToVDP(pc),a3

NemDec_Main:
        lea     $FFFFAA00,a1            ; load Nemesis decompression buffer
        move.w  (a0)+,d2                ; get number of patterns
        bpl.s   .0                      ; are we in Mode 0?
        lea     $A(a3),a3               ; if not, use Mode 1
.0      lsl.w   #3,d2
        movea.w d2,a5
        moveq   #7,d3
        moveq   #0,d2
        moveq   #0,d4
        bsr.w   NemDec4
        move.b  (a0)+,d5                ; get first byte of compressed data
        asl.w   #8,d5                   ; shift up by a byte
        move.b  (a0)+,d5                ; get second byte of compressed data
        move.w  #$10,d6                 ; set initial shift value
        bsr.s   NemDec2
        movem.l (sp)+,d0-a1/a3-a6
        rts

; ---------------------------------------------------------------------------
; Part of the Nemesis decompressor, processes the actual compressed data
; ---------------------------------------------------------------------------

NemDec2:
        move.w  d6,d7
        subq.w  #8,d7                   ; get shift value
        move.w  d5,d1
        lsr.w   d7,d1                   ; shift so that high bit of the code is in bit position 7
        cmpi.b  #%11111100,d1           ; are the high 6 bits set?
        bhs.s   NemDec_InlineData       ; if they are, it signifies inline data
        andi.w  #$FF,d1
        add.w   d1,d1
        sub.b   (a1,d1.w),d6            ; ~~ subtract from shift value so that the next code is read next time around
        cmpi.w  #9,d6                   ; does a new byte need to be read?
        bhs.s   .0                      ; if not, branch
        addq.w  #8,d6
        asl.w   #8,d5
        move.b  (a0)+,d5                ; read next byte
.0      move.b  1(a1,d1.w),d1
        move.w  d1,d0
        andi.w  #$F,d1                  ; get palette index for pixel
        andi.w  #$F0,d0

NemDec_GetRepeatCount:
        lsr.w   #4,d0                   ; get repeat count

NemDec_WritePixel:
        lsl.l   #4,d4                   ; shift up by a nybble
        or.b    d1,d4                   ; write pixel
        dbf     d3,NemDec_WritePixelLoop; ~~
        jmp     (a3)                    ; otherwise, write the row to its destination
; ---------------------------------------------------------------------------

NemDec3:
        moveq   #0,d4                   ; reset row
        moveq   #7,d3                   ; reset nybble counter

NemDec_WritePixelLoop:
        dbf     d0,NemDec_WritePixel
        bra.s   NemDec2
; ---------------------------------------------------------------------------

NemDec_InlineData:
        subq.w  #6,d6                   ; 6 bits needed to signal inline data
        cmpi.w  #9,d6
        bhs.s   .0
        addq.w  #8,d6
        asl.w   #8,d5
        move.b  (a0)+,d5
.0      subq.w  #7,d6                   ; and 7 bits needed for the inline data itself
        move.w  d5,d1
        lsr.w   d6,d1                   ; shift so that low bit of the code is in bit position 0
        move.w  d1,d0
        andi.w  #$F,d1                  ; get palette index for pixel
        andi.w  #$70,d0                 ; high nybble is repeat count for pixel
        cmpi.w  #9,d6
        bhs.s   NemDec_GetRepeatCount
        addq.w  #8,d6
        asl.w   #8,d5
        move.b  (a0)+,d5
        bra.s   NemDec_GetRepeatCount

; ---------------------------------------------------------------------------
; Subroutines to output decompressed entry
; Selected depending on current decompression mode
; ---------------------------------------------------------------------------

NemDec_WriteRowToVDP:
loc_1502:
        move.l  d4,(a4)                 ; write 8-pixel row
        subq.w  #1,a5
        move.w  a5,d4                   ; have all the 8-pixel rows been written?
        bne.s   NemDec3                 ; if not, branch
        rts
; ---------------------------------------------------------------------------

NemDec_WriteRowToVDP_XOR:
        eor.l   d4,d2                   ; XOR the previous row by the current row
        move.l  d2,(a4)                 ; and write the result
        subq.w  #1,a5
        move.w  a5,d4
        bne.s   NemDec3
        rts
; ---------------------------------------------------------------------------

NemDec_WriteRowToRAM:
        move.l  d4,(a4)+                ; write 8-pixel row
        subq.w  #1,a5
        move.w  a5,d4                   ; have all the 8-pixel rows been written?
        bne.s   NemDec3                 ; if not, branch
        rts
; ---------------------------------------------------------------------------

NemDec_WriteRowToRAM_XOR:
        eor.l   d4,d2                   ; XOR the previous row by the current row
        move.l  d2,(a4)+                ; and write the result
        subq.w  #1,a5
        move.w  a5,d4
        bne.s   NemDec3
        rts

; ---------------------------------------------------------------------------
; Part of the Nemesis decompressor, builds the code table (in RAM)
; ---------------------------------------------------------------------------

NemDec4:
        move.b  (a0)+,d0                ; read first byte

.ChkEnd:
        cmpi.b  #$FF,d0                 ; has the end of the code table description been reached?
        bne.s   .NewPalIndex            ; if not, branch
        rts
; ---------------------------------------------------------------------------

.NewPalIndex:
        move.w  d0,d7

.ItemLoop:
        move.b  (a0)+,d0                ; read next byte
        bmi.s   .ChkEnd                 ; ~~
        move.b  d0,d1
        andi.w  #$F,d7                  ; get palette index
        andi.w  #$70,d1                 ; get repeat count for palette index
        or.w    d1,d7                   ; combine the two
        andi.w  #$F,d0                  ; get the length of the code in bits
        move.b  d0,d1
        lsl.w   #8,d1
        or.w    d1,d7                   ; combine with palette index and repeat count to form code table entry
        moveq   #8,d1
        sub.w   d0,d1                   ; is the code 8 bits long?
        bne.s   .ItemShortCode          ; if not, a bit of extra processing is needed
        move.b  (a0)+,d0                ; get code
        add.w   d0,d0                   ; each code gets a word-sized entry in the table
        move.w  d7,(a1,d0.w)            ; store the entry for the code
        bra.s   .ItemLoop               ; repeat
; ---------------------------------------------------------------------------

.ItemShortCode:
        move.b  (a0)+,d0                ; get code
        lsl.w   d1,d0                   ; shift so that high bit is in bit position 7
        add.w   d0,d0                   ; get index into code table
        moveq   #1,d5
        lsl.w   d1,d5
        subq.w  #1,d5                   ; d5 = 2^d1 - 1
        lea     (a1,d0.w),a6            ; ~~

.ItemShortCodeLoop:
        move.w  d7,(a6)+                ; ~~ store entry
        dbf     d5,.ItemShortCodeLoop   ; repeat for required number of entries
        bra.s   .ItemLoop

; ---------------------------------------------------------------------------
; Subroutine to	load pattern load cues
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadPLC:
		movem.l	a1-a2,-(sp)
		lea	(ArtLoadCues).l,a1
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
LoadPLC_Custom:
		lea	$FFFFF680-6,a2

loc_1598:
		addq.w	#6,a2
		tst.l	(a2)
		bne.s	loc_1598

loc_15A0:				; XREF: LoadPLC
		move.w	(a1)+,d0
		bmi.s	loc_15AC

loc_15A4:
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+
		dbf	d0,loc_15A4

loc_15AC:
		movem.l	(sp)+,a1-a2
		rts
; End of function LoadPLC


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadPLC2:
		movem.l	a1-a2,-(sp)
		lea	(ArtLoadCues).l,a1
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		bsr.s	ClearPLC
		lea	($FFFFF680).w,a2
		move.w	(a1)+,d0
		bmi.s	loc_15D8

loc_15D0:
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+
		dbf	d0,loc_15D0

loc_15D8:
		movem.l	(sp)+,a1-a2
		rts
; End of function LoadPLC2

; ---------------------------------------------------------------------------
; Subroutine to	clear the pattern load cues
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ClearPLC:				; XREF: LoadPLC2
		lea	($FFFFF680).w,a2
		moveq	#$1F,d0

ClearPLC_Loop:
		clr.l	(a2)+
		dbf	d0,ClearPLC_Loop
		rts
; End of function ClearPLC

; ---------------------------------------------------------------------------
; Subroutine to	use graphics listed in a pattern load cue
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


RunPLC_RAM:				; XREF: Pal_FadeTo
		tst.l	($FFFFF680).w
		beq.s	locret_1640
		tst.w	($FFFFF6F8).w
		bne.s	locret_1640
		movea.l	($FFFFF680).w,a0
		lea	loc_1502,a3
		lea	($FFFFAA00).w,a1
		move.w	(a0)+,d2
		bpl.s	loc_160E
		adda.w	#$A,a3

loc_160E:
		andi.w	#$7FFF,d2
		bsr.w	NemDec4
		move.b	(a0)+,d5
		asl.w	#8,d5
		move.b	(a0)+,d5
		moveq	#$10,d6
		moveq	#0,d0
		move.l	a0,($FFFFF680).w
		move.l	a3,($FFFFF6E0).w
		move.l	d0,($FFFFF6E4).w
		move.l	d0,($FFFFF6E8).w
		move.l	d0,($FFFFF6EC).w
		move.l	d5,($FFFFF6F0).w
		move.l	d6,($FFFFF6F4).w
		move.w	d2,($FFFFF6F8).w

locret_1640:
		rts
; End of function RunPLC_RAM


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1642:				; XREF: loc_C44; loc_F54; loc_F9A
		tst.w	($FFFFF6F8).w
		beq.w	locret_16DA
		move.w	#9,($FFFFF6FA).w	; tiles amount
		moveq	#0,d0
		move.w	($FFFFF684).w,d0	; old offs
		addi.w	#9*32,($FFFFF684).w	; incr to next
		bra.s	loc_1676
; End of function sub_1642


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_165E:				; XREF: Demo_Time
		tst.w	($FFFFF6F8).w
		beq.s	locret_16DA
		move.w	#3,($FFFFF6FA).w	; tiles amount
		moveq	#0,d0
		move.w	($FFFFF684).w,d0	; old offs
		addi.w	#3*32,($FFFFF684).w	; incr to next

loc_1676:				; XREF: sub_1642
		lea	VDP_Control_Port,a4	; control port
		lsl.l	#2,d0			; spill last 2 bits to upper word
		lsr.w	#2,d0			; return 14 bits back to low word
		ori.w	#$4000,d0		; or VRAM write mode
		swap	d0			; swap hi and lo
		move.l	d0,(a4)			; write to VDP
		subq.w	#4,a4			; data port
		movea.l	($FFFFF680).w,a0
		movea.l	($FFFFF6E0).w,a3
		move.l	($FFFFF6E4).w,d0
		move.l	($FFFFF6E8).w,d1
		move.l	($FFFFF6EC).w,d2
		move.l	($FFFFF6F0).w,d5
		move.l	($FFFFF6F4).w,d6
		lea	($FFFFAA00).w,a1

loc_16AA:				; XREF: sub_165E
		movea.w	#8,a5
		bsr.w	NemDec3
		subq.w	#1,($FFFFF6F8).w
		beq.s	loc_16DC
		subq.w	#1,($FFFFF6FA).w
		bne.s	loc_16AA
		move.l	a0,($FFFFF680).w
		move.l	a3,($FFFFF6E0).w
		move.l	d0,($FFFFF6E4).w
		move.l	d1,($FFFFF6E8).w
		move.l	d2,($FFFFF6EC).w
		move.l	d5,($FFFFF6F0).w
		move.l	d6,($FFFFF6F4).w

locret_16DA:				; XREF: sub_1642
		rts
; ===========================================================================

loc_16DC:                       ; XREF: sub_165E
                lea     ($FFFFF680).w,a0
                lea     6(a0),a1
                moveq   #$E,d0          ; do $F cues

loc_16E2:                               ; XREF: sub_165E
                move.l  (a1)+,(a0)+
                move.w  (a1)+,(a0)+
                dbf     d0,loc_16E2

                moveq   #0,d0
                move.l  d0,(a0)+        ; clear the last cue to avoid overcopying it
                move.w  d0,(a0)+        ;
                rts
; End of function sub_165E

; ---------------------------------------------------------------------------
; Subroutine to	execute	the pattern load cue
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


RunPLC_ROM:
		lea	(ArtLoadCues).l,a1 ; load the PLC index
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		move.w	(a1)+,d1	; load number of entries in the	PLC

RunPLC_Loop:
		movea.l	(a1)+,a0	; get art pointer
		moveq	#0,d0
		move.w	(a1)+,d0	; get VRAM address
		lsl.l	#2,d0		; divide address by $20
		lsr.w	#2,d0
		ori.w	#$4000,d0
		swap	d0
		move.l	d0,VDP_Control_Port	; put the VRAM address into VDP
		bsr.w	NemDec		; decompress
		dbf	d1,RunPLC_Loop	; loop for number of entries
		rts
; End of function RunPLC_ROM

; ---------------------------------------------------------------------------
; Enigma decompression subroutine
; Inputs:
; a0 = compressed data location
; a1 = destination (in RAM)
; d0 = starting art tile
; See http://www.segaretro.org/Enigma_compression for format description
; ---------------------------------------------------------------------------

; =============== S U B R O U T I N E =======================================


enidec:
		movem.l	d0-d7/a1-a5,-(sp)
		movea.w	d0,a3	; store starting art tile
		move.b	(a0)+,d0
		ext.w	d0
		movea.w	d0,a5	; store number of bits in inline copy value
		move.b	(a0)+,d4
		lsl.b	#3,d4	; store PCCVH flags bitfield
		movea.w	(a0)+,a2
		adda.w	a3,a2	; store incremental copy word
		movea.w	(a0)+,a4
		adda.w	a3,a4	; store literal copy word
		move.b	(a0)+,d5
		asl.w	#8,d5
		move.b	(a0)+,d5	; get first word in format list
		moveq	#$10,d6		; initial shift value

enidec_Loop:
		moveq	#7,d0	; assume a format list entry is 7 bits
		move.w	d6,d7
		sub.w	d0,d7
		move.w	d5,d1
		lsr.w	d7,d1
		andi.w	#$7F,d1	; get format list entry
		move.w	d1,d2	; and copy it
		cmpi.w	#$40,d1	; is the high bit of the entry set?
		bhs.s	.c
		moveq	#6,d0	; if it isn't, the entry is actually 6 bits
		lsr.w	#1,d2
.c
		bsr.w	enidec_FetchByte
		andi.w	#$F,d2	; get repeat count
		lsr.w	#4,d1
		add.w	d1,d1
		jmp	enidec_Index(pc,d1.w)
; ---------------------------------------------------------------------------

enidec_00:
		move.w	a2,(a1)+	; copy incremental copy word
		addq.w	#1,a2	; increment it
		dbf	d2,enidec_00	; repeat
		bra.s	enidec_Loop
; ---------------------------------------------------------------------------

enidec_01:
		move.w	a4,(a1)+	; copy literal copy word
		dbf	d2,enidec_01	; repeat
		bra.s	enidec_Loop
; ---------------------------------------------------------------------------

enidec_100:
		bsr.w	enidec_FetchInlineValue

.l4		move.w	d1,(a1)+	; copy inline value
		dbf	d2,.l4	; repeat
		bra.s	enidec_Loop
; ---------------------------------------------------------------------------

enidec_101:
		bsr.w	enidec_FetchInlineValue

.l3		move.w	d1,(a1)+	; copy inline value
		addq.w	#1,d1	; increment
		dbf	d2,.l3	; repeat
		bra.s	enidec_Loop
; ---------------------------------------------------------------------------

enidec_110:
		bsr.w	enidec_FetchInlineValue

.l2		move.w	d1,(a1)+	; copy inline value
		subq.w	#1,d1	; decrement
		dbf	d2,.l2	; repeat
		bra.s	enidec_Loop
; ---------------------------------------------------------------------------

enidec_111:
		cmpi.w	#$F,d2
		beq.s	enidec_Done

.l		bsr.w	enidec_FetchInlineValue	; fetch new inline value
		move.w	d1,(a1)+	; copy it
		dbf	d2,.l	; and repeat
		bra.s	enidec_Loop
; ---------------------------------------------------------------------------

enidec_Index:
		bra.s	enidec_00
; ---------------------------------------------------------------------------
		bra.s	enidec_00
; ---------------------------------------------------------------------------
		bra.s	enidec_01
; ---------------------------------------------------------------------------
		bra.s	enidec_01
; ---------------------------------------------------------------------------
		bra.s	enidec_100
; ---------------------------------------------------------------------------
		bra.s	enidec_101
; ---------------------------------------------------------------------------
		bra.s	enidec_110
; ---------------------------------------------------------------------------
		bra.s	enidec_111
; ---------------------------------------------------------------------------

enidec_Done:
		subq.w	#1,a0	; go back by one byte
		cmpi.w	#$10,d6
		bne.s	.c1
		subq.w	#1,a0	; and another one if needed
.c1
		move.w	a0,d0
		lsr.w	#1,d0
		bhs.s	.c
		addq.w	#1,a0	; make sure it's an even address
.c
		movem.l	(sp)+,d0-d7/a1-a5
		rts
; End of function enidec

; ---------------------------------------------------------------------------
; Part of the Enigma decompressor
; Fetches an inline copy value and stores it in d1
; ---------------------------------------------------------------------------

; =============== S U B R O U T I N E =======================================


enidec_FetchInlineValue:
		move.w	a3,d3	; copy starting art tile
		move.b	d4,d1	; copy PCCVH bitfield
		add.b	d1,d1	; is the priority bit set?
		bhs.s	.c5	; if not, branch
		subq.w	#1,d6
		btst	d6,d5	; is the priority bit set in the inline render flags?
		beq.s	.c5	; if not, branch
		ori.w	#$8000,d3	; otherwise set priority bit in art tile
.c5
		add.b	d1,d1	; is the high palette line bit set?
		bhs.s	.c4	; if not, branch
		subq.w	#1,d6
		btst	d6,d5
		beq.s	.c4
		addi.w	#$4000,d3
.c4
		add.b	d1,d1	; is the low palette line bit set?
		bhs.s	.c3	; if not, branch
		subq.w	#1,d6
		btst	d6,d5
		beq.s	.c3
		addi.w	#$2000,d3
.c3
		add.b	d1,d1	; is the vertical flip flag set?
		bhs.s	.c2	; if not, branch
		subq.w	#1,d6
		btst	d6,d5
		beq.s	.c2
		ori.w	#$1000,d3
.c2
		add.b	d1,d1	; is the horizontal flip flag set?
		bhs.s	.c	; if not, branch
		subq.w	#1,d6
		btst	d6,d5
		beq.s	.c
		ori.w	#$800,d3
.c
		move.w	d5,d1
		move.w	d6,d7
		sub.w	a5,d7	; subtract length in bits of inline copy value
		bhs.s	.enoughBits	; branch if a new word doesn't need to be read
		move.w	d7,d6
		addi.w	#$10,d6
		neg.w	d7	; calculate bit deficit
		lsl.w	d7,d1	; and make space for that many bits
		move.b	(a0),d5	; get next byte
		rol.b	d7,d5	; and rotate the required bits into the lowest positions
		add.w	d7,d7
		and.w	enidec_Masks-2(pc,d7.w),d5
		add.w	d5,d1	; combine upper bits with lower bits

.maskValue:
		move.w	a5,d0	; get length in bits of inline copy value
		add.w	d0,d0
		and.w	enidec_Masks-2(pc,d0.w),d1	; mask value appropriately
		add.w	d3,d1	; add starting art tile
		move.b	(a0)+,d5
		lsl.w	#8,d5
		move.b	(a0)+,d5	; get next word
		rts
; ---------------------------------------------------------------------------

.enoughBits:
		beq.s	.justEnough	; if the word has been exactly exhausted, branch
		lsr.w	d7,d1	; get inline copy value
		move.w	a5,d0
		add.w	d0,d0
		and.w	enidec_Masks-2(pc,d0.w),d1	; and mask it appropriately
		add.w	d3,d1	; add starting art tile
		move.w	a5,d0
		bra.s	enidec_FetchByte
; ---------------------------------------------------------------------------

.justEnough:
		moveq	#$10,d6	; reset shift value
		bra.s	.maskValue
; End of function enidec_FetchInlineValue

; ---------------------------------------------------------------------------
enidec_Masks:
		dc.w     1
		dc.w     3
		dc.w     7
		dc.w    $F
		dc.w   $1F
		dc.w   $3F
		dc.w   $7F
		dc.w   $FF
		dc.w  $1FF
		dc.w  $3FF
		dc.w  $7FF
		dc.w  $FFF
		dc.w $1FFF
		dc.w $3FFF
		dc.w $7FFF
		dc.w $FFFF

; ---------------------------------------------------------------------------
; Part of the Enigma decompressor, fetches the next byte if needed
; ---------------------------------------------------------------------------

; =============== S U B R O U T I N E =======================================


enidec_FetchByte:
		sub.w	d0,d6	; subtract length of current entry from shift value so that next entry is read next time around
		cmpi.w	#9,d6	; does a new byte need to be read?
		bhs.s	.c	; if not, branch
		addq.w	#8,d6
		asl.w	#8,d5
		move.b	(a0)+,d5
.c
		rts
; End of function enidec_FetchByte

; ---------------------------------------------------------------------------
; Kosinski decompression algorithm
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


; (sometimes called KOZINSKI decompression)
;
; ARGUMENTS:
; a0 = source address
; a1 = destination address
;
; For format explanation see http://info.sonicretro.org/Kosinski_compression
; New faster version by written by vladikcomper, with additional improvements by
; MarkeyJester and Flamewing
; ---------------------------------------------------------------------------
_Kos_UseLUT = 1
_Kos_LoopUnroll = 3
_Kos_ExtremeUnrolling = 1

_Kos_RunBitStream macro
        dbra    d2,.skip\@
        moveq   #7,d2                                   ; Set repeat count to 8.
        move.b  d1,d0                                   ; Use the remaining 8 bits.
        not.w   d3                                      ; Have all 16 bits been used up?
        bne.s   .skip\@                                 ; Branch if not.
        move.b  (a0)+,d0                                ; Get desc field low-byte.
        move.b  (a0)+,d1                                ; Get desc field hi-byte.
        if _Kos_UseLUT=1
        move.b  (a4,d0.w),d0                    ; Invert bit order...
        move.b  (a4,d1.w),d1                    ; ... for both bytes.
        endif
.skip\@
        endm

_Kos_ReadBit macro
        if _Kos_UseLUT=1
        add.b   d0,d0                                   ; Get a bit from the bitstream.
        else
        lsr.b   #1,d0                                   ; Get a bit from the bitstream.
        endif
        endm
; ===========================================================================
; KozDec_193A:
KosDec:
        moveq   #(1<<_Kos_LoopUnroll)-1,d7
        if _Kos_UseLUT=1
        moveq   #0,d0
        moveq   #0,d1
        lea     KosDec_ByteMap(pc),a4           ; Load LUT pointer.
        endif
        move.b  (a0)+,d0                                ; Get desc field low-byte.
        move.b  (a0)+,d1                                ; Get desc field hi-byte.
        if _Kos_UseLUT=1
        move.b  (a4,d0.w),d0                    ; Invert bit order...
        move.b  (a4,d1.w),d1                    ; ... for both bytes.
        endif
        moveq   #7,d2                                   ; Set repeat count to 8.
        moveq   #0,d3                                   ; d3 will be desc field switcher.
        bra.s   .FetchNewCode
; ---------------------------------------------------------------------------
.FetchCodeLoop:
        ; Code 1 (Uncompressed byte).
        _Kos_RunBitStream
        move.b  (a0)+,(a1)+

.FetchNewCode:
        _Kos_ReadBit
        bcs.s   .FetchCodeLoop                  ; If code = 1, branch.

        ; Codes 00 and 01.
        moveq   #-1,d5
        lea     (a1),a5
        _Kos_RunBitStream
        if _Kos_ExtremeUnrolling=1
        _Kos_ReadBit
        bcs.w   .Code_01

        ; Code 00 (Dictionary ref. short).
        _Kos_RunBitStream
        _Kos_ReadBit
        bcs.s   .Copy45
        _Kos_RunBitStream
        _Kos_ReadBit
        bcs.s   .Copy3
        _Kos_RunBitStream
        move.b  (a0)+,d5                                ; d5 = displacement.
        adda.w  d5,a5
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        bra.s   .FetchNewCode
; ---------------------------------------------------------------------------
.Copy3:
        _Kos_RunBitStream
        move.b  (a0)+,d5                                ; d5 = displacement.
        adda.w  d5,a5
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        bra.w   .FetchNewCode
; ---------------------------------------------------------------------------
.Copy45:
        _Kos_RunBitStream
        _Kos_ReadBit
        bcs.s   .Copy5
        _Kos_RunBitStream
        move.b  (a0)+,d5                                ; d5 = displacement.
        adda.w  d5,a5
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        bra.w   .FetchNewCode
; ---------------------------------------------------------------------------
.Copy5:
        _Kos_RunBitStream
        move.b  (a0)+,d5                                ; d5 = displacement.
        adda.w  d5,a5
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        move.b  (a5)+,(a1)+
        bra.w   .FetchNewCode
; ---------------------------------------------------------------------------
        else
        moveq   #0,d4                                   ; d4 will contain copy count.
        _Kos_ReadBit
        bcs.s   .Code_01

        ; Code 00 (Dictionary ref. short).
        _Kos_RunBitStream
        _Kos_ReadBit
        addx.w  d4,d4
        _Kos_RunBitStream
        _Kos_ReadBit
        addx.w  d4,d4
        _Kos_RunBitStream
        move.b  (a0)+,d5                                ; d5 = displacement.

.StreamCopy:
        adda.w  d5,a5
        move.b  (a5)+,(a1)+                             ; Do 1 extra copy (to compensate +1 to copy counter).

.copy:
        move.b  (a5)+,(a1)+
        dbra    d4,.copy
        bra.w   .FetchNewCode
        endif
; ---------------------------------------------------------------------------
.Code_01:
        moveq   #0,d4                                   ; d4 will contain copy count.
        ; Code 01 (Dictionary ref. long / special).
        _Kos_RunBitStream
        move.b  (a0)+,d6                                ; d6 = %LLLLLLLL.
        move.b  (a0)+,d4                                ; d4 = %HHHHHCCC.
        move.b  d4,d5                                   ; d5 = %11111111 HHHHHCCC.
        lsl.w   #5,d5                                   ; d5 = %111HHHHH CCC00000.
        move.b  d6,d5                                   ; d5 = %111HHHHH LLLLLLLL.
        if _Kos_LoopUnroll=3
        and.w   d7,d4                                   ; d4 = %00000CCC.
        else
        andi.w  #7,d4
        endif
        bne.s   .StreamCopy                             ; if CCC=0, branch.

        ; special mode (extended counter)
        move.b  (a0)+,d4                                ; Read cnt
        beq.s   .Quit                                   ; If cnt=0, quit decompression.
        subq.b  #1,d4
        beq.w   .FetchNewCode                   ; If cnt=1, fetch a new code.

        adda.w  d5,a5
        move.b  (a5)+,(a1)+                             ; Do 1 extra copy (to compensate +1 to copy counter).
        move.w  d4,d6
        not.w   d6
        and.w   d7,d6
        add.w   d6,d6
        lsr.w   #_Kos_LoopUnroll,d4
        jmp     .largecopy(pc,d6.w)
; ---------------------------------------------------------------------------
.largecopy:
        rept (1<<_Kos_LoopUnroll)
        move.b  (a5)+,(a1)+
        endr
        dbra    d4,.largecopy
        bra.w   .FetchNewCode
; ---------------------------------------------------------------------------
        if _Kos_ExtremeUnrolling=1
.StreamCopy:
        adda.w  d5,a5
        move.b  (a5)+,(a1)+                             ; Do 1 extra copy (to compensate +1 to copy counter).
        if _Kos_LoopUnroll=3
        eor.w   d7,d4
        else
        eori.w  #7,d4
        endif
        add.w   d4,d4
        jmp     .mediumcopy(pc,d4.w)
; ---------------------------------------------------------------------------
.mediumcopy:
        rept 8
        move.b  (a5)+,(a1)+
        endr
        bra.w   .FetchNewCode
        endif
; ---------------------------------------------------------------------------
.Quit:
        rts                                                             ; End of function KosDec.
; ===========================================================================
        if _Kos_UseLUT=1
KosDec_ByteMap:
        dc.b    $00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
        dc.b    $08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
        dc.b    $04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
        dc.b    $0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
        dc.b    $02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
        dc.b    $0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
        dc.b    $06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
        dc.b    $0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
        dc.b    $01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
        dc.b    $09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
        dc.b    $05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
        dc.b    $0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
        dc.b    $03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
        dc.b    $0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
        dc.b    $07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
        dc.b    $0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
        endif
; ===========================================================================

; ===============================================================
; ---------------------------------------------------------------
; COMPER Decompressor
; ---------------------------------------------------------------
; INPUT:
;       a2      - Source Offset
;       a1      - Destination Offset
; ---------------------------------------------------------------
CompDecToVRAM:
		lea	CompDec_RAM,a1	; get the RAM for the space provided for CompDec
		bsr	CompDec		; decompress to RAM

		lea	CompDec_RAM.w,a2; get the RAM again
		lea	VDP_Data_Port,a6; get VDP data port
		move.l	a1,d0		; move end address to d0
		sub.l	a2,d0		; substract the compdec buffer address from d0
		lsr.l	#2,d0		; shift 2 bits to right (as we transfer longword per loop
		subq.l	#1,d0		; substract 1 from d0 because of dbf

		move	#$2700,sr	; disable interrupts
		move.l	d6,4(a6)	; set VDP transfer mode
.loop		move.l	(a2)+,(a6)	; transfer next longword
		dbf	d0,.loop	; loop until d0 = 0
		move	#$2300,sr	; enable interrupts
		rts

.EndTransfer
		rts
CompDec:
.newblock
	        move.w	(a2)+,d0                ; fetch description field
	        moveq	#15,d3                  ; set bits counter to 16

.mainloop
	        add.w	d0,d0                   ; roll description field
	        blo	.flag                   ; if a flag issued, branch
	        move.w	(a2)+,(a1)+             ; otherwise, do uncompressed data
	        dbf	d3,.mainloop            ; if bits counter remains, parse the next word
	        bra	.newblock               ; start a new block

; ---------------------------------------------------------------
.flag		moveq	#-1,d1                  ; init displacement
	        move.b	(a2)+,d1                ; load displacement
	        add.w	d1,d1
	        moveq	#0,d2                   ; init copy count
	        move.b	(a2)+,d2                ; load copy length
	        beq	pend                   ; if zero, branch
	        lea	(a1,d1),a3              ; load start copy address

.loop		move.w	(a3)+,(a1)+             ; copy given sequence
	        dbf	d2,.loop                ; repeat
	        dbf	d3,.mainloop            ; if bits counter remains, parse the next word
	        bra	.newblock               ; start a new block

pend		rts
; ---------------------------------------------------------------------------
; Pallet cycling routine loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

PalCycle_Load:				; XREF: Demo; Level_MainLoop; End_MainLoop
		cmpi.b	#8,$FFFFF600.w	; if not in level (or special stage), exit
		blt.s	pend
		moveq	#0,d2
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0 ; get level number
		add.w	d0,d0		; multiply by 2
		move.w	PalCycle(pc,d0.w),d0 ; load animated pallets offset index into d0
		jmp	PalCycle(pc,d0.w) ; jump to PalCycle + offset index
; End of function PalCycle_Load

; ===========================================================================
; ---------------------------------------------------------------------------
; Pallet cycling routines
; ---------------------------------------------------------------------------
PalCycle:	dc.w PalCycle_GHZ-PalCycle
		dc.w PalCycle_LZ-PalCycle
		dc.w PalCycle_MZ-PalCycle
		dc.w PalCycle_SLZ-PalCycle
		dc.w PalCycle_SYZ-PalCycle
		dc.w PalCycle_SBZ-PalCycle
		dc.w PalCycle_GHZ-PalCycle
                dc.w PalCycle_Ow-PalCycle
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

PalCycle_GHZ:				; XREF: PalCycle
		lea	(Pal_GHZCyc).l,a0

loc_196A:				; XREF: PalCycle_Title
		subq.w	#1,($FFFFF634).w
		bpl.s	locret_1990
		move.w	#5,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#8,($FFFFF632).w
		andi.w	#$18,d0
		lea	Palette_NCurr+$50.w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)

locret_1990:
		rts
; End of function PalCycle_Title


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_LZ:				; XREF: PalCycle
		subq.w	#1,($FFFFF634).w
		bpl.s	loc_19D8
		move.w	#2,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#8,($FFFFF632).w
		andi.w	#$18,d0
		lea	Pal_LZCyc1,a0

loc_19C0:
		lea	Palette_NCurr+$56.w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)
		lea	Palette_UCurr+$56.w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)

loc_19D8:
		move.w	($FFFFFE04).w,d0
		andi.w	#7,d0
		move.b	byte_1A3C(pc,d0.w),d0
		beq.s	locret_1A3A
		moveq	#1,d1
		tst.b	($FFFFF7C0).w
		beq.s	loc_19F0
		neg.w	d1

loc_19F0:
		move.w	($FFFFF650).w,d0
		andi.w	#3,d0
		add.w	d1,d0
		cmpi.w	#3,d0
		blo.s	loc_1A0A
		move.w	d0,d1
		moveq	#0,d0
		tst.w	d1
		bpl.s	loc_1A0A
		moveq	#2,d0

loc_1A0A:
		move.w	d0,($FFFFF650).w
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	Pal_LZCyc2,a0
		lea	Palette_NCurr+$76.w,a1
		move.l	(a0,d0.w),(a1)+
		move.w	4(a0,d0.w),(a1)
		lea	Pal_LZCyc3,a0
		lea	Palette_UCurr+$76.w,a1
		move.l	(a0,d0.w),(a1)+
		move.w	4(a0,d0.w),(a1)

locret_1A3A:
		rts
; ===========================================================================
byte_1A3C:	dc.b 1,	0, 0, 1, 0, 0, 1, 0
; ===========================================================================

PalCycle_MZ:				; XREF: PalCycle
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_SLZ:				; XREF: PalCycle
		subq.w	#1,($FFFFF634).w
		bpl.s	locret_1A80
		move.w	#7,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,d0
		cmpi.w	#6,d0
		blo.s	loc_1A60
		moveq	#0,d0

loc_1A60:
		move.w	d0,($FFFFF632).w
		move.w	d0,d1
		add.w	d1,d1
		add.w	d1,d0
		add.w	d0,d0
		lea	(Pal_SLZCyc).l,a0
		lea	Palette_NCurr+$56.w,a1
		move.w	(a0,d0.w),(a1)
		move.l	2(a0,d0.w),4(a1)

locret_1A80:
		rts
; End of function PalCycle_SLZ


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_SYZ:				; XREF: PalCycle
		subq.w	#1,($FFFFF634).w
		bpl.s	locret_1AC6
		move.w	#5,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#2,d0
		move.w	d0,d1
		add.w	d0,d0
		lea	(Pal_SYZCyc1).l,a0
		lea	Palette_NCurr+$6E.w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)
		lea	(Pal_SYZCyc2).l,a0
		lea	Palette_NCurr+$76.w,a1
		move.w	(a0,d1.w),(a1)
		move.w	2(a0,d1.w),4(a1)

locret_1AC6:
		rts
; End of function PalCycle_SYZ


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
PalcycOw_offs	equ Bought_Items+4
PalcycOw_timer	equ Bought_Items+6

PalCycle_OW:
		cmpi.b	#$1C,$FFFFF742.w
		bge.s	locret_1AC6
		subq.w	#1,PalcycOw_timer.w
		bpl.s	PalCycle_OW2

		moveq	#(($20*2)/4)-1,d1
		move.w	PalcycOw_offs.w,d0
		move.l	PalList_ow(pc,d0.w),a0
		lea	Palette_NCurr+$40.w,a1

.loop		move.l	(a0)+,(a1)+
		dbf	d1,.loop

		move.w	#3,PalcycOw_timer.w
		add.w	#4,PalcycOw_offs.w

		cmp.w	#4*7,PalcycOw_offs.w
		bne.s	PalCycle_OW2
		move.l	#60,PalcycOw_offs.w
		bra.s	PalCycle_OW2

PalList_ow:	dc.l pal_ow+$20, pal_ow7+$20, pal_ow6+$20, pal_ow5+$20, pal_ow6+$20, pal_ow7+$20, pal_ow+$20

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
PalCycle_SBZ:				; XREF: PalCycle

		lea	(Pal_SBZCycList).l,a2
		tst.b	($FFFFFE11).w
		beq.s	loc_1ADA

PalCycle_OW2:
		lea	(Pal_SBZCycList2).l,a2

loc_1ADA:
		lea	($FFFFF650).w,a1
		move.w	(a2)+,d1

loc_1AE0:
		subq.b	#1,(a1)
		bmi.s	loc_1AEA
		addq.l	#2,a1
		addq.l	#8,a2
		bra.s	loc_1B06
; ===========================================================================

loc_1AEA:				; XREF: PalCycle_SBZ
		move.b	(a2)+,(a1)+
		move.b	(a1),d0
		addq.b	#1,d0
		cmp.b	(a2)+,d0
		blo.s	loc_1AF6
		moveq	#0,d0

loc_1AF6:
		move.b	d0,(a1)+
		andi.w	#$F,d0
		add.w	d0,d0
		movea.l	(a2)+,a0
		movea.w	(a2)+,a3
		move.w	(a0,d0.w),(a3)

loc_1B06:				; XREF: PalCycle_SBZ
		dbf	d1,loc_1AE0
		subq.w	#1,($FFFFF634).w
		bpl.s	locret_1B64
		lea	(Pal_SBZCyc4).l,a0
		move.w	#1,($FFFFF634).w
		tst.b	($FFFFFE11).w
		beq.s	loc_1B2E
		lea	(Pal_SBZCyc10).l,a0
		move.w	#0,($FFFFF634).w

loc_1B2E:
		moveq	#-1,d1
		tst.b	($FFFFF7C0).w
		beq.s	loc_1B38
		neg.w	d1

loc_1B38:
		move.w	($FFFFF632).w,d0
		andi.w	#3,d0
		add.w	d1,d0
		cmpi.w	#3,d0
		blo.s	loc_1B52
		move.w	d0,d1
		moveq	#0,d0
		tst.w	d1
		bpl.s	loc_1B52
		moveq	#2,d0

loc_1B52:
		move.w	d0,($FFFFF632).w
		add.w	d0,d0
		lea	Palette_NCurr+$58.w,a1
		move.l	(a0,d0.w),(a1)+
		move.w	4(a0,d0.w),(a1)

locret_1B64:
		rts
; End of function PalCycle_SBZ

; ===========================================================================
Pal_GHZCyc:	incbin	pallet\c_ghz.bin
Pal_LZCyc1:	incbin	pallet\c_lz_wat.bin	; waterfalls pallet
Pal_LZCyc2:	incbin	pallet\c_lz_bel.bin	; conveyor belt pallet
Pal_LZCyc3:	incbin	pallet\c_lz_buw.bin	; conveyor belt (underwater) pallet
Pal_SBZ3Cyc1:	incbin	pallet\c_sbz3_w.bin	; waterfalls pallet
Pal_SLZCyc:	incbin	pallet\c_slz.bin
Pal_SYZCyc1:	incbin	pallet\c_syz_1.bin
Pal_SYZCyc2:	incbin	pallet\c_syz_2.bin

Pal_SBZCycList:
	include "_inc\SBZ pallet script 1.asm"

Pal_SBZCycList2:
	include "_inc\SBZ pallet script 2.asm"

Pal_SBZCyc1:	incbin	pallet\c_sbz_1.bin
Pal_SBZCyc2:	incbin	pallet\c_sbz_2.bin
Pal_SBZCyc3:	incbin	pallet\c_sbz_3.bin
Pal_SBZCyc4:	incbin	pallet\c_sbz_4.bin
Pal_SBZCyc5:	incbin	pallet\c_sbz_5.bin
Pal_SBZCyc6:	incbin	pallet\c_sbz_6.bin
Pal_SBZCyc7:	incbin	pallet\c_sbz_7.bin
Pal_SBZCyc8:	incbin	pallet\c_sbz_8.bin
Pal_SBZCyc9:	incbin	pallet\c_sbz_9.bin
Pal_SBZCyc10:	incbin	pallet\c_sbz_10.bin
; ---------------------------------------------------------------------------
; Subroutine to	fade out and fade in
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_FadeTo:
		move.w	#$3F,($FFFFF626).w

Pal_FadeTo2:
		moveq	#0,d0
		lea	Palette_NCurr.w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		moveq	#0,d1
		move.b	($FFFFF627).w,d0

Pal_ToBlack:
		move.w	d1,(a0)+
		dbf	d0,Pal_ToBlack	; fill pallet with $000	(black)
		moveq	#$0E,d4					; MJ: prepare maximum colour check
		moveq	#$00,d6					; MJ: clear d6

loc_1DCE:
		bsr.w	RunPLC_RAM
		move.b	#$12,(VBlank_Routine).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1DCE				; MJ: if null, delay a frame
		bsr.s	Pal_FadeIn
		subq.b	#$02,d4					; MJ: decrease colour check
		bne	loc_1DCE				; MJ: if it has not reached null, branch
		move.b	#$12,(VBlank_Routine).w			; MJ: wait for V-blank again (so colours transfer)
		bra	DelayProgram				; MJ: ''

; End of function Pal_FadeTo

; ---------------------------------------------------------------------------
; Pallet fade-in subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_FadeIn:				; XREF: Pal_FadeTo
		moveq	#0,d0
		lea	Palette_NCurr.w,a0
		lea	Palette_NTarget.w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0

loc_1DFA:
		bsr.s	Pal_AddColor
		dbf	d0,loc_1DFA
		tst.l	Water_Array.w	; check if has water
		bmi.s	locret_1E24
		moveq	#0,d0
		lea	Palette_UCurr.w,a0
		lea	Palette_UTarget.w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0

loc_1E1E:
		bsr.s	Pal_AddColor
		dbf	d0,loc_1E1E

locret_1E24:
		rts
; End of function Pal_FadeIn


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_AddColor:				; XREF: Pal_FadeIn
		move.b	(a1),d5					; MJ: load blue
		move.w	(a1)+,d1				; MJ: load green and red
		move.b	d1,d2					; MJ: load red
		lsr.b	#$04,d1					; MJ: get only green
		andi.b	#$0E,d2					; MJ: get only red
		move.w	(a0),d3					; MJ: load current colour in buffer
		cmp.b	d5,d4					; MJ: is it time for blue to fade?
		bhi	FCI_NoBlue				; MJ: if not, branch
		addi.w	#$0200,d3				; MJ: increase blue

FCI_NoBlue:
		cmp.b	d1,d4					; MJ: is it time for green to fade?
		bhi	FCI_NoGreen				; MJ: if not, branch
		addi.b	#$20,d3					; MJ: increase green

FCI_NoGreen:
		cmp.b	d2,d4					; MJ: is it time for red to fade?
		bhi	FCI_NoRed				; MJ: if not, branch
		addq.b	#$02,d3					; MJ: increase red

FCI_NoRed:
		move.w	d3,(a0)+				; MJ: save colour
		rts						; MJ: return

; End of function Pal_AddColor


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_FadeFrom:
		move.w	#$3F,($FFFFF626).w
		moveq	#$07,d4					; MJ: set repeat times
		moveq	#$00,d6					; MJ: clear d6

loc_1E5C:
		bsr.w	RunPLC_RAM
		move.b	#$12,(VBlank_Routine).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1E5C				; MJ: if null, delay a frame
		bsr.s	Pal_FadeOut
		dbf	d4,loc_1E5C
		rts
; End of function Pal_FadeFrom

; ---------------------------------------------------------------------------
; Pallet fade-out subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_FadeOut:				; XREF: Pal_FadeFrom
		moveq	#0,d0
		lea	Palette_NCurr.w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0

loc_1E82:
		bsr.s	Pal_DecColor
		dbf	d0,loc_1E82

		moveq	#0,d0
		lea	Palette_UCurr.w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0

loc_1E98:
		bsr.s	Pal_DecColor
		dbf	d0,loc_1E98
		rts
; End of function Pal_FadeOut


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_DecColor:				; XREF: Pal_FadeOut
		move.w	(a0),d5					; MJ: load colour
		move.w	d5,d1					; MJ: copy to d1
		move.b	d1,d2					; MJ: load green and red
		move.b	d1,d3					; MJ: load red
		andi.w	#$0E00,d1				; MJ: get only blue
		beq	FCO_NoBlue				; MJ: if blue is finished, branch
		subi.w	#$0200,d5				; MJ: decrease blue

FCO_NoBlue:
		andi.w	#$00E0,d2				; MJ: get only green (needs to be word)
		beq	FCO_NoGreen				; MJ: if green is finished, branch
		subi.b	#$20,d5					; MJ: decrease green

FCO_NoGreen:
		andi.b	#$0E,d3					; MJ: get only red
		beq	FCO_NoRed				; MJ: if red is finished, branch
		subq.b	#$02,d5					; MJ: decrease red

FCO_NoRed:
		move.w	d5,(a0)+				; MJ: save new colour
		rts						; MJ: return

; End of function Pal_DecColor

; ---------------------------------------------------------------------------
; Subroutine to	fill the pallet	with white (special stage)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_MakeWhite:				; XREF: SpecialStage
		move.w	#$3F,($FFFFF626).w
		moveq	#0,d0
		lea	Palette_NCurr.w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.w	#$EEE,d1
		move.b	($FFFFF627).w,d0

PalWhite_Loop:
		move.w	d1,(a0)+
		dbf	d0,PalWhite_Loop
		move.w	#$15,d4

loc_1EF4:
		move.b	#$12,(VBlank_Routine).w
		bsr.w	DelayProgram
		bsr.s	Pal_WhiteToBlack
		bsr.w	RunPLC_RAM
		dbf	d4,loc_1EF4
		rts
; End of function Pal_MakeWhite


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_WhiteToBlack:			; XREF: Pal_MakeWhite
		moveq	#0,d0
		lea	Palette_NCurr.w,a0
		lea	Palette_NTarget.w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0

loc_1F20:
		bsr.s	Pal_DecColor2
		dbf	d0,loc_1F20

		tst.l	Water_Array.w	; check if has water
		bmi.w	locret_1F4A
		moveq	#0,d0
		lea	Palette_UCurr.w,a0
		lea	Palette_UTarget.w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0

loc_1F44:
		bsr.s	Pal_DecColor2
		dbf	d0,loc_1F44

locret_1F4A:
		rts
; End of function Pal_WhiteToBlack


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_DecColor2:				; XREF: Pal_WhiteToBlack
		move.w	(a1)+,d2
		move.w	(a0),d3
		cmp.w	d2,d3
		beq.s	loc_1F78
		move.w	d3,d1
		subi.w	#$200,d1	; decrease blue	value
		blo.s	loc_1F64
		cmp.w	d2,d1
		blo.s	loc_1F64
		move.w	d1,(a0)+
		rts
; ===========================================================================

loc_1F64:				; XREF: Pal_DecColor2
		move.w	d3,d1
		subi.w	#$20,d1		; decrease green value
		blo.s	loc_1F74
		cmp.w	d2,d1
		blo.s	loc_1F74
		move.w	d1,(a0)+
		rts
; ===========================================================================

loc_1F74:				; XREF: loc_1F64
		subq.w	#2,(a0)+	; decrease red value
		rts
; ===========================================================================

loc_1F78:				; XREF: Pal_DecColor2
		addq.w	#2,a0
		rts
; End of function Pal_DecColor2

; ---------------------------------------------------------------------------
; Pallet fade-out to color subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Pal_FadeFromTo:
		move.w	#$3F,($FFFFF626).w
		moveq	#$07,d4					; MJ: set repeat times
		moveq	#$00,d6					; MJ: clear d6

.loop		bsr.w	RunPLC_RAM
		move.b	#$12,VBlank_Routine.w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	.loop					; MJ: if null, delay a frame
		move.l	d4,-(sp)
		move.w	d6,-(sp)
		bsr.s	Pal_FadeOutTo
		move.w	(sp)+,d6
		move.l	(sp)+,d4
		dbf	d4,.loop
		rts

Pal_FadeOutTo:				; XREF: Pal_FadeFrom
		moveq	#0,d0
		lea	Palette_NCurr.w,a0
		lea	Palette_NTarget.w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0

.loop		bsr.s	.DecColor
		dbf	d0,.loop
		rts
; End of function Pal_FadeOut


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


.DecColor				; XREF: Pal_FadeOut
		move.w	(a0),d5					; MJ: load colour
		move.w	d5,d1					; MJ: copy to d1
		move.b	d1,d2					; MJ: load green and red
		move.b	d1,d3					; MJ: load red

		move.w	(a1)+,d6				; GS: load colour
		move.b	d6,d4					; GS: copy to d1
		move.b	d4,d7					; GS: load green and red

		andi.w	#$0E00,d1				; MJ: get only blue
		andi.w	#$0E00,d6				; GS: get only blue
		cmp.w	d6,d1
		beq	.NoBlue
		subi.w	#$0200,d5				; MJ: decrease blue

.NoBlue		andi.w	#$00E0,d2				; MJ: get only green (needs to be word)
		andi.w	#$00E0,d4				; GS: get only green
		cmp.w	d4,d2
		beq	.NoGreen
		subi.b	#$20,d5					; MJ: decrease green

.NoGreen	andi.b	#$0E,d3					; MJ: get only red
		andi.b	#$0E,d7					; GS: get only red
		cmp.b	d7,d3
		beq	.NoRed
		subq.b	#$02,d5					; MJ: decrease red

.NoRed		move.w	d5,(a0)+				; MJ: save new colour
		rts						; MJ: return

; End of function Pal_DecColor
; ---------------------------------------------------------------------------
; Subroutine to	make a white flash when	you enter a special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_MakeFlash:				; XREF: SpecialStage
		move.w	#$3F,($FFFFF626).w
		move.w	#$15,d4

loc_1F86:
		move.b	#$12,(VBlank_Routine).w
		bsr.w	DelayProgram
		bsr.s	Pal_ToWhite
		bsr.w	RunPLC_RAM
		dbf	d4,loc_1F86
		rts
; End of function Pal_MakeFlash


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_ToWhite:				; XREF: Pal_MakeFlash
		moveq	#0,d0
		lea	Palette_NCurr.w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0

loc_1FAC:
		bsr.s	Pal_AddColor2
		dbf	d0,loc_1FAC
		moveq	#0,d0
		lea	Palette_UCurr.w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0

loc_1FC2:
		bsr.s	Pal_AddColor2
		dbf	d0,loc_1FC2
		rts
; End of function Pal_ToWhite


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_AddColor2:				; XREF: Pal_ToWhite
		move.w	(a0),d2
		cmpi.w	#$EEE,d2
		beq.s	loc_2006
		move.w	d2,d1
		andi.w	#$E,d1
		cmpi.w	#$E,d1
		beq.s	loc_1FE2
		addq.w	#2,(a0)+	; increase red value
		rts
; ===========================================================================

loc_1FE2:				; XREF: Pal_AddColor2
		move.w	d2,d1
		andi.w	#$E0,d1
		cmpi.w	#$E0,d1
		beq.s	loc_1FF4
		addi.w	#$20,(a0)+	; increase green value
		rts
; ===========================================================================

loc_1FF4:				; XREF: loc_1FE2
		move.w	d2,d1
		andi.w	#$E00,d1
		cmpi.w	#$E00,d1
		beq.s	loc_2006
		addi.w	#$200,(a0)+	; increase blue	value
		rts
; ===========================================================================

loc_2006:				; XREF: Pal_AddColor2
		addq.w	#2,a0
		rts
; End of function Pal_AddColor2

; ---------------------------------------------------------------------------
; Pallet cycling routine - Sega	logo
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_Sega:				; XREF: SegaScreen
		tst.b	($FFFFF635).w
		bne.s	loc_206A
		lea	($FFFFFB20).w,a1
		lea	(Pal_Sega1).l,a0
		moveq	#5,d1
		move.w	($FFFFF632).w,d0

loc_2020:
		bpl.s	loc_202A
		addq.w	#2,a0
		subq.w	#1,d1
		addq.w	#2,d0
		bra.s	loc_2020
; ===========================================================================

loc_202A:				; XREF: PalCycle_Sega
		move.w	d0,d2
		andi.w	#$1E,d2
		bne.s	loc_2034
		addq.w	#2,d0

loc_2034:
		cmpi.w	#$60,d0
		bhs.s	loc_203E
		move.w	(a0)+,(a1,d0.w)

loc_203E:
		addq.w	#2,d0
		dbf	d1,loc_202A
		move.w	($FFFFF632).w,d0
		addq.w	#2,d0
		move.w	d0,d2
		andi.w	#$1E,d2
		bne.s	loc_2054
		addq.w	#2,d0

loc_2054:
		cmpi.w	#$64,d0
		blt.s	loc_2062
		move.w	#$401,($FFFFF634).w
		moveq	#-$C,d0

loc_2062:
		move.w	d0,($FFFFF632).w
		moveq	#1,d0
		rts
; ===========================================================================

loc_206A:				; XREF: loc_202A
		subq.b	#1,($FFFFF634).w
		bpl.s	loc_20BC
		move.b	#4,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addi.w	#$C,d0
		cmpi.w	#$30,d0
		blo.s	loc_2088
		moveq	#0,d0
		rts
; ===========================================================================

loc_2088:				; XREF: loc_206A
		move.w	d0,($FFFFF632).w
		lea	(Pal_Sega2).l,a0
		lea	(a0,d0.w),a0
		lea	($FFFFFB04).w,a1
		move.l	(a0)+,(a1)+
		move.l	(a0)+,(a1)+
		move.w	(a0)+,(a1)
		lea	($FFFFFB20).w,a1
		moveq	#0,d0
		moveq	#$2C,d1

loc_20A8:
		move.w	d0,d2
		andi.w	#$1E,d2
		bne.s	loc_20B2
		addq.w	#2,d0

loc_20B2:
		move.w	(a0),(a1,d0.w)
		addq.w	#2,d0
		dbf	d1,loc_20A8

loc_20BC:
		moveq	#1,d0
		rts
; End of function PalCycle_Sega

; ===========================================================================

Pal_Sega1:	incbin	pallet\sega1.bin
Pal_Sega2:	incbin	pallet\sega2.bin

; ---------------------------------------------------------------------------
; Subroutines to load pallets
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad1:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		suba.w	#$80,a3
		move.w	(a1)+,d7

loc_2110:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2110
		rts
; End of function PalLoad1


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad2:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		move.w	(a1)+,d7

loc_2128:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2128
		rts
; End of function PalLoad2

; ---------------------------------------------------------------------------
; Underwater pallet loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad3_Water:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		adda.w	#$80,a3
		move.w	(a1)+,d7

loc_2144:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2144
		rts
; End of function PalLoad3_Water


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad4_Water:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		suba.w	#$100,a3
		move.w	(a1)+,d7

loc_2160:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2160
		rts
; End of function PalLoad4_Water

; ===========================================================================
; ---------------------------------------------------------------------------
; Pallet pointers
; ---------------------------------------------------------------------------
PalPointers:
	include "_inc\Pallet pointers.asm"

; ---------------------------------------------------------------------------
; Pallet data
; ---------------------------------------------------------------------------
Pal_SegaBG:	incbin	pallet\sega_bg.bin
Pal_LevelSel:	incbin	pallet\levelsel.bin
Pal_SaveSelect:
Pal_GHZ:	incbin	pallet\ghz.bin
Pal_LZ:		incbin	pallet\lz.bin
Pal_MZ:		incbin	pallet\mz.bin
Pal_SLZ:	incbin	pallet\slz.bin
Pal_SYZ:	incbin	pallet\syz.bin
Pal_SBZ1:	incbin	pallet\sbz_act1.bin	; SBZ act 1 pallets
Pal_SBZ2:	incbin	pallet\sbz_act2.bin	; SBZ act 2 & Final Zone pallets
Pal_LZWater:	incbin	pallet\lz_uw.bin	; LZ underwater pallets

Pal_SBZ3:	incbin	pallet\sbz_act3.bin	; SBZ act 3 pallets
Pal_SBZ3Water:	incbin	pallet\sbz_a3uw.bin	; SBZ act 3 (underwater) pallets
Pal_SBZ3SonWat:	incbin	pallet\son_sbzu.bin	; Sonic (underwater in SBZ act 3) pallet
Pal_LBZboss:	incbin	boss\LBZpalette.bin	; LBZ boss palette

; ---------------------------------------------------------------------------
; Subroutine to	delay the program by (VBlank_Routine) frames
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

DelayProgram__:
		move.l	DOS_txtoff,DOS_TextPos.w
DelayProgram_:
		st	VBlank_Routine.w	; set
DelayProgram:
		move.l	d7,-(sp)		; store d7
		moveq	#0,d7			; clear
		move	#$2300,sr		; enable VBI

.loop		addq.w	#1,d7			; increment d7
		tst.b	VBlank_Routine.w	; is routine 0
		bne.s	.loop			; if not, wait for vbi

		move.w	d7,Freecycles.w		; store d7
		move.l	(sp)+,d7		; pop d7
		rts				; return
; End of function DelayProgram

; ---------------------------------------------------------------------------
; Subroutine to	generate a pseudo-random number	in d0
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


RandomNumber:
		move.l	$FFFFF636.w,d1		; get last seed
		bne.s	.isreset		; if not 0, dont reset
		move.l	#'SEGA',d1		; sega is secret 4-byte value
		move.l	VDP_control_port,d0	; get data port
		eor.l	d0,d1			; eor 'SEGA'
		move.l	$C00008,d0		; get H/V
		eor.l	d0,d1			; eor d0

.isreset	move.l	d1,d0
		asl.l	#2,d1
		add.l	d0,d1
		asl.l	#3,d1
		add.l	d0,d1
		move.w	d1,d0
		swap	d1
		add.w	d1,d0
		move.w	d0,d1
		swap	d1
		move.l	d1,$FFFFF636.w
		rts
; End of function RandomNumber


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CalcSine:				; XREF: SS_BGAnimate; et al
		andi.w	#$FF,d1
		add.w	d1,d1
		addq.w	#8,d1
		move.w	Sine_Data-8(pc,d1.w),d0
		move.w	Sine_Data+($40*2)-8(pc,d1.w),d1
		rts
; End of function CalcSine

; ===========================================================================

Sine_Data:	incbin	misc\sinewave.bin	; values for a 360ยบ sine wave

; ===========================================================================

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CalcAngle:
		movem.l	d3-d4,-(sp)
		moveq	#0,d3
		moveq	#0,d4
		move.w	d1,d0
		move.w	d1,d3
		move.w	d2,d4
		or.w	d3,d4
		beq.s	loc_2D04
		move.w	d2,d4
		tst.w	d3
		bpl.w	loc_2CC2
		neg.w	d3

loc_2CC2:
		tst.w	d4
		bpl.w	loc_2CCA
		neg.w	d4

loc_2CCA:
		cmp.w	d3,d4
		bhs.w	loc_2CDC
		lsl.l	#8,d4
		divu.w	d3,d4
		moveq	#0,d1
		move.b	Angle_Data(pc,d4.w),d1
		bra.s	loc_2CE6
; ===========================================================================

loc_2CDC:				; XREF: CalcAngle
		lsl.l	#8,d3
		divu.w	d4,d3
		moveq	#$40,d1
		sub.b	Angle_Data(pc,d3.w),d1

loc_2CE6:
		tst.w	d0
		bpl.w	loc_2CF2
		neg.w	d1
		addi.w	#$80,d1

loc_2CF2:
		tst.w	d2
		bpl.w	loc_2CFE
		neg.w	d1
		addi.w	#$100,d1

loc_2CFE:
		movem.l	(sp)+,d3-d4
		rts
; ===========================================================================

loc_2D04:				; XREF: CalcAngle
		moveq	#$40,d1
		movem.l	(sp)+,d3-d4
		rts
; End of function CalcAngle

; ===========================================================================

Angle_Data:	incbin	misc\angles.bin

; ===========================================================================

; ---------------------------------------------------------------------------
; Sega screen
; ---------------------------------------------------------------------------

SegaScreen:				; XREF: GameModeArray
		move.w	d5,-(sp)
	SRAMEnable
		ori.w	#$8001,Music_EnabledChans.w	; enable sfx

		move	#$2700,sr
		bsr.w	SoundDriverLoad

		lea	SRAM_Start,a0
		movep.w	SRAM_LastLVL(a0),d0
		move.w	d0,$FFFFFE10.w
		movep.l	SRAM_Rings(a0),d0
		move.l	d0,DCL_Rings.w
		movep.l	SRAM_Items(a0),d0
		move.l	d0,Bought_Items.w
		move.b	SRAM_Char(a0),Current_Character.w
		move.b	SRAM_Lives(a0),$FFFFFE12.w	; djohe you little bitch

	SRAMDisable
	move.l	Bought_Items.w,d6
	move.l	d6,-(sp)
	bclr	#Used_Boobs,d6
	move.l	d6,Bought_Items.w

		clr.w	DMA_Buffer_Start			; clear start of the DMA queue
		move.l	#DMA_Buffer_Start,DMA_Buffer_End	; reset address pointer of DMA queue

		jsr	NatsumiScreen
		jsr	SSRG_Screen
		moveq	#$FFFFFFE4,d0
		bsr.w	PlaySound	; fade out music

		st	d6

		lea	Palette_NCurr,a0
		move.l	#$EEE0EEE,d0
		moveq	#((Palette_UCurr-Palette_NCurr)/4)-1,d1

.clr		move.l	d0,(a0)+
		dbf	d1,.clr

		move.l	(sp)+,Bought_Items.w

		move.b	#$16,VBlank_Routine.w
		bsr.w	DelayProgram
		moveq	#0,d7
		move.b	#4,$FFFFF600.w
		move.w	(sp)+,d5
		bpl.s	TitleScreen_skip
		jmp	NO_SRAM_FUCK_SEGA	; oops! SRAM still does no work!
; ===========================================================================

; ---------------------------------------------------------------------------
; Title	screen
; ---------------------------------------------------------------------------

TitleScreen:
		moveq	#$FFFFFFE0,d0
		bsr.w	PlaySound	; fade out music
		bsr.w	Pal_FadeFrom
		bsr.w	ClearPLC

		sf	d6

TitleScreen_skip:
		lea	(VDP_control_port).l,a6
		move.w	#$8004,(a6)			; Command $8004 - Disable HInt, HV Counter
		move.w	#$8230,(a6)			; Command $8230 - Nametable A at $C000
		move.w	#$8407,(a6)			; Command $8407 - Nametable B at $E000
		move.w	#$9001,(a6)			; Command $9001 - 64x32 cell nametable area
		move.w	#$9200,(a6)			; Command $9200 - Window V position at default
		move.w	#$8B03,(a6)			; Command $8B03 - Vscroll full, HScroll line-based
		move.w	#$8700,(a6)			; Command $8700 - BG color is Pal 0 Color 0
		sf	($FFFFF64E).w
		move.l	#-1,Water_Array.w
		bsr	ClearScreen
		bsr	ClrObjRAM

		lea	($FFFFF628).w,a1
		moveq	#0,d0
		move.w	#$15,d1

.clr:		move.l	d0,(a1)+
		dbf	d1,.clr ; clear misc variables

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1

.clr2:		move.l	d0,(a1)+
		dbf	d1,.clr2 ; clear misc variables

		tst.b	d6
		bmi.s	.skp

		lea	Palette_NTarget.w,a1
		moveq	#0,d0
		move.w	#$1F,d1

.ClrPallet	move.l	d0,(a1)+
		dbf	d1,.ClrPallet ; fill pallet with 0	(black)

.skp		sf	($FFFFFE30).w 	; clear lamppost counter
		sf	$FFFFFE08.w	; disable debug item placement	mode
		move.w	#0,($FFFFFFF0).w ; disable debug mode
		move.w	#0,($FFFFFFEA).w
		move.w	#0,($FFFFFE10).w ; set level to	GHZ (00)
		move.w	#0,($FFFFF634).w ; disable pallet cycling
		move.w	#$167,($FFFFF614).w ; run title	screen for $178	frames

		clr.w	DMA_Buffer_Start.w			; clear start of the DMA queue
		move.l	#DMA_Buffer_Start,DMA_Buffer_End.w	; reset address pointer of DMA queue

		lea	(ArtKos_S3TitleSonic1).l,a2	;S3DATA
		lea	$FF0000,a1
		bsr.w	Compdec
		move.w	a2,d3
		lsr.w	#1,d3
		move.l	#$FF0000,d1
		move.w	#0,d2
		jsr	QueueDMATransfer		; DMA Sega logo+Sonic art data 1 to $0 in VRAM

		move.b	#8,VBlank_Routine.w	; WHY THIS FUCKER IS NEEDED?
		bsr.w	DelayProgram

		lea	$FFFFAA00.w,a1
		lea	(MapEni_S3TitleSonic1).l,a0	;S3DATA
		move.w	#0,d0
		bsr.w	EniDec			; Decompress Comper Mappings

		lea	$FFFFAA00.w,a1
		move.l	#$40000003,d0
		moveq	#$27,d1
		moveq	#$1B,d2
		jsr	ShowVDPGraphics		; Copy screen mappings to VRAM

		lea	(Pal_TitleSonic1).l,a1
		lea	Palette_NCurr.w,a2
		tst.b	d6
		bmi.s	.ldnorm

		lea	Palette_NTarget.w,a2
.ldnorm		moveq	#7,d0
		bsr	Loc_pal

		move.w	#4,($FFFFF614).w
		move.w	$FFFFF60C.w,d0
		ori.b	#$40,d0
		move.w	d0,(VDP_control_port).l			; Turn the display on

.loop		move.b	#8,VBlank_Routine.w
		bsr.w	DelayProgram
		tst.w	($FFFFF614).w
		bne.s	.loop			; loop to load the logo correctly first

		tst.b	d6
		bmi.s	.play

		bsr.w	Pal_FadeTo				; Fade in to logo
.play		moveq	#$FFFFFF80+18,d0
		bsr.w	PlaySample
		move.w	#$B4,($FFFFF614).w		; Set to wait for 3 seconds

Wait_SegaS3K:
		move.b	#8,VBlank_Routine.w
		bsr.w	DelayProgram				; Wait for SEGA sound
		move.b	($FFFFF605).w,d0
		andi.b	#$80,d0
		bne.w	loc_3FE4				; If start was pressed, skip ahead
		tst.w	($FFFFF614).w
		bne.s	Wait_SegaS3K

loc_3FE4:
		moveq	#$FFFFFF80,d0
		bsr.w	PlaySample				; Stop SEGA sound
		jsr	Randomnumber
		lea	Pal_Title,a1

loc_3FF0:
		move.b	#2,VBlank_Routine.w
		bsr.w	DelayProgram
		lea	Palette_Ncurr.w,a2
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+
		tst.w	-$E(a1)					; Wait for BG color to turn to black
		bne.s	loc_3FF0

		move.b	#-1,Title_FlipAniMask.w
		move.b	#0,Title_FrameCount-1.w
		move.w	#1,Title_FrameCount.w		; Set initial variables for Sonic animation page flipping
		moveq	#1,d0
		bsr.w	TitleSonic_LoadFrame
		move.w	#$384,($FFFFF614).w		; Set to wait 15 seconds (900 frames in NTSC)


;		lea	(ArtKos_S3TitleSonic8).l,a1
;		lea	(RAM_start).l,a2
;		jsr	(Queue_Kos).l				; Queue frame 8 of data into a2 since frame 1 is already in VRAM
		moveq	#Music_TitleScreen,d0
		bsr.w	PlayMusic				; Start playing the title screen music

Wait_TitleS3K:
		move.b	#$1A,VBlank_Routine.w
		bsr.w	DelayProgram
		bsr.w	Iterate_TitleSonicFrame
	;	jsr	ObjectsLoad
	;	jsr	BuildSprites

		move.b	($FFFFF605).w,d0
		andi.b	#$80,d0
		bne.w	loc_4090			; If start was pressed, skip straight to title
		cmpi.w	#$C,Title_FrameCount.w
		blo.s	Wait_TitleS3K			; If last frame was reached, don't repeat

loc_4090:
		move.w	#$C,Title_FrameCount.w
		lea	Palette_Ncurr.w,a1
		moveq	#$1F,d1

loc_409C:
		move.l	#$EEE0EEE,(a1)+
		dbf	d1,loc_409C				; Flash palette white

		move.b	#3,Title_FrameCount-1.w
		move.b	#$1A,VBlank_Routine.w
		bsr.w	DelayProgram

		lea	(ArtKos_S3TitleSonicD).l,a2	;S3DATA
		lea	$FF0000,a1
		bsr.w	compdec
		move.w	a1,d3
		lsr.w	#1,d3
		move.l	#$FFFF0000,d1
		move.w	#0,d2
		andi.l	#$FFFFFF,d1
		jsr	QueueDMATransfer		; Load Sonic art frame 14

		lea	$FFFFAA00,a1
		lea	(MapEni_S3TitleSonicD).l,a0
		move.w	#$8000,d0
		bsr.w	EniDec

		lea	$FFFFAA00.w,a1
		move.l	#$40000003,d0
		moveq	#$27,d1
		moveq	#$1B,d2
		jsr	ShowVDPGraphics		; Load Sonic mapping frame 14 to $C000 VRAM

		lea	$FFFFAA00.w,a1
		lea	(MapEni_S3TitleBg).l,a0
		move.w	#$4000,d0
		bsr.w	EniDec

		lea	$FFFFAA00.w,a1
		move.l	#$60000003,d0
		moveq	#$27,d1
		moveq	#$1B,d2
		jsr	ShowVDPGraphics		; Load S3K Title BG to $E000 VRAM

		move.b	#8,VBlank_Routine.w
		bsr.w	DelayProgram
		lea	Pal_TitleSonicD,a0		; Title palette
		lea	Palette_NTarget.w,a1
		moveq	#$1F,d0

loc_4140:
		move.l	(a0)+,(a1)+
		dbf	d0,loc_4140

 		move.l	#$60000002,(VDP_control_port).l	; to VRAM $A000
		lea	(ArtNem_Title_S3Banner).l,a0
		bsr.w	NemDec
		move.l	#$50000003,(VDP_control_port).l	; to VRAM $D000
		lea	(ArtNem_TitleScreenText).l,a0
		bsr.w	NemDec
		move.l	#$40000002,(VDP_control_port).l	; to VRAM $8000
		lea	(ArtNem_Title_SonicSprites).l,a0
		bsr.w	NemDec
		move.l	#$58000002,(VDP_control_port).l	; to VRAM $9800
		lea	(ArtNem_Title_ANDKnuckles).l,a0
		bsr.w	NemDec

		bsr	ClrObjRAM
		lea	$FFFFAC00.w,a0
		move.l	#(($FFFFB000-$FFFFAC00)/4)-1,d0
		moveq	#0,d1

.clr		move.l	d1,(a0)+
		dbf	d0,.clr

		lea	($FFFFF800).w,a1
		move.w	#$A0,d0

.loop		move.l	d1,(a1)+
		dbf	d0,.loop

		lea	Object_RAM.w,a0
		move.b	#$93,(a0)
		move.b	#$94,Next_Obj*1(a0)
		move.b	#$95,Next_Obj*2(a0)
		move.b	#$96,Next_Obj*3(a0)
		move.b	#$97,Next_Obj*4(a0)
		move.b	#$98,Next_Obj*5(a0)
		move.b	#$99,Next_Obj*6(a0)		; Load all applicable title objects
		sf	Title_FrameCount-1.w
		move.w	#$EEE,Palette_NTarget+2.w	; <- no idea why this fix is necessary

		moveq	#0,d0
		bsr.w	LoadPLC

loc_41D4:
		move.b	#$1A,VBlank_Routine.w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
	;	bsr.w	DeformBgLayer
		jsr	BuildSprites
		bsr.w	RunPLC_RAM
		cmpi.b	#4,Object_RAM+Routine.w
		bne.s	loc_41D4			; Don't do anything at all until banner has finished moving
		tst.w	($FFFFF614).w
		beq	loc_4278			; If the timer has run out, go do the level demos
		move.b	($FFFFF605).w,d0
		or.b	($FFFFF607).w,d0
		andi.b	#$80,d0
		beq	loc_41D4			; Repeat until start has been pressed on either controller

		move.b	Title_screen_option.w,d0	; Selection is stored here.
		beq	PlayLevel_SRAM			; normal level
		subq.b	#2,d0
		bpl	LevelSelect_S3			; Sonic 3 level select
		; second option
		andi.b	#$70,$FFFFF604.w
		beq.s	.play

	if Cheats=1
		st	Debug_Mode.w
	endif
		move.l	Bought_Items.w,d6
		bset	#Bought_LevSel,d6
		move.l	d6,Bought_Items.w

.play		moveq	#$FFFFFF80+$19,d0
		bsr	PlaySound
		bra	loc_41D4

loc_4278	bsr.w	Pal_FadeFrom
		moveq	#18,d0
		bsr.s	.loop

		moveq	#$FFFFFF9C,d0
		bsr	PlaySample

		moveq	#60,d0

.loop		addq.b	#2,VBlank_Routine.w
		bsr.w	DelayProgram
		dbf	d0,.loop

		rts
		jmp	YourEmuSucks

PlayLevel_SRAM:
	SRAMEnable
		lea	SRAM_Start,a0
		movep.w	SRAM_LastLVL(a0),d0
		move.w	d0,$FFFFFE10.w

PlayLevel:				; XREF: ROM:00003246j ...
		move.b	#$C,($FFFFF600).w ; set	screen mode to $0C (level)
		moveq	#0,d0
		move.w	d0,($FFFFFE20).w ; clear rings
		move.l	d0,($FFFFFE22).w ; clear time
		move.l	d0,($FFFFFE26).w ; clear score
		move.b	d0,($FFFFFE16).w ; clear special stage number
		move.b	d0,($FFFFFE18).w ; clear continues
	SRAMDisable

		cmp.b	#2,Music_RequestTypes.w
		beq.w	Pal_FadeFrom
		moveq	#$FFFFFFE0,d0
		bsr.w	PlaySound	; fade out music
		bra.w	Pal_FadeFrom

	include 's3l/main.asm'

; ===========================================================================
TitleBanner:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	.Index(pc,d0.w),d1
		jmp	.Index(pc,d1.w)
; ===========================================================================
.Index:	dc.w .Init-.Index, .Main-.Index, TitleBanner_Display-.Index
; ===========================================================================

.Init		move.l	#Map_S3TitleBanner,Mappings_Offset(a0)
		move.w	#$E500,Art_Tile(a0)		; Origin at $A000
		move.w	#1,Priority(a0)
		move.b	#$80,X_Radius(a0)
		move.b	#$40,Y_Radius(a0)
		move.w	#$120,x_pos(a0)
		move.w	#$F0,X_pos2(a0)
		move.w	#$400,y_vel(a0)
		move.l	#$FFA00000,Off30(a0)
		addq.b	#2,Routine(a0)
	;	move.b	#4,Render_Flags(a0)

.Main		move.b	Off34(a0),d2
		move.w	y_vel(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,Off30(a0)
		move.w	Off30(a0),d0
		move.b	#0,Off34(a0)
		move.w	#$40,d1
		cmpi.w	#0,d0
		blt.s	loc_48B4
		bne.s	loc_48AA
		cmpi.w	#$FFA5,y_vel(a0)
		bne.s	loc_48AA
		addq.b	#2,Routine(a0)
;		move.l	#Obj_TitleTM,(Reserved_object_3).w
		bra.s	loc_48C2
; ---------------------------------------------------------------------------

loc_48AA:
		move.b	#$FF,Off34(a0)
		move.w	#$FFC0,d1

loc_48B4:
		add.w	d1,y_vel(a0)
		cmp.b	Off34(a0),d2
		beq.s	loc_48C2
		asr	y_vel(a0)

loc_48C2:
		move.w	Off30(a0),d0
		neg.w	d0
		addi.w	#$D4,d0
		move.w	d0,X_pos2(a0)
		cmpi.w	#$10,$FFFFF616.w		; Raise title screen Y position to make room for the &KNUCKLES
		beq.s	TitleBanner_Display
		addq.w	#1,$FFFFF616.w

TitleBanner_Display:
		subq.b	#1,Anim_Dur(a0)
		bpl.s	loc_48F2
		move.b	#9,Anim_Dur(a0)
		addq.b	#4,Anim_scriptNum(a0)
		andi.b	#$1C,Anim_scriptNum(a0)

loc_48F2:
		moveq	#0,d0
		move.b	Anim_scriptNum(a0),d0
		move.l	Pal_TitleWaterRot(pc,d0.w),(Palette_NTarget+(2*$20)+$1A).w
		jmp	displaysprite

; ===========================================================================
Pal_TitleWaterRot:	incbin 's3k/Palettes/S3 Water Anim.bin'
	even
; ===========================================================================

TitleSelection:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	.Index(pc,d0.w),d1
		jmp	.Index(pc,d1.w)
; ===========================================================================
.Index:	dc.w .Init-.Index,.Main-.Index


.Init		move.w	#$F0,x_pos(a0)
		move.w	#$140,x_pos2(a0)
		move.l	#Map_TitleScreenText,Mappings_Offset(a0)
		move.w	#$C680,Art_Tile(a0)		; Start at $D000 VRAM
		andi.b	#1,Title_screen_option.w
		move.b	Title_screen_option.w,Anim_Frame(a0)
		addq.b	#2,Routine(a0)

.Main		moveq	#0,d2
		move.b	Title_screen_option.w,d2
		move.b	$FFFFF605,d0
		or.b	$FFFFF607,d0
		btst	#0,d0
		beq.s	loc_4AAE
		subq.b	#1,d2
		bhs.s	loc_4AAE
		move.b	#2,d2
		buyTest	Bought_LevSel
		bne.s	loc_4AAE
		move.b	#1,d2
loc_4AAE:

		btst	#1,d0
		beq.s	loc_4AC8
		addq.b	#1,d2
		buytest	Bought_LevSel
		bne.s	loc_4AC0
		andi.b	#1,d2

loc_4AC0:
		cmpi.b	#3,d2
		blo.s	loc_4AC8
		moveq	#0,d2

loc_4AC8:

		move.b	d2,Anim_Frame(a0)
		move.b	d2,Title_screen_option.w
		andi.b	#3,d0
		beq.s	loc_4ADE
		moveq	#$FFFFFFCD,d0
		jsr	PlaySound		; Only play sound if selection was changed

loc_4ADE:
		jmp	DisplaySprite


TitleCopyRight:
		move.l	#Map_TitleScreenText,Mappings_Offset(a0)
		move.w	#$E680,Art_Tile(a0)		; Start at $D000 VRAM
		move.w	#$158,x_pos(a0)
		move.w	#$14C,x_pos2(a0)
		move.w	#1,Priority(a0)
		move.b	#$C,X_Radius(a0)
		move.b	#4,Y_Radius(a0)
		move.b	#3,Anim_Frame(a0)
		jmp	DisplaySprite

TitleSonicFinger:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	.Index(pc,d0.w),d1
		jmp	.Index(pc,d1.w)
; ===========================================================================
.Index:	dc.w .Init-.Index,.Display-.Index


.Init		move.l	#Map_TitleSonicAnim,Mappings_Offset(a0)
		move.w	#$A400,Art_Tile(a0)		; Start at $8000 VRAM
		move.w	#$148,x_pos(a0)
		move.w	#$DC,x_pos2(a0)
		move.w	#$180,Priority(a0)
		move.b	#$18,x_radius(a0)
		move.b	#$1C,y_radius(a0)
		addq.b	#2,Routine(a0)

.Display	move.w	#$DC,d0
		sub.w	$FFFFF616.w,d0
		move.w	d0,x_pos2(a0)
		lea	Ani_TitleSonicFinger,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ---------------------------------------------------------------------------
Ani_TitleSonicFinger:	include 's3k/Anim - S3 Sonic Finger.asm'


TitleSonicWink:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	.Index(pc,d0.w),d1
		jmp	.Index(pc,d1.w)
; ===========================================================================
.Index:	dc.w .Init-.Index,.Display-.Index


.Init		move.l	#Map_TitleSonicAnim,Mappings_Offset(a0)
		move.w	#$A400,Art_Tile(a0)		; Start at $8000 VRAM
		move.w	#$F8,x_pos(a0)
		move.w	#$C8,x_pos2(a0)
		move.w	#$180,Priority(a0)
		move.b	#$10,x_radius(a0)
		move.b	#$18,y_radius(a0)
		addq.b	#2,Routine(a0)

.Display	move.w	#$C8,d0
		sub.w	$FFFFF616.w,d0
		move.w	d0,x_pos2(a0)
		lea	Ani_TitleSonicWink,a1
		jsr	AnimateSprite_special
		jmp	DisplaySprite
; ---------------------------------------------------------------------------
Ani_TitleSonicWink:	include 's3k/Anim - S3 Sonic Wink.asm'

AnimateSprite_special:
		moveq	#0,d0
		move.b	Anim(a0),d0
		cmp.b	Anim_Restart(a0),d0
		beq.s	_1ACA0
		move.b	d0,Anim_Restart(a0)
		sf	Anim_scriptNum(a0)
		sf	Anim_Dur(a0)

_1ACA0:
		subq.b	#1,Anim_Dur(a0)
		bhs.s	locret_1ACDA
		add.w	d0,d0
		adda.w	(a1,d0.w),a1
		moveq	#0,d1
		move.b	Anim_scriptNum(a0),d1
		add.w	d1,d1
		move.b	(a1,d1.w),d0
		bmi.s	loc_1ACDC

loc_1ACBA:
		move.b	1(a1,d1.w),Anim_Dur(a0)
		move.b	d0,Anim_Frame(a0)
		move.b	Status(a0),d1
		andi.b	#3,d1
		andi.b	#-4,Render_Flags(a0)
		or.b	d1,Render_Flags(a0)
		addq.b	#1,Anim_scriptNum(a0)

locret_1ACDA:
		rts
; ---------------------------------------------------------------------------

loc_1ACDC:
		addq.b	#1,d0
		bne.s	loc_1ACEA
		moveq	#0,d1
		move.b	d1,Anim_scriptNum(a0)
		move.b	(a1),d0
		bra.s	loc_1ACBA
; ---------------------------------------------------------------------------

loc_1ACEA:
		addq.b	#1,d0
		bne.s	loc_1AD00
		move.b	1(a1,d1.w),d0
		sub.b	d0,Anim_scriptNum(a0)
		add.w	d0,d0
		sub.b	d0,d1
		move.b	(a1,d1.w),d0
		bra.s	loc_1ACBA
; ---------------------------------------------------------------------------

loc_1AD00:
		addq.b	#1,d0
		bne.s	loc_1AD0C
		move.b	1(a1,d1.w),Anim(a0)
		rts
; ---------------------------------------------------------------------------

loc_1AD0C:
		addq.b	#1,d0
		bne.s	locret_1AD1E
		addq.b	#2,5(a0)
		sf	Anim_Dur(a0)
		addq.b	#1,Anim_scriptNum(a0)
		rts
; ---------------------------------------------------------------------------

locret_1AD1E:
		rts

TitleTailsPlane:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	.Index(pc,d0.w),d1
		jmp	.Index(pc,d1.w)
; ===========================================================================
.Index:	dc.w .Init-.Index,.Main-.Index

.Init		move.l	#Map_TitleTailsPlane,Mappings_Offset(a0)
		move.w	#$6400,Art_Tile(a0)		; Start at $8000 VRAM
		move.w	#0,x_pos(a0)
		move.w	#$C0,x_pos2(a0)
		move.w	#$380,Priority(a0)
		move.b	#$18,X_radius(a0)
		move.b	#8,Y_radius(a0)
		addq.b	#2,Routine(a0)

.Main		tst.b	Off30(a0)
		bne.s	loc_4C0A
		addq.w	#1,x_pos(a0)
		cmpi.w	#$240,x_pos(a0)
		bne.s	loc_4C08
		move.b	#1,Off30(a0)
		bset	#0,status(a0)
		move.w	#$D0,y_pos(a0)

loc_4C08:
		bra.s	loc_4C28
; ---------------------------------------------------------------------------

loc_4C0A:
		subq.w	#1,x_pos(a0)
		cmpi.w	#0,x_pos(a0)
		bne.s	loc_4C28
		move.b	#0,Off30(a0)
		bclr	#0,status(a0)
		move.w	#$C0,y_pos(a0)

loc_4C28:
		lea	Ani_TitleTailsPlane,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ---------------------------------------------------------------------------
Ani_TitleTailsPlane:	include 's3k/Anim - S3 Tails Plane.asm'

TitleANDKnuckles:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	.Index(pc,d0.w),d1
		jmp	.Index(pc,d1.w)
; ===========================================================================
.Index:	dc.w .Init-.Index,.Display-.Index


.Init		move.l	#Map_TitleANDKnuckles,Mappings_Offset(a0)
		move.w	#$E4C0,Art_Tile(a0)		; Start at $9800
		move.w	#$120,x_pos(a0)
		move.w	#$108,x_pos2(a0)
		move.w	#$80,Priority(a0)
		move.b	#$54,x_radius(a0)
		move.b	#$C,y_radius(a0)
		addq.b	#2,Routine(a0)

.Display	move.w	Object_RAM+x_pos2.w,d0
		addi.w	#$5C,d0
		move.w	d0,x_pos2(a0)
		jmp	DisplaySprite
; ---------------------------------------------------------------------------
Map_TitleANDKnuckles:	include 's3k/Map - S3 ANDKnuckles.asm'
Map_TitleScreenText:	include 's3k/Map - S3 Screen Text.asm'
Map_TitleSonicAnim:	include 's3k/Map - S3 Sonic Anim.asm'
Map_TitleTailsPlane:	include 's3k/Map - S3 Tails Plane.asm'
Map_S3TitleBanner:	include 's3k/Map - S3 Banner.asm'


Iterate_TitleSonicFrame:
		cmpi.b	#1,Title_FrameCount-1.w
		bne.s	locret_43F0
		move.w	Title_FrameCount.w,d0
		move.b	SonicFrameIndex(pc,d0.w),d0
		ext.w	d0
		bmi.s	loc_43F2
		bsr.w	TitleSonic_LoadFrame
		addq.w	#1,Title_FrameCount.w

locret_43F0:
		rts
; ---------------------------------------------------------------------------

loc_43F2:
		move.w	#$C,Title_FrameCount.w
		move.b	#3,Title_FrameCount-1.w
		rts
; End of function Iterate_TitleSonicFrame

; ---------------------------------------------------------------------------
SonicFrameIndex:	dc.b	1,   2,	  3,   4,   5,	 6,   7,   8,	9,  $A,	 $B, $FF

; =============== S U B R O U T I N E =======================================


TitleSonic_LoadFrame:
		move.w	d0,d7
		add.w	d0,d0
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	(TitleSonic_Frames).l,a3
		lea	(a3,d0.w),a3
		move.w	#$2C60,d3
		move.l	(a3)+,d0				; Art data
	;	cmpi.w	#7,d7
	;	beq.s	loc_4446
	;	blo.s	loc_4466
		andi.l	#$FFFFFF,d0
		movea.l	d0,a2
		lea	$FF0000.l,a1
		movem.l	d1/a3,-(sp)
		bsr.w	Compdec
		movem.l	(sp)+,d1/a3
		move.w	a1,d3
		lsr.w	#1,d3
loc_4446:
		move.l	#$FFFF0000,d1
		move.w	#0,d2
		tst.b	Title_FlipAniMask.w		; FFFFBC toggles on and off so that each animation frame could alternate locations for a sort of makeshift double-buffering
		beq.s	loc_445A
		move.w	#$6000,d2

loc_445A:
		andi.l	#$FFFFFF,d1
		jsr	QueueDMATransfer

loc_4466:
		movea.l	(a3)+,a0			; Palette data address
		lea	Palette_NTarget.w,a1
		moveq	#$F,d0

loc_446E:
		move.l	(a0)+,(a1)+
		dbf	d0,loc_446E
		tst.b	Title_FlipAniMask.w
		bne.s	loc_44B8
		lea	$FFFFAA00,a1			; Buffer 1
		movea.l	(a3)+,a0			; comper Mappings
		move.w	#0,d0
		bsr.w	EniDec

loc_449A:
		move	#$2700,sr
		lea	$FFFFAA00,a1
		move.l	#$40000003,d0			; to $C000 in VRAM, Nametable A
		moveq	#$27,d1
		moveq	#$1B,d2
		jsr	ShowVDPGraphics
		move	#$2300,sr
		rts
; ---------------------------------------------------------------------------

loc_44B8:
		lea	$FFFFAA00,a1			; Buffer 2
		movea.l	(a3)+,a0			; comper Mappings
		move.w	#$300,d0
		cmpi.w	#7,d7
		bhs.s	loc_44CC
		move.w	#0,d0

loc_44CC:
		bsr.w	EniDec

loc_44E2:
		move	#$2700,sr
		lea	$FFFFAA00,a1
		move.l	#$60000003,d0			; to $E000 in VRAM Nametable B
		moveq	#$27,d1
		moveq	#$1B,d2
		jsr	ShowVDPGraphics
		move	#$2300,sr
		rts
; End of function TitleSonic_LoadFrame

; ---------------------------------------------------------------------------
TitleSonic_Frames:dc.l ArtKos_S3TitleSonic1	;S3DATA
		dc.l Pal_TitleSonic1
		dc.l MapEni_S3TitleSonic1				;S3DATA
		dc.l ArtKos_S3TitleSonic1				;S3DATA
		dc.l Pal_TitleSonic2
		dc.l MapEni_S3TitleSonic2				;S3DATA
		dc.l ArtKos_S3TitleSonic1				;S3DATA
		dc.l Pal_TitleSonic3
		dc.l MapEni_S3TitleSonic3				;S3DATA
		dc.l ArtKos_S3TitleSonic1				;S3DATA
		dc.l Pal_TitleSonic4
		dc.l MapEni_S3TitleSonic4				;S3DATA
		dc.l ArtKos_S3TitleSonic1				;S3DATA
		dc.l Pal_TitleSonic5
		dc.l MapEni_S3TitleSonic5				;S3DATA
		dc.l ArtKos_S3TitleSonic1				;S3DATA
		dc.l Pal_TitleSonic6
		dc.l MapEni_S3TitleSonic6				;S3DATA
		dc.l ArtKos_S3TitleSonic1				;S3DATA
		dc.l Pal_TitleSonic7
		dc.l MapEni_S3TitleSonic7				;S3DATA
		dc.l ArtKos_S3TitleSonic8				;S3DATA
		dc.l Pal_TitleSonic8
		dc.l MapEni_S3TitleSonic8				;S3DATA
		dc.l ArtKos_S3TitleSonic9				;S3DATA
		dc.l Pal_TitleSonic9
		dc.l MapEni_S3TitleSonic9				;S3DATA
		dc.l ArtKos_S3TitleSonicA				;S3DATA
		dc.l Pal_TitleSonicA
		dc.l MapEni_S3TitleSonicA				;S3DATA
		dc.l ArtKos_S3TitleSonicB				;S3DATA
		dc.l Pal_TitleSonicB
		dc.l MapEni_S3TitleSonicB				;S3DATA
		dc.l ArtKos_S3TitleSonicC				;S3DATA
		dc.l Pal_TitleSonicC
		dc.l MapEni_S3TitleSonicC				;S3DATA
		dc.l ArtKos_S3TitleSonicD				;S3DATA
		dc.l Pal_TitleSonicD
		dc.l MapEni_S3TitleSonicD				;S3DATA

TitleAnim_FlipBuffer:
		tst.b	Title_FrameCount-1.w
		bne.s	loc_43AC
		move.b	#3,Title_FrameCount-1.w
		cmpi.w	#$C,Title_FrameCount.w
		bhs.s	loc_43B2
		move.b	#4,Title_FrameCount-1.w
		lea	Palette_NTarget.w,a0
		lea	Palette_Ncurr.w,a1
		moveq	#$F,d0

loc_4376:
		move.l	(a0)+,(a1)+
		dbf	d0,loc_4376
		eori.b	#-1,Title_FlipAniMask.w
		tst.b	Title_FlipAniMask.w
		beq.s	loc_439A
		move.w	#$8406,(VDP_control_port).l		; Nametable B Address $C000
		move.w	#$8230,(VDP_control_port).l		; Nametable A Address $C000
		rts
; ---------------------------------------------------------------------------

loc_439A:
		move.w	#$8407,(VDP_control_port).l		; Nametable B Address $E000
		move.w	#$8238,(VDP_control_port).l		; Nametable A Address $E000
		rts
; ---------------------------------------------------------------------------

loc_43AC:
		subq.b	#1,Title_FrameCount-1.w
		rts
; ---------------------------------------------------------------------------

loc_43B2:
		lea	Palette_NTarget.w,a0
		lea	Palette_Ncurr.w,a1
		moveq	#$1F,d0

loc_43BC:
		move.l	(a0)+,(a1)+
		dbf	d0,loc_43BC
		move.w	#$8407,(VDP_control_port).l		; Nametable B Address $E000
		move.w	#$8230,(VDP_control_port).l		; Nametable B Address $C000
		rts
; End of function sub_4352

loc_Pal:
		move.l	(a1)+,(a2)+
		dbf	d0,loc_Pal
		rts

ClrObjRAM:
		lea	Object_RAM,a1
		moveq	#0,d0
		move.w	#$7FF,d1

Title_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,Title_ClrObjRam ; fill object RAM ($D000-$EFFF) with	0
		rts
; ---------------------------------------------------------------------------
; Music	playlist
; ---------------------------------------------------------------------------
MusicListExtra:	dc.b $E4+3, $E4+$B, $E4+$10, $E4+$C, $E4+$18, 0, $E4+5, $E4+$17
MusicList:	dc.b $81, $82, $83, $84, $85, $86, $8D, $E4+$17
MusicListExtraSBZ: dc.b $E4+$17, $E4+8

PlayZoneMusic:
		moveq	#0,d0
	;	bclr	#7,Music_RequestTypes.w	; clear 7th bit of the flag (in case we want to keep the music, make sure will not change)
		tst.b	Music_RequestTypes.w	; check if the music request flag is 0
		bne	.Chk1			; if is not, branch to check other options

		moveq	#6,d0
		cmpi.w	#$502,$FFFFFE10.w
		beq.s	.noFZ

		move.b	$FFFFFE10.w,d0		; get zone id
		cmpi.w	#7,$FFFFFE10.w
		bne.s	.noFZ

		moveq	#$FFFFFFE4+$12,d0
		buytest	Used_AltMusic
		beq.s	.PlayPrev
		moveq	#$FFFFFFE4+$1A,d0
		bra	.PlayPrev

.noFZ		lea	MusicList(pc),a1		; load music playlist
		buytest	Used_AltMusic
		beq.s	.norm2
		lea	MusicListExtra(pc),a1	; load extra music playlist

.norm2		move.b	(a1,d0.w),d0		; get correct id
		bmi.s	.norm
		move.b	$FFFFFE11.w,d0
		lea	MusicListExtraSBZ(pc),a1; load extra music playlist
		move.b	(a1,d0.w),d0		; get correct id

.norm		cmp.b	Music_StorePrevID.w,d0	; check if the id is same as current musid id
		beq	.1			; if is, dont get new music
		move.b	d0,Music_StoreZoneID.w	; if not, put the new music to "Music_StoreZoneID"
		bra	.playprev		; branch to continue with the code

.Chk1		cmpi.b	#1,Music_RequestTypes.w	; if all requests disabled?
		beq	.1			; if are, branch away
		move.b	Music_StoreZoneID.w,d0	; get the music ID we should play
		cmp.b	Music_StorePrevID.w,d0	; check if it's equal with the music we are playing
		beq	.1			; if is, branch away

.PlayPrev	move.b	d0,Music_StorePrevID.w	; if not, store the id
		bra	PlayMusicFade		; and play the music
.1		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Level
; ---------------------------------------------------------------------------

Level:					; XREF: GameModeArray
		bset	#7,($FFFFF600).w	; add $80 to screen mode (for pre level sequence)
		move.b	#8,DefaultVBIRoutine

	SRAMEnable
		lea	SRAM_Start,a2
		move.b	Current_Character.w,SRAM_Char(a2); move character id to SRAM
		move.w	$FFFFFE10.w,d0
		movep.w	d0,SRAM_LastLVL(a2)		; move the level id to last level been at
		move.b	$FFFFFE12.w,SRAM_Lives(a2)	; move lives amount to SRAM
		move.l	DCL_Rings.w,d0
		movep.l	d0,SRAM_Rings(a2)
		move.l	Bought_Items.w,d0
		movep.l	d0,SRAM_Items(a2)

	SRAMDisable
		moveq	#$FFFFFFE3,d0			; slow down id
		bsr	PlaySound			; slow the music down

; this part makes sure no sound is played wrongly when entering a level
.music		jsr	PlayZoneMusic

.1		cmpi.w	#7,$FFFFFE10.w
		beq.s	.cl
		jsr	DLCScreen		; first go check DLC
.cl		bsr	GetCorrectColl

		bsr.w	ClearPLC
		bsr.w	Pal_FadeFrom
		tst.w	($FFFFFFF0).w
		bmi.s	Level_ClrRam
		cmpi.w	#7,$FFFFFE10.w
		bne.s	.norm
		move.l	#0,Turbomode_flag.w
		move.w	#0,Turbomode_flag+4.w
		move.w	#0,$FFFFF700.w

		moveq	#$17,d0
		bsr.w	LoadPLC		; load level patterns
		bra.s	Level_ClrRam

.norm		moveq	#0,d0
		move.b	$FFFFFE10,d0
		lsl.w	#2,d0
		addi.w	#Misc_PLC,d0
		beq.s	loc_37FC
		bsr.w	LoadPLC		; load level patterns

loc_37FC:
		moveq	#1,d0
		bsr.w	LoadPLC		; load standard	patterns

	     	moveq	#0,d0
		move.b	Current_Character,d0	; get char
		addi.w	#13,d0			; add 14
		jsr	LoadPLC			; load the PLC

Level_ClrRam:
		bsr	ClrObjRAM

		lea	($FFFFF628).w,a1
		moveq	#0,d0
		move.b	d0,BossMode.w
		moveq	#$15,d1

Level_ClrVars:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrVars ; clear misc variables

		lea	($FFFFF700).w,a1
		moveq	#$3F,d1

Level_ClrVars2:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrVars2 ; clear misc variables

		lea	($FFFFFE60).w,a1
		moveq	#$47,d1

Level_ClrVars3:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrVars3 ; clear object variables

		move	#$2700,sr
		bsr.w	ClearScreen
		lea	VDP_Control_Port,a6
		move.w	#$8B03,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$857C,(a6)
		move.w	#$9001,(a6)
		move.w	#$8004,(a6)
		move.w	#$8720,(a6)
		move.w	#$8ADF,($FFFFF624).w
		move.w	($FFFFF624).w,(a6)
		clr.w	DMA_Buffer_Start			; clear start of the DMA queue
		move.l	#DMA_Buffer_Start,DMA_Buffer_End	; reset address pointer of DMA queue

		moveq	#0,d0
		move.b	($FFFFFE10).w,d0			; get level id
		lsl.w	#2,d0					; 4x
		move.l	WaterArrayLocs(pc,d0.w),Water_Array.w	; get proper array here

		tst.l	Water_Array.w	; check if has water
		bmi.w	Level_LoadPal	; if not, branch
		move.l	DynWaterOffsets(pc,d0.w),DynWater_Off-2.w	; get proper array here
		bra.s	skipwater

DynWaterOffsets:	dc.l -1,0
WaterArrayLocs:		dc.l -1,.lz,-1,-1,-1,-1,-1,-1
.lz	dc.w $B8, $328, $900, $220, $7FFF, LZ6_Water_UpY


skipwater	move.w	#$8014,(a6)
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		movea.l	Water_Array.w,a1 ; load water height array
		move.w	(a1,d0.w),d0
		move.w	d0,($FFFFF646).w ; set water heights
		move.w	d0,($FFFFF648).w
		move.w	d0,($FFFFF64A).w
		sf	$FFFFF64D.w	; clear	water routine counter
		move.b	#1,$FFFFF64E.w	; clear	water movement
		move.b	#1,$FFFFF64C.w	; enable water
		tst.b	$FFFFFE30.w
		beq.s	Level_LoadPal
		move.b	($FFFFFE53).w,($FFFFF64E).w

Level_LoadPal:
		move.w	#$1E,($FFFFFE14).w
		move	#$2300,sr

		lea	Palette_Ncurr,a2
		lea	Palette_UCurr,a3
		bsr	LoadPlayerPallets
		move.b	#8,Level_VBIRoutine.w

Level_GetBgm:
		cmpi.w	#7,$FFFFFE10.w
		bne.s	.1
		move.w	#80,Player_RollHeight.w
		st	Dirty_Flag.w

.loop		move.b	#$C,(VBlank_Routine).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		bsr.w	RunPLC_RAM

		subq.w	#1,Player_RollHeight.w
		bpl.s	.loop
		bra.s	loc_3946

.1		move.b	#$34,Ttlcard_RAM	; load title card object

Level_TtlCard:
		move.b	#$C,(VBlank_Routine).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		bsr.w	RunPLC_RAM
		move.w	($FFFFD108).w,d0
		cmp.w	($FFFFD130).w,d0 ; has title card sequence finished?
		bne.s	Level_TtlCard	; if not, branch
		tst.l	($FFFFF680).w	; are there any	items in the pattern load cue?
		bne.s	Level_TtlCard	; if yes, branch
		jsr	Hud_Base

loc_3946:
		lea	Palette_NTarget,a2	; target pallet
		lea	Palette_UTarget,a3	; target underwater pallet
		bsr	LoadPlayerPallets; load pallets
		bsr.w	LevelSizeLoad
		bsr.w	DeformBgLayer
		bset	#2,($FFFFF754).w
		bsr.w	MainLoadBlockLoad ; load block mappings	and pallets
		bsr.w	LoadTilesFromStart
		bsr.w	ColIndexLoad
		bsr.w	LZWaterEffects

		cmpi.w	#7,$FFFFFE10.w
		beq.s	Level_ChkWater
		move.b	#1,Object_RAM ; load	Sonic object
		move.b	#$21,Hud_RAM	; load HUD object

Level_ChkDebug:
	;	tst.b	($FFFFFFE2).w	; has debug cheat been entered?
	;	beq.s	Level_ChkWater	; if not, branch
	;	btst	#6,($FFFFF604).w ; is A	button pressed?
	;	beq.s	Level_ChkWater	; if not, branch
	;	move.b	#1,Debug_Mode ; enable debug	mode

Level_ChkWater:
		buytest Bought_Shields
		bne.s	.bought
		lea	ArtComp_MonShield,a2		; sparks graphics
		move.l	#$55000003,d6			; VRAM location
		jsr	CompDecToVRAM			; decompress

.bought		move.w	#0,($FFFFF602).w
		move.w	#0,($FFFFF604).w
		tst.l	Water_Array.w	; check if has water
		bmi.s	Level_LoadObj	; if not, branch
		move.b	#$1B,($FFFFD780).w ; load water	surface	object
		move.w	#$60,($FFFFD788).w
		move.b	#$1B,($FFFFD7C0).w
		move.w	#$120,($FFFFD7C8).w

Level_LoadObj:
		jsr	ObjPosLoad
		jsr	ObjectsLoad
		jsr	BuildSprites
		moveq	#0,d0
		tst.b	($FFFFFE30).w	; are you starting from	a lamppost?
		bne.s	loc_39E8	; if yes, branch
		move.w	d0,($FFFFFE20).w ; clear rings
		move.l	d0,($FFFFFE22).w ; clear time
		move.b	d0,($FFFFFE1B).w ; clear lives counter

		cmp.b	#7,$FFFFFE10.w
		bne.s	loc_39E8
		st	Dirty_Flag.w
		move.l	#$12D00,$FFFFFE22.w

loc_39E8:
		move.b	d0,($FFFFFE1A).w

		move.b	d0,($FFFFFE2D).w ; clear invincibility
		move.b	d0,($FFFFFE2E).w ; clear speed shoes
		move.b	d0,($FFFFFE2F).w
		move.b	d0,$FFFFFE08.w
		move.w	d0,($FFFFFE02).w
		move.w	d0,($FFFFFE04).w
		bsr.w	OscillateNumInit
		move.b	#1,($FFFFFE1F).w ; update score	counter
		move.b	#1,($FFFFFE1D).w ; update rings	counter
		move.b	#1,($FFFFFE1E).w ; update time counter
		move.w	#0,($FFFFF790).w
		lea	(Demo_Index).l,a1 ; load demo data
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1

Level_Demo:
		move.b	1(a1),($FFFFF792).w ; load key press duration
		subq.b	#1,($FFFFF792).w ; subtract 1 from duration
		move.w	#1800,($FFFFF614).w
		tst.w	($FFFFFFF0).w
		bpl.s	Level_ChkWaterPal
		move.w	#540,($FFFFF614).w
		cmpi.w	#4,($FFFFFFF4).w
		bne.s	Level_ChkWaterPal
		move.w	#510,($FFFFF614).w

Level_ChkWaterPal:
		tst.l	Water_Array.w	; check if has water
		bmi.s	Level_Delay	; if not, branch
		moveq	#$B,d0		; pallet $0B (LZ underwater)
		bsr.w	PalLoad4_Water

Level_Delay:
		move.w	#3,d1

Level_DelayLoop:
		move.b	#8,(VBlank_Routine).w
		bsr.w	DelayProgram
		dbf	d1,Level_DelayLoop

		move.w	#$202F,($FFFFF626).w
		bsr.w	Pal_FadeTo2
		tst.w	($FFFFFFF0).w
		bmi.s	Level_ClrCardArt
		cmpi.w	#7,$FFFFFE10.w
		beq.s	.lel

		addq.b	#2,Ttlcard_RAM+Routine	; make title card move
		addq.b	#4,Ttlcard_RAM+$40+Routine
		addq.b	#4,Ttlcard_RAM+$80+Routine
		addq.b	#4,Ttlcard_RAM+$C0+routine
		bra.s	Level_StartGame
; ===========================================================================
.lel		move.l	#$3000000,Turbomode_flag.w
		move.w	#0,$FFFFF700.w
		st	Dirty_Flag.w
		bra.s	Level_StartGame

Level_ClrCardArt:
		moveq	#2,d0
		jsr	LoadPLC	; load explosion patterns
		moveq	#0,d0
		move.b	$FFFFFE10,d0
		lsl.w	#2,d0
		addi.w	#Misc_PLC+2,d0
		jsr	LoadPLC	; load animal patterns (level no.*3 + 23)

Level_StartGame:
		bclr	#7,($FFFFF600).w ; subtract 80 from screen mode

; ---------------------------------------------------------------------------
; Main level loop (when	all title card and loading sequences are finished)
; ---------------------------------------------------------------------------

Level_MainLoop:
		bsr.w	PauseGame
		move.b	Level_VBIRoutine.w,VBlank_Routine.w
		bsr.w	DelayProgram
		addq.w	#1,($FFFFFE04).w ; add 1 to level timer
		bsr.s	LZWaterEffects
		jsr	ObjectsLoad
		tst.w	($FFFFFE02).w	; is the level set to restart?
		bne.w	Level		; if yes, branch
		tst.b	$FFFFFE08.w
		bne.s	loc_3B10
		cmpi.b	#6,Object_RAM+Routine
		bhs.s	loc_3B14

loc_3B10:
		bsr.w	DeformBgLayer

loc_3B14:
		jsr	BuildSprites
		jsr	ObjPosLoad
		bsr.w	PalCycle_Load
		bsr.w	RunPLC_RAM
		bsr.w	OscillateNumDo
		bsr.w	ChangeRingFrame
		bsr.w	SignpostArtLoad
		cmpi.b	#$C,($FFFFF600).w
		beq.w	Level_MainLoop	; if screen mode is $0C	(level), branch
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	do special water effects in Labyrinth Zone
; ---------------------------------------------------------------------------

LZWaterEffects:				; XREF: Level
		tst.l	Water_Array.w	; check if has water
		bmi.s	locret_3C28	; if not, branch
		cmpi.b	#6,Object_RAM+Routine.w
		bhs.s	LZMoveWater

		bsr.w	LZWindTunnels
		bsr.w	LZWaterSlides
		bsr.w	LZDynamicWater

LZMoveWater:
		sf	$FFFFF64E.w
		moveq	#0,d0
		move.b	($FFFFFE60).w,d0
		lsr.w	#1,d0
		add.w	($FFFFF648).w,d0
		move.w	d0,($FFFFF646).w
		move.w	($FFFFF646).w,d0
		sub.w	($FFFFF704).w,d0
		bhs.s	loc_3C1A
		tst.w	d0
		bpl.s	loc_3C1A
		move.b	#-$21,($FFFFF625).w
		st	$FFFFF64E.w

loc_3C1A:
		cmpi.w	#$DF,d0
		blo.s	loc_3C24
		move.w	#$DF,d0

loc_3C24:
		move.b	d0,($FFFFF625).w

locret_3C28:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Labyrinth dynamic water routines
; ---------------------------------------------------------------------------

LZDynamicWater:				; XREF: LZWaterEffects
		lea	dyn_lz(pc),a1
		add.w	DynWater_Off.w,a1
		jsr	(a1)
		moveq	#0,d1
		move.b	($FFFFF64C).w,d1
		move.w	($FFFFF64A).w,d0
		sub.w	($FFFFF648).w,d0
		beq.s	locret_3C5A
		bhs.s	loc_3C56
		neg.w	d1

loc_3C56:
		add.w	d1,($FFFFF648).w

locret_3C5A:
		rts

dyn_lz:
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	DynWater_Index(pc,d0.w),d0
		jmp	DynWater_Index(pc,d0.w)
; ===========================================================================
DynWater_Index:	dc.w DynWater_LZ1-DynWater_Index
		dc.w DynWater_LZ2-DynWater_Index
		dc.w DynWater_LZ3-DynWater_Index
		dc.w DynWater_SBZ3-DynWater_Index
		dc.w locret_3C5A-DynWater_Index
		dc.w locret_3C5A-DynWater_Index	; LZ6
; ===========================================================================

DynWater_LZ1:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.b	($FFFFF64D).w,d2
		bne.s	loc_3CD0
		move.w	#$B8,d1
		cmpi.w	#$600,d0
		blo.s	loc_3CB4
		move.w	#$108,d1
		cmpi.w	#$200,($FFFFD00C).w
		blo.s	loc_3CBA
		cmpi.w	#$C00,d0
		blo.s	loc_3CB4
		move.w	#$318,d1
		cmpi.w	#$1080,d0
		blo.s	loc_3CB4
		move.b	#-$80,($FFFFF7E5).w
		move.w	#$5C8,d1
		cmpi.w	#$1380,d0
		blo.s	loc_3CB4
		move.w	#$3A8,d1
		cmp.w	($FFFFF648).w,d1
		bne.s	loc_3CB4
		move.b	#1,($FFFFF64D).w

loc_3CB4:
		move.w	d1,($FFFFF64A).w
		rts
; ===========================================================================

loc_3CBA:				; XREF: DynWater_LZ1
		cmpi.w	#$C80,d0
		blo.s	loc_3CB4
		move.w	#$E8,d1
		cmpi.w	#$1500,d0
		blo.s	loc_3CB4
		move.w	#$108,d1
		bra.s	loc_3CB4
; ===========================================================================

loc_3CD0:				; XREF: DynWater_LZ1
		subq.b	#1,d2
		bne.s	locret_3CF4
		cmpi.w	#$2E0,($FFFFD00C).w
		bhs.s	locret_3CF4
		move.w	#$3A8,d1
		cmpi.w	#$1300,d0
		blo.s	loc_3CF0
		move.w	#$108,d1
		move.b	#2,($FFFFF64D).w

loc_3CF0:
		move.w	d1,($FFFFF64A).w

locret_3CF4:
		rts
; ===========================================================================

DynWater_LZ2:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.w	#$328,d1
		cmpi.w	#$500,d0
		blo.s	loc_3D12
		move.w	#$3C8,d1
		cmpi.w	#$B00,d0
		blo.s	loc_3D12
		move.w	#$428,d1

loc_3D12:
		move.w	d1,($FFFFF64A).w
		rts
; ===========================================================================

DynWater_LZ3:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.b	($FFFFF64D).w,d2
		bne.s	loc_3D5E
		move.w	#$900,d1
		cmpi.w	#$600,d0
		blo.s	loc_3D54
		cmpi.w	#$3C0,($FFFFD00C).w
		blo.s	loc_3D54
		cmpi.w	#$600,($FFFFD00C).w
		bhs.s	loc_3D54
		move.w	#$4C8,d1
		move.l	#Level_LZ3,Layout_Data.w
		move.b	#1,($FFFFF64D).w
		move.w	#$B7,d0
		bsr.w	PlaySound ; play sound $B7 (rumbling)

loc_3D54:
		move.w	d1,($FFFFF64A).w
		move.w	d1,($FFFFF648).w
		rts
; ===========================================================================

loc_3D5E:				; XREF: DynWater_LZ3
		subq.b	#1,d2
		bne.s	loc_3DA8
		move.w	#$4C8,d1
		cmpi.w	#$770,d0
		blo.s	loc_3DA2
		move.w	#$308,d1
		cmpi.w	#$1400,d0
		blo.s	loc_3DA2
		cmpi.w	#$508,($FFFFF64A).w
		beq.s	loc_3D8E
		cmpi.w	#$600,($FFFFD00C).w
		bhs.s	loc_3D8E
		cmpi.w	#$280,($FFFFD00C).w
		bhs.s	loc_3DA2

loc_3D8E:
		move.w	#$508,d1
		move.w	d1,($FFFFF648).w
		cmpi.w	#$1770,d0
		blo.s	loc_3DA2
		move.b	#2,($FFFFF64D).w

loc_3DA2:
		move.w	d1,($FFFFF64A).w
		rts
; ===========================================================================

loc_3DA8:
		subq.b	#1,d2
		bne.s	loc_3DD2
		move.w	#$508,d1
		cmpi.w	#$1860,d0
		blo.s	loc_3DCC
		move.w	#$188,d1
		cmpi.w	#$1AF0,d0
		bhs.s	loc_3DC6
		cmp.w	($FFFFF648).w,d1
		bne.s	loc_3DCC

loc_3DC6:
		move.b	#3,($FFFFF64D).w

loc_3DCC:
		move.w	d1,($FFFFF64A).w
		rts
; ===========================================================================

loc_3DD2:
		subq.b	#1,d2
		bne.s	loc_3E0E
		move.w	#$188,d1
		cmpi.w	#$1AF0,d0
		blo.s	loc_3E04
		move.w	#$900,d1
		cmpi.w	#$1BC0,d0
		blo.s	loc_3E04
		move.b	#4,($FFFFF64D).w
		move.w	#$608,($FFFFF64A).w
		move.w	#$7C0,($FFFFF648).w
		move.b	#1,($FFFFF7E8).w
		rts
; ===========================================================================

loc_3E04:
		move.w	d1,($FFFFF64A).w
		move.w	d1,($FFFFF648).w
		rts
; ===========================================================================

loc_3E0E:
		cmpi.w	#$1E00,d0
		blo.s	locret_3E1A
		move.w	#$128,($FFFFF64A).w

locret_3E1A:
		rts
; ===========================================================================

DynWater_SBZ3:				; XREF: DynWater_Index
		move.w	#$228,d1
		cmpi.w	#$F00,($FFFFF700).w
		blo.s	loc_3E2C
		move.w	#$4C8,d1

loc_3E2C:
		move.w	d1,($FFFFF64A).w

dyn_ghz:
dyn_slz:	rts

; ---------------------------------------------------------------------------
LZWindTunnels:				; XREF: LZWaterEffects
		tst.b	$FFFFFE08.w	; is debug mode	being used?
		bne.w	locret_3F0A	; if yes, branch
		lea	(LZWind_Data).l,a2
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		lsl.w	#3,d0
		adda.w	d0,a2
		moveq	#0,d1
		tst.b	($FFFFFE11).w
		bne.s	loc_3E56
		moveq	#1,d1
		subq.w	#8,a2

loc_3E56:
		lea	($FFFFD000).w,a1

LZWind_Loop:
		move.w	X_Pos(a1),d0
		cmp.w	(a2),d0
		blo.w	loc_3EF4
		cmp.w	4(a2),d0
		bhs.w	loc_3EF4
		move.w	Y_Pos(a1),d2
		cmp.w	2(a2),d2
		blo.s	loc_3EF4
		cmp.w	6(a2),d2
		bhs.s	loc_3EF4
		move.b	($FFFFFE0F).w,d0
		andi.b	#$3F,d0
		bne.s	loc_3E90
		move.w	#$D0,d0
		jsr	PlaySound ;	play rushing water sound

loc_3E90:
		tst.b	($FFFFF7C9).w
		bne.w	locret_3F0A
		cmpi.b	#4,Routine(a1)
		bhs.s	loc_3F06
		move.b	#1,($FFFFF7C7).w
		subi.w	#$80,d0
		cmp.w	(a2),d0
		bhs.s	LZWind_Move
		moveq	#2,d0
		cmpi.b	#1,($FFFFFE11).w
		bne.s	loc_3EBA
		neg.w	d0

loc_3EBA:
		add.w	d0,Y_Pos(a1)

LZWind_Move:
		addq.w	#4,X_Pos(a1)
		move.w	#$400,X_Vel(a1)	; move Sonic horizontally
		move.w	#0,Y_Vel(a1)
		bset	#1,Status(a1)

		moveq	#$F,d0
		jsr	K_Glide_HitObj

		btst	#0,($FFFFF602).w ; is up pressed?
		beq.s	LZWind_MoveDown	; if not, branch
		subq.w	#1,Y_Pos(a1)	; move Sonic up

LZWind_MoveDown:
		btst	#1,($FFFFF602).w ; is down being pressed?
		beq.s	locret_3EF2	; if not, branch
		addq.w	#1,Y_Pos(a1)	; move Sonic down

locret_3EF2:
		rts
; ===========================================================================

loc_3EF4:				; XREF: LZWindTunnels
		addq.w	#8,a2
		dbf	d1,LZWind_Loop
		tst.b	($FFFFF7C7).w
		beq.s	locret_3F0A
		moveq	#0,d0
		jsr	K_Glide_HitObj

loc_3F06:
		sf	($FFFFF7C7).w

locret_3F0A:
		rts
; End of function LZWindTunnels

; ===========================================================================
		dc.w $A80, $300, $C10, $380
LZWind_Data:	dc.w $F80, $100, $1410,	$180, $460, $400, $710,	$480, $A20
		dc.w $600, $1610, $6E0,	$C80, $600, $13D0, $680
		dc.w $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF
					; XREF: LZWindTunnels
		even

; ---------------------------------------------------------------------------
; Labyrinth Zone water slide subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LZWaterSlides:				; XREF: LZWaterEffects
		lea	Object_RAM,a1
		btst	#1,Status(a1)
		bne.s	loc_3F6A
		move.w	Y_Pos(a1),d0				; MJ: Load Y position
		move.w	X_Pos(a1),d1				; MJ: Load X position
		and.w	#$0780,d0				; MJ: keep Y position within 800 pixels (in multiples of 80)
		lsl.w	#$01,d0					; MJ: multiply by 2 (Because every 80 bytes switch from FG to BG..)
		lsr.w	#$07,d1					; MJ: divide X position by 80 (00 = 0, 80 = 1, etc)
		and.b	#$7F,d1					; MJ: keep within 4000 pixels (4000 / 80 = 80)
		add.w	d1,d0					; MJ: add together
		movea.l	Layout_Data.w,a2			; MJ: Load address of layout
		move.b	(a2,d0.w),d0				; MJ: collect correct chunk ID based on the position of Sonic
		lea	Slide_Chunks(pc),a2
		moveq	#$00,d1					; MJ: clear d2
		bra	LZLoadChunk				; MJ: continue

LZFindChunk:
		cmp.b	d2,d0					; MJ: does the chunk match?
		beq	LZSlide_Move				; MJ: if so, branch
		addq.w	#$01,d1					; MJ: increase counter

LZLoadChunk:
		move.b	(a2)+,d2				; MJ: load chunk ID
		bne	LZFindChunk				; MJ: if it's not null, branch

loc_3F6A:
		tst.b	($FFFFF7CA).w
		beq.s	locret_3F7A
		move.w	#5,Off3E(a1)
		sf	($FFFFF7CA).w

locret_3F7A:
		rts
; ===========================================================================

LZSlide_Move:
		bclr	#0,Status(a1)
		move.b	Slide_Speeds(pc,d1.w),d0
		move.b	d0,Inertia(a1)
		bpl.s	loc_3F9A
		bset	#0,Status(a1)

loc_3F9A:
		sf	Inertia+1(a1)
		move.b	#$1B,Anim(a1)	; use Sonic's "sliding" animation
		move.b	#1,($FFFFF7CA).w ; lock	controls (except jumping)
		move.b	($FFFFFE0F).w,d0
		andi.b	#$1F,d0
		bne.s	locret_3FBE
		move.w	#$D0,d0
		jsr	PlaySound ;	play water sound

locret_3FBE:
		rts
; End of function LZWaterSlides

; ===========================================================================
; ---------------------------------------------------------------------------
Slide_Chunks:	dc.b	$05,$06,$09,$0A				; MJ: Chunks to read (128x128 ID's)
		dc.b	$FA,$FB,$FC,$FD
		dc.b	$0B,$0C,$0D,$0E
		dc.b	$15,$16,$F8,$F9
		dc.b	$19,$1A,$1B,$1C
		dc.b	$17
		dc.b	$00					; MJ: End marker
		even
; ---------------------------------------------------------------------------
Slide_Speeds:	dc.b	$0A,$0A,$0A,$0A				; MJ: Values for speed, format XX00 = Speed in $14(a-)
		dc.b	$F6,$F6,$F6,$F6
		dc.b	$0B,$0B,$0B,$0B
		dc.b	$F5,$F5,$F5,$F5
		dc.b	$F4,$F4,$F4,$F4
		dc.b	$F5
		even

GetCorrectColl:
		move.l	#Anglemap,Coll_Pointer		; sonic 1
		move.l	#CollArray1,Coll_Pointer+4	; sonic 1
		move.l	#CollArray2,Coll_Pointer+8 	; sonic 1

.rts		rts
; ---------------------------------------------------------------------------
; Subroutine to load players pallets
; ---------------------------------------------------------------------------

LoadPlayerPallets:
		moveq	#0,d0
		move.b	Current_Character,d0	; get char
		move.w	CharPalList(pc,d0.w),d0	; get pallet
		lea	CharPalList(pc,d0.w),a1	; put to a1

		moveq	#7,d0			; one line
		bsr	Loc_Pal			; load pallets
		tst.l	Water_Array.w		; check if has water
		bmi.s	.rts			; nope?

                moveq	#0,d0
		move.b	Current_Character,d0	; get char
		move.w	CharPalListUW(pc,d0.w),d0; get underwater pallet
		lea	CharPalListUW(pc,d0.w),a1; put to a1

		moveq	#7,d0			; one line
		lea	(a3),a2			; put water pallet to a2
		bsr	Loc_Pal			; load it
.rts		rts

CharPalList:	dc.w Pal_Sonic-CharPalList,Pal_Tails-CharPalList,Pal_Knux-CharPalList
CharPalListUW:	dc.w Pal_SonicUW-CharPalListUW,Pal_TailsUW-CharPalListUW,Pal_KnuxUW-CharPalListUW

Pal_Sonic:      incbin	pallet\sonic.bin	; Sonic day pallet
Pal_Knux:	incbin	pallet\knux.bin		; Knuckles day pallet
Pal_Tails:	incbin	pallet\tails.bin	; Tails day pallet
Pal_SonicUW:	incbin	pallet\son_lzuw.bin	; Sonic (underwater in LZ) pallet
Pal_Tailsuw:	incbin	pallet\tailsuw.bin	; Tails Sunderwater pallet
Pal_Knuxuw:	incbin	pallet\knuxuw.bin       ; Knuckles underwater pallet

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	move Sonic in demo mode
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MoveSonicInDemo:
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Demo sequence	pointers
; ---------------------------------------------------------------------------
Demo_Index:
	include "_inc\Demo pointers for intro.asm"

; ---------------------------------------------------------------------------
; Collision index loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ColIndexLoad:				; XREF: Level
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#$03,d0					; MJ: multiply by 8 not 4
		move.l	ColPointers(pc,d0.w),CollIndx1.w	; MJ: get first collision set
		add.w	#$04,d0					; MJ: increase to next location
		move.l	ColPointers(pc,d0.w),CollIndx2.w	; MJ: get second collision set
		rts
; End of function ColIndexLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Collision index pointers
; ---------------------------------------------------------------------------
ColPointers:
	include "_inc\Collision index pointers.asm"

; ---------------------------------------------------------------------------
; Oscillating number subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


OscillateNumInit:			; XREF: Level
		lea	($FFFFFE5E).w,a1
		lea	(Osc_Data).l,a2
		moveq	#$20,d1

Osc_Loop:
		move.w	(a2)+,(a1)+
		dbf	d1,Osc_Loop
		rts
; End of function OscillateNumInit

; ===========================================================================
Osc_Data:	dc.w $7C, $80		; baseline values
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$50F0
		dc.w $11E, $2080
		dc.w $B4, $3080
		dc.w $10E, $5080
		dc.w $1C2, $7080
		dc.w $276, $80
		dc.w 0,	$80
		dc.w 0
		even

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


OscillateNumDo:				; XREF: Level
		cmpi.b	#6,Object_RAM+Routine
		bhs.s	locret_41C4
		lea	($FFFFFE5E).w,a1
		lea	(Osc_Data2).l,a2
		move.w	(a1)+,d3
		moveq	#$F,d1

loc_4184:
		move.w	(a2)+,d2
		move.w	(a2)+,d4
		btst	d1,d3
		bne.s	loc_41A4
		move.w	2(a1),d0
		add.w	d2,d0
		move.w	d0,2(a1)
		add.w	d0,0(a1)
		cmp.b	0(a1),d4
		bhi.s	loc_41BA
		bset	d1,d3
		bra.s	loc_41BA
; ===========================================================================

loc_41A4:				; XREF: OscillateNumDo
		move.w	2(a1),d0
		sub.w	d2,d0
		move.w	d0,2(a1)
		add.w	d0,0(a1)
		cmp.b	0(a1),d4
		bls.s	loc_41BA
		bclr	d1,d3

loc_41BA:
		addq.w	#4,a1
		dbf	d1,loc_4184
		move.w	d3,($FFFFFE5E).w

locret_41C4:
		rts
; End of function OscillateNumDo

; ===========================================================================
Osc_Data2:	dc.w 2,	$10		; XREF: OscillateNumDo
		dc.w 2,	$18
		dc.w 2,	$20
		dc.w 2,	$30
		dc.w 4,	$20
		dc.w 8,	8
		dc.w 8,	$40
		dc.w 4,	$40
		dc.w 2,	$50
		dc.w 2,	$50
		dc.w 2,	$20
		dc.w 3,	$30
		dc.w 5,	$50
		dc.w 7,	$70
		dc.w 2,	$10
		dc.w 2,	$10
		even

; ---------------------------------------------------------------------------
; Subroutine to	change object animation	variables (rings, giant	rings)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChangeRingFrame:			; XREF: Level
		subq.b	#1,($FFFFFEC0).w
		bpl.s	loc_421C
		move.b	#$B,($FFFFFEC0).w
		subq.b	#1,($FFFFFEC1).w
		andi.b	#7,($FFFFFEC1).w

loc_421C:
		subq.b	#1,($FFFFFEC2).w
		bpl.s	loc_4232
		move.b	#7,($FFFFFEC2).w
		addq.b	#1,($FFFFFEC3).w
		andi.b	#3,($FFFFFEC3).w

loc_4232:
		subq.b	#1,($FFFFFEC4).w
		bpl.s	loc_4250
		move.b	#7,($FFFFFEC4).w
		addq.b	#1,($FFFFFEC5).w
		cmpi.b	#6,($FFFFFEC5).w
		blo.s	loc_4250
		move.b	#0,($FFFFFEC5).w

loc_4250:
		tst.b	($FFFFFEC6).w
		beq.s	locret_4272
		moveq	#0,d0
		move.b	($FFFFFEC6).w,d0
		add.w	($FFFFFEC8).w,d0
		move.w	d0,($FFFFFEC8).w
		rol.w	#7,d0
		andi.w	#3,d0
		move.b	d0,($FFFFFEC7).w
		subq.b	#1,($FFFFFEC6).w

locret_4272:
		rts
; End of function ChangeRingFrame

; ---------------------------------------------------------------------------
; End-of-act signpost pattern loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SignpostArtLoad:			; XREF: Level
		tst.b	$FFFFFE08.w	; is debug mode	being used?
		bne.w	Signpost_Exit	; if yes, branch
		tst.b	($FFFFFE11).w ; is act number 00 (act 1)?
		bne.s	Signpost_Exit	; if yes, branch
		cmpi.b	#7,($FFFFFE10).w ; is act number 00 (act 1)?
		beq.s	Signpost_Exit	; if yes, branch
		move.w	($FFFFF700).w,d0
		move.w	($FFFFF72A).w,d1
		subi.w	#$100,d1
		cmp.w	d1,d0		; has Sonic reached the	edge of	the level?
		blt.s	Signpost_Exit	; if not, branch
		tst.b	($FFFFFE1E).w
		beq.s	Signpost_Exit
		cmp.w	($FFFFF728).w,d1
		beq.s	Signpost_Exit
		move.w	d1,($FFFFF728).w ; move	left boundary to current screen	position
		moveq	#6,d0
		bra.w	LoadPLC2	; load signpost	patterns
; ===========================================================================

Signpost_Exit:
		rts
; End of function SignpostArtLoad

; ===========================================================================
Demo_GHZ:	incbin	demodata\i_ghz.bin
Demo_MZ:	incbin	demodata\i_mz.bin
Demo_SYZ:	incbin	demodata\i_syz.bin
Demo_SS:	incbin	demodata\i_ss.bin

	include "credits.asm"


SpecialStage:
ContinueScreen:
EndingSequence:
Obj89:
TryAgainEnd:					; XREF: Obj_Index
		move.b	#4,$FFFFF600.w
		rts
; ---------------------------------------------------------------------------
; Subroutine to	load level boundaries and start	locations
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LevelSizeLoad:				; XREF: TitleScreen; Level; EndingSequence
		moveq	#0,d0
		move.b	d0,($FFFFF740).w
		move.b	d0,($FFFFF741).w
		move.b	d0,($FFFFF746).w
		move.b	d0,($FFFFF748).w
		move.b	d0,($FFFFF742).w
		move.b	$FFFFFE10.w,d0	; get zone id
		lsl.w	#3,d0		; multiply with 8 (replace 3 with 2 for 4 acts, or with 4 for 16 acts)
		add.b	$FFFFFE11.w,d0	; add act id
		lsl.w	#2,d0		; multiply with 4
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	LevelSizeArray(pc,d0.w),a0 ; load level	boundaries
		move.w	(a0)+,d0	; Transfer first word
		move.w	d0,($FFFFF730).w
		move.l	(a0)+,d0	; Transfer longword (Right level boundary and Left level boundary)
		move.l	d0,($FFFFF728).w
		move.l	d0,($FFFFF720).w
		move.l	(a0)+,d0	; Transfer longoword (Upper boundary and Lower boundary)
		move.l	d0,($FFFFF72C).w
		move.l	d0,($FFFFF724).w
		move.w	($FFFFF728).w,d0
		addi.w	#$240,d0
		move.w	d0,($FFFFF732).w
		move.w	#$1010,($FFFFF74A).w
		move.w	(a0)+,d0	; transfer word ($60)
		move.w	d0,($FFFFF73E).w
		bra.w	LevSz_ChkLamp
; ===========================================================================
; ---------------------------------------------------------------------------
; Level size array and ending start location array
; ---------------------------------------------------------------------------
LevelSizeArray:	; 4 (something to do with level rendering, DO NOT TOUCH), Right level boundary, Left level boundary, Upper boundary, lower boundary, default camera Y-offset
	dc.w 4, 0, $24BF, 0, 	$300, $60; GHZ 1
	dc.w 4, 0, $1FBF, 0, 	$300, $60; GHZ 2
	dc.w 4, 0, $2960, 0, 	$300, $60; GHZ 3
	dc.w 4, 0, $06D0, 0, 	$300, $60; GHZ 4
	dc.w 4, 0, $24BF, 0, 	$300, $60; GHZ 5
	dc.w 4, 0, $1EBF, 0, 	$300, $60; GHZ 6
	dc.w 4, 0, $2960, 0, 	$300, $60; GHZ 7
	dc.w 4, 0, $2ABF, 0, 	$300, $60; GHZ 8
	dc.w 4, 0, $19BF, 0, 	$530, $60; LZ 1
	dc.w 4, 0, $10AF, 0,	$720, $60; LZ 2
	dc.w 4, 0, $202F, $FF00,$800, $60; LZ 3
	dc.w 4, 0, $20BF, 0,	$720, $60; LZ 4
	dc.w 4, 0, $19BF, 0, 	$530, $60; LZ 5
	dc.w 4, 0, $10AF, 0,	$720, $60; LZ 6
	dc.w 4, 0, $202F, $FF00,$800, $60; LZ 7
	dc.w 4, 0, $20BF, 0,	$720, $60; LZ 8
	dc.w 4, 0, $17BF, 0, 	$1D0, $60; MZ 1
	dc.w 4, 0, $18BF, 0, 	$520, $60; MZ 2
	dc.w 4, 0, $1800, 0,	$720, $60; MZ 3
	dc.w 4, 0, $0670, 0,	$220, $60; MZ 4
	dc.w 4, 0, $17BF, 0, 	$1D0, $60; MZ 5
	dc.w 4, 0, $17BF, 0, 	$520, $60; MZ 6
	dc.w 4, 0, $1800, 0,	$720, $60; MZ 7
	dc.w 4, 0, $16BF, 0,	$720, $60; MZ 8
	dc.w 4, 0, $1FBF, 0, 	$640, $60; SLZ 1
	dc.w 4, 0, SLZ2_Boss_Pos_Left, 0, 	$640, $60; SLZ 2
	dc.w 4, 0, $2000, 0, 	$6C0, $60; SLZ 3
	dc.w 4, 0, $0B80, 0, 	$2A0, $60; SLZ 4
	dc.w 4, 0, $1FBF, 0, 	$640, $60; SLZ 5
	dc.w 4, 0, $1FBF, 0, 	$640, $60; SLZ 6
	dc.w 4, 0, $2000, 0, 	$6C0, $60; SLZ 7
	dc.w 4, 0, $3EC0, 0,	$720, $60; SLZ 8
	dc.w 4, 0, $22C0, 0,	$420, $60; SYZ 1
	dc.w 4, 0, SYZ2_Boss_Pos_Left, 0, 	$520, $60; SYZ 2
	dc.w 4, 0, $2C00, 0,	$620, $60; SYZ 3
	dc.w 4, 0, $04E0, 0, 	$150, $60; SYZ 4
	dc.w 4, 0, $22C0, 0, 	$420, $60; SYZ 5
	dc.w 4, 0, $28C0, 0, 	$520, $60; SYZ 6
	dc.w 4, 0, $2C00, 0,	$620, $60; SYZ 7
	dc.w 4, 0, $2EC0, 0, 	$620, $60; SYZ 8
	dc.w 4, 0, $21C0, 0, 	$720, $60; SBZ 1
	dc.w 4, 0, $1E40, $FF00,$800, $60; SBZ 2
SBZ3List:dc.w 4,$2100,$2460,$510,$510, $60; SBZ 3
	dc.w 4, 0, $053C, 0,	$120, $60; SBZ 4
	dc.w 4, 0, $21C0, 0, 	$720, $60; SBZ 5
	dc.w 4, 0, $1E40, $FF00,$800, $60; SBZ 6
	dc.w 4, 0, $2460, 0, 	$510, $60; SBZ 7?
	dc.w 4, 0, $3EC0, 0,	$720, $60; SBZ 8
	dc.w 4, 0, $500, $110, 	$110, $60; ??? 1
	dc.w 4, 0, $DC0, $110, 	$110, $60; ??? 2
	dc.w 4, 0, $2FFF, 0, 	$320, $60; ??? 3
	dc.w 4, 0, $2FFF, 0, 	$320, $60; ??? 4
	dc.w 4, 0, $500, $110,	$110, $60; ??? 5
	dc.w 4, 0, $DC0, $110,	$110, $60; ??? 6
	dc.w 4, 0, $2FFF, 0, 	$320, $60; ??? 7
	dc.w 4, 0, $2FFF, 0, 	$320, $60; ??? 8
        dc.w 4, 0, $1FFF, 0, 	$720, $60; ow 1
	dc.w 4, 0, $0660, 0, 	$220, $60; ow 2
	dc.w 4, 0, $0660, 0, 	$1C0, $60; ow 3
	dc.w 4, 0, $0660, 0, 	$220, $60; ow 4
	dc.w 4, 0, $0660, 0, 	$220, $60; ow 5
	dc.w 4, 0, $0660, 0, 	$220, $60; ow 6
	dc.w 4, 0, $0660, 0, 	$220, $60; ow 7
	dc.w 4, 0, $0660, 0, 	$220, $60; ow 8

EndingStLocArray:
		incbin	misc\sloc_end.bin
		even

; ===========================================================================

LevSz_ChkLamp:				; XREF: LevelSizeLoad
		tst.b	($FFFFFE30).w	; have any lampposts been hit?
		beq.s	LevSz_StartLoc	; if not, branch
		jsr	Obj79_LoadInfo
		move.w	Object_RAM+X_Pos,d1
		move.w	Object_RAM+Y_Pos,d0
		bra.s	loc_60D0
; ===========================================================================

LevSz_StartLoc:				; XREF: LevelSizeLoad
		move.b	$FFFFFE10,d0	; get zone id
		lsl.w	#3,d0		; multiply with 8 (replace 3 with 2 for 4 acts, or with 4 for 16 acts)
		add.b	$FFFFFE11,d0	; add act id
		lsl.w	#2,d0		; multiply with 4
		lea	(StartLocArray).l,a1			; MJ: load location array
		lea	(a1,d0.w),a1				; MJ: load Sonic's start location address
		tst.w	($FFFFFFF0).w	; is demo mode on?
		bpl.s	LevSz_SonicPos	; if not, branch
		move.w	($FFFFFFF4).w,d0
		subq.w	#1,d0
		lsl.w	#2,d0
		lea	EndingStLocArray(pc,d0.w),a1 ; load Sonic's start location

LevSz_SonicPos:
		moveq	#0,d1
		move.w	(a1)+,d1
		move.w	d1,Object_RAM+X_Pos ; set Sonic's position on x-axis
		moveq	#0,d0
		move.w	(a1),d0
		move.w	d0,Object_RAM+Y_Pos ; set Sonic's position on y-axis

loc_60D0:				; XREF: LevSz_ChkLamp
		bsr	ClearTrackingarray2
		subi.w	#$A0,d1
		bhs.s	loc_60D8
		moveq	#0,d1

loc_60D8:
		move.w	($FFFFF72A).w,d2
		cmp.w	d2,d1
		blo.s	loc_60E2
		move.w	d2,d1

loc_60E2:
		move.w	d1,($FFFFF700).w
		subi.w	#$60,d0
		bhs.s	loc_60EE
		moveq	#0,d0

loc_60EE:
		cmp.w	($FFFFF72E).w,d0
		blt.s	loc_60F8
		move.w	($FFFFF72E).w,d0

loc_60F8:
		move.w	d0,($FFFFF704).w
		bsr.w	BgScrollSpeed
		bra.w	LevSz_Unk

ClearTrackingarray:
		move.w	X_Pos(a0),d1
		move.w	Y_Pos(a0),d0

ClearTrackingarray2:
		clr.w	($FFFFF7A8).w		; reset Sonic's position tracking index
		lea	($FFFFCB00).w,a2	; load the tracking array into a2
		moveq	#63,d2			; begin a 64-step loop
.looppoint:
	   	move.w	d1,(a2)+		; fill in X
		move.w	d0,(a2)+		; fill in Y
		dbf	d2,.looppoint		; loop
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; MJ: Sonic start location array
; ---------------------------------------------------------------------------

StartLocArray:	incbin	startpos\ghz1.bin
		incbin	startpos\ghz2.bin
		incbin	startpos\ghz3.bin
		incbin	startpos\ghz4.bin
		incbin	startpos\ghz1.bin
		incbin	startpos\ghz2.bin
		incbin	startpos\ghz3.bin
		incbin	startpos\ghz1.bin
		incbin	startpos\lz1.bin
		incbin	startpos\lz2.bin
		incbin	startpos\lz3.bin
		incbin	startpos\lz4.bin
		incbin	startpos\lz1.bin
		incbin	startpos\lz6.bin
		incbin	startpos\lz3.bin
		incbin	startpos\lz4.bin
		incbin	startpos\mz1.bin
		incbin	startpos\mz2.bin
		incbin	startpos\mz3.bin
		incbin	startpos\mz4.bin
		incbin	startpos\mz1.bin
		incbin	startpos\mz2.bin
		incbin	startpos\mz3.bin
		incbin	startpos\mz4.bin
		incbin	startpos\slz1.bin
		incbin	startpos\slz2.bin
		incbin	startpos\slz3.bin
		incbin	startpos\slz4.bin
		incbin	startpos\slz1.bin
		incbin	startpos\slz2.bin
		incbin	startpos\slz3.bin
		incbin	startpos\slz4.bin
		incbin	startpos\syz1.bin
		incbin	startpos\syz2.bin
		incbin	startpos\syz3.bin
		incbin	startpos\syz4.bin
		incbin	startpos\syz1.bin
		incbin	startpos\syz2.bin
		incbin	startpos\syz3.bin
		incbin	startpos\syz4.bin
		incbin	startpos\sbz1.bin
		incbin	startpos\sbz2.bin
		incbin	startpos\sbz3.bin
		incbin	startpos\sbz4.bin
		incbin	startpos\sbz1.bin
		incbin	startpos\sbz2.bin
		incbin	startpos\sbz3.bin
		incbin	startpos\sbz4.bin
		incbin	startpos\end1.bin
		incbin	startpos\end2.bin
		incbin	startpos\end3.bin
		incbin	startpos\end4.bin
		incbin	startpos\end1.bin
		incbin	startpos\end2.bin
		incbin	startpos\end3.bin
		incbin	startpos\end4.bin
		incbin	startpos\ow1.bin
		incbin	startpos\ow1.bin
		incbin	startpos\ow1.bin
		incbin	startpos\ow1.bin
		incbin	startpos\ow1.bin
		incbin	startpos\ow1.bin
		incbin	startpos\ow1.bin
		incbin	startpos\ow1.bin
		even

; ===========================================================================
; ---------------------------------------------------------------------------
; Which	256x256	tiles contain loops or roll-tunnels
; ---------------------------------------------------------------------------
; Format - 4 bytes per zone, referring to which 256x256 evoke special events:
; loop,	loop, tunnel, tunnel
; ---------------------------------------------------------------------------
LoopTileNums:	incbin	misc\loopnums.bin
		even

; ===========================================================================

LevSz_Unk:				; XREF: LevelSizeLoad
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#3,d0
		lea	dword_61B4(pc,d0.w),a1
		lea	($FFFFF7F0).w,a2
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+
		rts
; End of function LevelSizeLoad

; ===========================================================================
dword_61B4:	dc.l $700100, $1000100
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $700100, $1000100
		dc.l $8000100, $1000000

; ---------------------------------------------------------------------------
; Subroutine to	set scroll speed of some backgrounds
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BgScrollSpeed:				; XREF: LevelSizeLoad
		tst.b	($FFFFFE30).w
		bne.s	loc_6206
		move.w	d0,($FFFFF70C).w
		move.w	d0,($FFFFF714).w
		move.w	d1,($FFFFF708).w
		move.w	d1,($FFFFF710).w
		move.w	d1,($FFFFF718).w

loc_6206:
		moveq	#0,d2
		move.b	($FFFFFE10).w,d2
		add.w	d2,d2
		move.w	BgScroll_Index(pc,d2.w),d2
		jmp	BgScroll_Index(pc,d2.w)
; End of function BgScrollSpeed

; ===========================================================================
BgScroll_Index:	dc.w BgScroll_GHZ-BgScroll_Index, BgScroll_LZ-BgScroll_Index
		dc.w BgScroll_MZ-BgScroll_Index, BgScroll_SLZ-BgScroll_Index
		dc.w BgScroll_SYZ-BgScroll_Index, BgScroll_SBZ-BgScroll_Index
		dc.w BgScroll_End-BgScroll_Index, BgScroll_SBZ-BgScroll_Index
; ===========================================================================
BgScroll_GHZ:				; XREF: BgScroll_Index
		bra.w	Deform_GHZ
; ===========================================================================

BgScroll_LZ:				; XREF: BgScroll_Index
		asr.l	#1,d0
		move.w	d0,($FFFFF70C).w
		rts
; ===========================================================================

BgScroll_MZ:				; XREF: BgScroll_Index
		rts
; ===========================================================================

BgScroll_SLZ:				; XREF: BgScroll_Index
		asr.l	#1,d0
		addi.w	#$C0,d0
		move.w	d0,($FFFFF70C).w
		rts
; ===========================================================================

BgScroll_SYZ:				; XREF: BgScroll_Index
		asl.l	#4,d0
		move.l	d0,d2
		asl.l	#1,d0
		add.l	d2,d0
		asr.l	#8,d0
		move.w	d0,($FFFFF70C).w
		move.w	d0,($FFFFF714).w
		rts
; ===========================================================================

BgScroll_SBZ:				; XREF: BgScroll_Index
		asl.l	#4,d0
		asl.l	#1,d0
		asr.l	#8,d0
		move.w	d0,($FFFFF70C).w
		rts
; ===========================================================================

BgScroll_End:				; XREF: BgScroll_Index
		move.w	#$1E,($FFFFF70C).w
		move.w	#$1E,($FFFFF714).w
		rts
; ===========================================================================
		move.w	#$A8,($FFFFF708).w
		move.w	#$1E,($FFFFF70C).w
		move.w	#-$40,($FFFFF710).w
		move.w	#$1E,($FFFFF714).w
		rts

; ---------------------------------------------------------------------------
; Background layer deformation subroutines
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DeformBgLayer:				; XREF: TitleScreen; Level; EndingSequence
		tst.b	($FFFFF744).w
		beq.s	loc_628E
		rts
; ===========================================================================

loc_628E:
		clr.w	($FFFFF754).w
		clr.w	($FFFFF756).w
		clr.w	($FFFFF758).w
		clr.w	($FFFFF75A).w

	;	cmp.w	#7,$FFFFFE10.w
	;	beq.s	.dyn

		bsr.w	ScrollHoriz
		bsr.w	ScrollVertical
.dyn		bsr.w	DynScrResizeLoad
		move.w	($FFFFF700).w,($FFFFF61A).w
		move.w	($FFFFF704).w,($FFFFF616).w
		move.w	($FFFFF708).w,($FFFFF61C).w
		move.w	($FFFFF70C).w,($FFFFF618).w
		move.w	($FFFFF718).w,($FFFFF620).w
		move.w	($FFFFF71C).w,($FFFFF61E).w
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	Deform_Index(pc,d0.w),d0
		jmp	Deform_Index(pc,d0.w)
; End of function DeformBgLayer

; ===========================================================================
; ---------------------------------------------------------------------------
; Offset index for background layer deformation	code
; ---------------------------------------------------------------------------
Deform_Index:	dc.w Deform_GHZ-Deform_Index, Deform_LZ-Deform_Index
		dc.w Deform_MZ-Deform_Index, Deform_SLZ-Deform_Index
		dc.w Deform_SYZ-Deform_Index, Deform_SBZ-Deform_Index
		dc.w Deform_GHZ-Deform_Index, Deform_SBZ-Deform_Index
; ---------------------------------------------------------------------------
; Overworld Zone background layer deformation code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
Deform_ow:				; XREF: Deform_Index
		move.w	($FFFFF73A).w,d4
		ext.l	d4
		asl.l	#6,d4
		move.w	($FFFFF73C).w,d5
		ext.l	d5
		muls.w	#110,d5
		bsr.w	ScrollBlock1
		move.w	($FFFFF70C).w,($FFFFF618).w
		lea	($FFFFCC00).w,a1
		move.w	#$DF,d1
		move.w	($FFFFF700).w,d0
		neg.w	d0
		swap	d0
		move.w	($FFFFF708).w,d0
		neg.w	d0

.loop		move.l	d0,(a1)+
		dbf	d1,.loop
		rts
; ---------------------------------------------------------------------------
; Green	Hill Zone background layer deformation code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Deform_GHZ:				; XREF: Deform_Index
		move.w	($FFFFF73A).w,d4
		ext.l	d4
		asl.l	#5,d4
		move.l	d4,d1
		asl.l	#1,d4
		add.l	d1,d4
		moveq	#0,d5
		bsr.w	ScrollBlock1
		bsr.w	ScrollBlock4
		lea	($FFFFCC00).w,a1
		move.w	($FFFFF704).w,d0
		andi.w	#$7FF,d0
		lsr.w	#5,d0
		neg.w	d0
		addi.w	#$26,d0
		move.w	d0,($FFFFF714).w
		move.w	d0,d4
		bsr.w	ScrollBlock3
		move.w	($FFFFF70C).w,($FFFFF618).w
		move.w	#$6F,d1
		sub.w	d4,d1
		move.w	($FFFFF700).w,d0
		cmpi.b	#4,($FFFFF600).w
		bne.s	loc_633C
		moveq	#0,d0

loc_633C:
		neg.w	d0
		swap	d0
		move.w	($FFFFF708).w,d0
		neg.w	d0

loc_6346:
		move.l	d0,(a1)+
		dbf	d1,loc_6346
		move.w	#$27,d1
		move.w	($FFFFF710).w,d0
		neg.w	d0

loc_6356:
		move.l	d0,(a1)+
		dbf	d1,loc_6356
		move.w	($FFFFF710).w,d0
		addi.w	#0,d0
		move.w	($FFFFF700).w,d2
		addi.w	#-$200,d2
		sub.w	d0,d2
		ext.l	d2
		asl.l	#8,d2
		divs.w	#$68,d2
		ext.l	d2
		asl.l	#8,d2
		moveq	#0,d3
		move.w	d0,d3
		move.w	#$47,d1
		add.w	d4,d1

loc_6384:
		move.w	d3,d0
		neg.w	d0
		move.l	d0,(a1)+
		swap	d3
		add.l	d2,d3
		swap	d3
		dbf	d1,loc_6384
		rts
; End of function Deform_GHZ

; ---------------------------------------------------------------------------
; Labyrinth Zone background layer deformation code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
Deform_LZ:
		move.w	($FFFFF73A).w,d4
		ext.l	d4
		asl.l	#7,d4
		move.w	($FFFFF73C).w,d5
		ext.l	d5
		asl.l	#7,d5
		bsr.w	ScrollBlock1
		move.w	($FFFFF70C).w,($FFFFF618).w
		lea	($FFFFCC00).w,a1
		move.w	#$DF,d1
		move.w	($FFFFF700).w,d0
		neg.w	d0
		swap	d0
		move.w	($FFFFF708).w,d0
		neg.w	d0

loc_63C6:
		move.l	d0,(a1)+
		dbf	d1,loc_63C6
		move.w	($FFFFF646).w,d0
		sub.w	($FFFFF704).w,d0
		rts
; ---------------------------------------------------------------------------
; Marble Zone background layer deformation code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Deform_MZ:				; XREF: Deform_Index
		move.w	($FFFFF73A).w,d4
		ext.l	d4
		asl.l	#6,d4
		move.l	d4,d1
		asl.l	#1,d4
		add.l	d1,d4
		moveq	#0,d5
		bsr.w	ScrollBlock1
		move.w	#$200,d0
		move.w	($FFFFF704).w,d1
		subi.w	#$1C8,d1
		blo.s	loc_6402
		move.w	d1,d2
		add.w	d1,d1
		add.w	d2,d1
		asr.w	#2,d1
		add.w	d1,d0

loc_6402:
		move.w	d0,($FFFFF714).w
		bsr.w	ScrollBlock3
		move.w	($FFFFF70C).w,($FFFFF618).w
		lea	($FFFFCC00).w,a1
		move.w	#$DF,d1
		move.w	($FFFFF700).w,d0
		neg.w	d0
		swap	d0
		move.w	($FFFFF708).w,d0
		neg.w	d0

loc_6426:
		move.l	d0,(a1)+
		dbf	d1,loc_6426
		rts
; End of function Deform_MZ

loc_6480:				; XREF: Deform_SLZ
		move.w	(a2)+,d0

loc_6482:
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		dbf	d1,loc_6480
		rts

; ---------------------------------------------------------------------------
; Star Light Zone background layer deformation code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Deform_SLZ:				; XREF: Deform_Index
		move.w	($FFFFF73A).w,d4
		ext.l	d4
		asl.l	#7,d4
		move.w	($FFFFF73C).w,d5
		ext.l	d5
		asl.l	#7,d5
		bsr.w	ScrollBlock2
		move.w	($FFFFF70C).w,($FFFFF618).w
		bsr.w	Deform_SLZ_2
		lea	($FFFFA800).w,a2
		move.w	($FFFFF70C).w,d0
		move.w	d0,d2
		subi.w	#$C0,d0
		andi.w	#$3F0,d0
		lsr.w	#3,d0
		lea	(a2,d0.w),a2
		lea	($FFFFCC00).w,a1
		move.w	#$E,d1
		move.w	($FFFFF700).w,d0
		neg.w	d0
		swap	d0
		andi.w	#$F,d2
		add.w	d2,d2
		move.w	(a2)+,d0
		jmp	loc_6482(pc,d2.w)
; ===========================================================================


; End of function Deform_SLZ


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Deform_SLZ_2:				; XREF: Deform_SLZ
		lea	($FFFFA800).w,a1
		move.w	($FFFFF700).w,d2
		neg.w	d2
		move.w	d2,d0
		asr.w	#3,d0
		sub.w	d2,d0
		ext.l	d0
		asl.l	#4,d0
		divs.w	#$1C,d0
		ext.l	d0
		asl.l	#4,d0
		asl.l	#8,d0
		moveq	#0,d3
		move.w	d2,d3
		move.w	#$1B,d1

loc_64CE:
		move.w	d3,(a1)+
		swap	d3
		add.l	d0,d3
		swap	d3
		dbf	d1,loc_64CE
		move.w	d2,d0
		asr.w	#3,d0
		move.w	#4,d1

loc_64E2:
		move.w	d0,(a1)+
		dbf	d1,loc_64E2
		move.w	d2,d0
		asr.w	#2,d0
		move.w	#4,d1

loc_64F0:
		move.w	d0,(a1)+
		dbf	d1,loc_64F0
		move.w	d2,d0
		asr.w	#1,d0
		move.w	#$1D,d1

loc_64FE:
		move.w	d0,(a1)+
		dbf	d1,loc_64FE
		rts
; End of function Deform_SLZ_2

; ---------------------------------------------------------------------------
; Spring Yard Zone background layer deformation	code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Deform_SYZ:				; XREF: Deform_Index
		move.w	($FFFFF73A).w,d4
		ext.l	d4
		asl.l	#6,d4
		move.w	($FFFFF73C).w,d5
		ext.l	d5
		asl.l	#4,d5
		move.l	d5,d1
		asl.l	#1,d5
		add.l	d1,d5
		bsr.w	ScrollBlock1
		move.w	($FFFFF70C).w,($FFFFF618).w
		lea	($FFFFCC00).w,a1
		move.w	#$DF,d1
		move.w	($FFFFF700).w,d0
		neg.w	d0
		swap	d0
		move.w	($FFFFF708).w,d0
		neg.w	d0

loc_653C:
		move.l	d0,(a1)+
		dbf	d1,loc_653C
		rts
; End of function Deform_SYZ

; ---------------------------------------------------------------------------
; Scrap	Brain Zone background layer deformation	code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Deform_SBZ:				; XREF: Deform_Index
		move.w	($FFFFF73A).w,d4
		ext.l	d4
		asl.l	#6,d4
		move.w	($FFFFF73C).w,d5
		ext.l	d5
		asl.l	#4,d5
		asl.l	#1,d5
		bsr.w	ScrollBlock1
		move.w	($FFFFF70C).w,($FFFFF618).w
		lea	($FFFFCC00).w,a1
		move.w	#$DF,d1
		move.w	($FFFFF700).w,d0
		neg.w	d0
		swap	d0
		move.w	($FFFFF708).w,d0
		neg.w	d0

loc_6576:
		move.l	d0,(a1)+
		dbf	d1,loc_6576
		rts
; End of function Deform_SBZ

; ---------------------------------------------------------------------------
; Subroutine to	scroll the level horizontally as Sonic moves
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollHoriz:				; XREF: DeformBgLayer
		tst.b	Hacky_Mode.w
		bmi.s	locret_65B0

		move.w	($FFFFF700).w,d4
		bsr.s	ScrollHoriz2
		move.w	($FFFFF700).w,d0
		andi.w	#$10,d0
		move.b	($FFFFF74A).w,d1
		eor.b	d1,d0
		bne.s	locret_65B0
		eori.b	#$10,($FFFFF74A).w
		move.w	($FFFFF700).w,d0
		sub.w	d4,d0
		bpl.s	loc_65AA
		bset	#2,($FFFFF754).w
		rts
; ===========================================================================

loc_65AA:
		bset	#3,($FFFFF754).w

locret_65B0:
		rts
; End of function ScrollHoriz


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollHoriz2:				; XREF: ScrollHoriz
		move.w	Spindash_HorizDelay,d1
		beq.s	.cont1
		sub.w	#$100,d1
		move.w	d1,Spindash_HorizDelay
		moveq	#0,d1
		move.b	Spindash_HorizDelay,d1
		lsl.b	#2,d1
		addq.b	#4,d1
		move.w	($FFFFF7A8).w,d0
		sub.b	d1,d0
		lea	($FFFFCB00).w,a1
		move.w	(a1,d0.w),d0
		and.w	#$3FFF,d0
		bra.s	.cont2

.cont1:
		move.w	(Object_RAM+X_Pos).w,d0
.cont2:
		moveq	#0,d1
		move.b	ExtCam_pos,d1	; put the stuff in d1
		ext.w	d1		; extend to work (fixes issues for negative values)
		add.w	d1,d0		; add to d0 (screen position)
		sub.w	($FFFFF700).w,d0
		subi.w	#$90,d0
		blt.s	loc_65F6
		subi.w	#$10,d0
		bgt.s	loc_65CC
		clr.w	($FFFFF73A).w
		rts
; ===========================================================================

loc_65CC:
		cmpi.w	#$10,d0
		blt.s	loc_65D6
		move.w	#$10,d0

loc_65D6:
		add.w	($FFFFF700).w,d0
		cmp.w	($FFFFF72A).w,d0
		blt.s	loc_65E4
		move.w	($FFFFF72A).w,d0

loc_65E4:
		move.w	d0,d1
		sub.w	($FFFFF700).w,d1
		asl.w	#8,d1
		move.w	d0,($FFFFF700).w
		move.w	d1,($FFFFF73A).w
		rts
; ===========================================================================

loc_65F6:				; XREF: ScrollHoriz2
		cmpi.w	#-$10,d0
		bgt.s	.cont
		move.w	#-$10,d0

.cont:
		add.w	($FFFFF700).w,d0
		cmp.w	($FFFFF728).w,d0
		bgt.s	loc_65E4
		move.w	($FFFFF728).w,d0
		bra.s	loc_65E4
; End of function ScrollHoriz2
; ===========================================================================

loc_6610:
		move.w	#2,d0
		bra.s	loc_65CC

; ---------------------------------------------------------------------------
; Subroutine to	scroll the level vertically as Sonic moves
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollVertical:				; XREF: DeformBgLayer
		moveq	#0,d1
		move.w	Object_RAM+Y_Pos,d0
		sub.w	($FFFFF704).w,d0
		btst	#2,Object_RAM+Status
		beq.s	loc_662A
		subq.w	#5,d0

loc_662A:
		btst	#1,Object_RAM+Status
		beq.s	loc_664A
		addi.w	#$20,d0
		sub.w	($FFFFF73E).w,d0
		blo.s	loc_6696
		subi.w	#$40,d0
		bhs.s	loc_6696
		tst.b	($FFFFF75C).w
		bne.s	loc_66A8
		bra.s	loc_6656
; ===========================================================================

loc_664A:
		sub.w	($FFFFF73E).w,d0
		bne.s	loc_665C
		tst.b	($FFFFF75C).w
		bne.s	loc_66A8

loc_6656:
		clr.w	($FFFFF73C).w
		rts
; ===========================================================================

loc_665C:
		cmpi.w	#$60,($FFFFF73E).w
		bne.s	loc_6684
		move.w	Object_RAM+Inertia,d1
		bpl.s	loc_666C
		neg.w	d1

loc_666C:
		cmpi.w	#$800,d1
		bhs.s	loc_6696
		move.w	#$600,d1
		cmpi.w	#6,d0
		bgt.s	loc_66F6
		cmpi.w	#-6,d0
		blt.s	loc_66C0
		bra.s	loc_66AE
; ===========================================================================

loc_6684:
		move.w	#$200,d1
		cmpi.w	#2,d0
		bgt.s	loc_66F6
		cmpi.w	#-2,d0
		blt.s	loc_66C0
		bra.s	loc_66AE
; ===========================================================================

loc_6696:
		move.w	#$1000,d1
		cmpi.w	#$10,d0
		bgt.s	loc_66F6
		cmpi.w	#-$10,d0
		blt.s	loc_66C0
		bra.s	loc_66AE
; ===========================================================================

loc_66A8:
		moveq	#0,d0
		move.b	d0,($FFFFF75C).w

loc_66AE:
		moveq	#0,d1
		move.w	d0,d1
		add.w	($FFFFF704).w,d1
		tst.w	d0
		bpl.w	loc_6700
		bra.w	loc_66CC
; ===========================================================================

loc_66C0:
		neg.w	d1
		ext.l	d1
		asl.l	#8,d1
		add.l	($FFFFF704).w,d1
		swap	d1

loc_66CC:
		cmp.w	($FFFFF72C).w,d1
		bgt.s	loc_6724
		cmpi.w	#-$100,d1
		bgt.s	loc_66F0
		andi.w	#$7FF,d1
		andi.w	#$7FF,Object_RAM+Y_Pos
		andi.w	#$7FF,($FFFFF704).w
		andi.w	#$3FF,($FFFFF70C).w
		bra.s	loc_6724
; ===========================================================================

loc_66F0:
		move.w	($FFFFF72C).w,d1
		bra.s	loc_6724
; ===========================================================================

loc_66F6:
		ext.l	d1
		asl.l	#8,d1
		add.l	($FFFFF704).w,d1
		swap	d1

loc_6700:
		cmp.w	($FFFFF72E).w,d1
		blt.s	loc_6724
		subi.w	#$800,d1
		blo.s	loc_6720
		andi.w	#$7FF,Object_RAM+Y_Pos
		subi.w	#$800,($FFFFF704).w
		andi.w	#$3FF,($FFFFF70C).w
		bra.s	loc_6724
; ===========================================================================

loc_6720:
		move.w	($FFFFF72E).w,d1

loc_6724:
		move.w	($FFFFF704).w,d4
		swap	d1
		move.l	d1,d3
		sub.l	($FFFFF704).w,d3
		ror.l	#8,d3
		move.w	d3,($FFFFF73C).w
		move.l	d1,($FFFFF704).w
		move.w	($FFFFF704).w,d0
		andi.w	#$10,d0
		move.b	($FFFFF74B).w,d1
		eor.b	d1,d0
		bne.s	locret_6766
		eori.b	#$10,($FFFFF74B).w
		move.w	($FFFFF704).w,d0
		sub.w	d4,d0
		bpl.s	loc_6760
		bset	#0,($FFFFF754).w
		rts
; ===========================================================================

loc_6760:
		bset	#1,($FFFFF754).w

locret_6766:
		rts
; End of function ScrollVertical


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollBlock1:				; XREF: Deform_GHZ; et al
		move.l	($FFFFF708).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,($FFFFF708).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74C).w,d3
		eor.b	d3,d1
		bne.s	loc_679C
		eori.b	#$10,($FFFFF74C).w
		sub.l	d2,d0
		bpl.s	loc_6796
		bset	#2,($FFFFF756).w
		bra.s	loc_679C
; ===========================================================================

loc_6796:
		bset	#3,($FFFFF756).w

loc_679C:
		move.l	($FFFFF70C).w,d3
		move.l	d3,d0
		add.l	d5,d0
		move.l	d0,($FFFFF70C).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74D).w,d2
		eor.b	d2,d1
		bne.s	locret_67D0
		eori.b	#$10,($FFFFF74D).w
		sub.l	d3,d0
		bpl.s	loc_67CA
		bset	#0,($FFFFF756).w
		rts
; ===========================================================================

loc_67CA:
		bset	#1,($FFFFF756).w

locret_67D0:
		rts
; End of function ScrollBlock1


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollBlock2:				; XREF: Deform_SLZ
		move.l	($FFFFF708).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,($FFFFF708).w
		move.l	($FFFFF70C).w,d3
		move.l	d3,d0
		add.l	d5,d0
		move.l	d0,($FFFFF70C).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74D).w,d2
		eor.b	d2,d1
		bne.s	locret_6812
		eori.b	#$10,($FFFFF74D).w
		sub.l	d3,d0
		bpl.s	loc_680C
		bset	#0,($FFFFF756).w
		rts
; ===========================================================================

loc_680C:
		bset	#1,($FFFFF756).w

locret_6812:
		rts
; End of function ScrollBlock2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollBlock3:				; XREF: Deform_GHZ; et al
		move.w	($FFFFF70C).w,d3
		move.w	d0,($FFFFF70C).w
		move.w	d0,d1
		andi.w	#$10,d1
		move.b	($FFFFF74D).w,d2
		eor.b	d2,d1
		bne.s	locret_6842
		eori.b	#$10,($FFFFF74D).w
		sub.w	d3,d0
		bpl.s	loc_683C
		bset	#0,($FFFFF756).w
		rts
; ===========================================================================

loc_683C:
		bset	#1,($FFFFF756).w

locret_6842:
		rts
; End of function ScrollBlock3


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollBlock4:				; XREF: Deform_GHZ
		move.w	($FFFFF710).w,d2
		move.w	($FFFFF714).w,d3
		move.w	($FFFFF73A).w,d0
		ext.l	d0
		asl.l	#7,d0
		add.l	d0,($FFFFF710).w
		move.w	($FFFFF710).w,d0
		andi.w	#$10,d0
		move.b	($FFFFF74E).w,d1
		eor.b	d1,d0
		bne.s	locret_6884
		eori.b	#$10,($FFFFF74E).w
		move.w	($FFFFF710).w,d0
		sub.w	d2,d0
		bpl.s	loc_687E
		bset	#2,($FFFFF758).w
		bra.s	locret_6884
; ===========================================================================

loc_687E:
		bset	#3,($FFFFF758).w

locret_6884:
		rts
; End of function ScrollBlock4

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_6886:				; XREF: loc_C44
		lea	VDP_Control_Port,a5
		lea	VDP_Data_Port,a6
		lea	($FFFFF756).w,a2
		lea	($FFFFF708).w,a3
		movea.l	Layout_BG,a4			; MJ: Load address of layout BG
		move.w	#$6000,d2
		bsr.w	sub_6954
		lea	($FFFFF758).w,a2
		lea	($FFFFF710).w,a3
		bra.w	sub_69F4
; End of function sub_6886

; ---------------------------------------------------------------------------
; Subroutine to	display	correct	tiles as you move
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadTilesAsYouMove:			; XREF: Demo_Time
		lea	VDP_Control_Port,a5
		lea	VDP_Data_Port,a6
		lea	($FFFFFF32).w,a2
		lea	($FFFFFF18).w,a3
		movea.l	Layout_BG,a4			; MJ: Load address of layout BG
		move.w	#$6000,d2
		bsr.w	sub_6954
		lea	($FFFFFF34).w,a2
		lea	($FFFFFF20).w,a3
		bsr.w	sub_69F4
		lea	($FFFFFF30).w,a2
		lea	($FFFFFF10).w,a3
		movea.l	Layout_Data,a4			; MJ: Load address of layout
		move.w	#$4000,d2
		tst.b	(Dirty_flag).w
		beq.s	Draw_FG

		move.b	#0,(Dirty_flag).w
		moveq	#-$10,d4
		moveq	#$F,d6
; loc_DACE:
Draw_All:
	   	movem.l	d4-d6,-(sp)	; This whole routine basically redraws the whole
		moveq	#-$10,d5	; area instead of merely a line of tiles
		move.w	d4,d1
		bsr.w	sub_6C20
		move.w	d1,d4
		moveq	#-$10,d5
		bsr.w	sub_6AD8
		movem.l	(sp)+,d4-d6
		addi.w	#$10,d4
		dbf	d6,Draw_All
		move.b	#0,($FFFFFF30).w
		rts

Draw_FG:
		tst.b	(a2)
		beq.s	locret_6952
		bclr	#0,(a2)
		beq.s	loc_6908
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	sub_6C20
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	sub_6AD8

loc_6908:
		bclr	#1,(a2)
		beq.s	loc_6922
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	sub_6C20
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	sub_6AD8

loc_6922:
		bclr	#2,(a2)
		beq.s	loc_6938
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	sub_6C20
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	sub_6B04

loc_6938:
		bclr	#3,(a2)
		beq.s	locret_6952
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	sub_6C20
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	sub_6B04

locret_6952:
		rts
; End of function LoadTilesAsYouMove


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_6954:				; XREF: sub_6886; LoadTilesAsYouMove
		tst.b	(a2)
		beq.w	locret_69F2
		bclr	#0,(a2)
		beq.s	loc_6972
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	sub_6C20
		moveq	#-$10,d4
		moveq	#-$10,d5
		moveq	#$1F,d6
		bsr.w	sub_6ADA

loc_6972:
		bclr	#1,(a2)
		beq.s	loc_698E
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	sub_6C20
		move.w	#$E0,d4
		moveq	#-$10,d5
		moveq	#$1F,d6
		bsr.w	sub_6ADA

loc_698E:
		bclr	#2,(a2)
		beq.s	loc_69BE
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	sub_6C20
		moveq	#-$10,d4
		moveq	#-$10,d5
		move.w	($FFFFF7F0).w,d6
		move.w	4(a3),d1
		andi.w	#-$10,d1
		sub.w	d1,d6
		blt.s	loc_69BE
		lsr.w	#4,d6
		cmpi.w	#$F,d6
		blo.s	loc_69BA
		moveq	#$F,d6

loc_69BA:
		bsr.w	sub_6B06

loc_69BE:
		bclr	#3,(a2)
		beq.s	locret_69F2
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	sub_6C20
		moveq	#-$10,d4
		move.w	#$140,d5
		move.w	($FFFFF7F0).w,d6
		move.w	4(a3),d1
		andi.w	#-$10,d1
		sub.w	d1,d6
		blt.s	locret_69F2
		lsr.w	#4,d6
		cmpi.w	#$F,d6
		blo.s	loc_69EE
		moveq	#$F,d6

loc_69EE:
		bsr.w	sub_6B06

locret_69F2:
		rts
; End of function sub_6954


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_69F4:				; XREF: sub_6886; LoadTilesAsYouMove
		tst.b	(a2)
		beq.w	locret_6A80
		bclr	#2,(a2)
		beq.s	loc_6A3E
		cmpi.w	#$10,(a3)
		blo.s	loc_6A3E
		move.w	($FFFFF7F0).w,d4
		move.w	4(a3),d1
		andi.w	#-$10,d1
		sub.w	d1,d4
		move.w	d4,-(sp)
		moveq	#-$10,d5
		bsr.w	sub_6C20
		move.w	(sp)+,d4
		moveq	#-$10,d5
		move.w	($FFFFF7F0).w,d6
		move.w	4(a3),d1
		andi.w	#-$10,d1
		sub.w	d1,d6
		blt.s	loc_6A3E
		lsr.w	#4,d6
		subi.w	#$E,d6
		bhs.s	loc_6A3E
		neg.w	d6
		bsr.w	sub_6B06

loc_6A3E:
		bclr	#3,(a2)
		beq.s	locret_6A80
		move.w	($FFFFF7F0).w,d4
		move.w	4(a3),d1
		andi.w	#-$10,d1
		sub.w	d1,d4
		move.w	d4,-(sp)
		move.w	#$140,d5
		bsr.w	sub_6C20
		move.w	(sp)+,d4
		move.w	#$140,d5
		move.w	($FFFFF7F0).w,d6
		move.w	4(a3),d1
		andi.w	#-$10,d1
		sub.w	d1,d6
		blt.s	locret_6A80
		lsr.w	#4,d6
		subi.w	#$E,d6
		bhs.s	locret_6A80
		neg.w	d6
		bsr.w	sub_6B06

locret_6A80:
		rts
; End of function sub_69F4

; ===========================================================================
		tst.b	(a2)
		beq.s	locret_6AD6
		bclr	#2,(a2)
		beq.s	loc_6AAC
		move.w	#$D0,d4
		move.w	4(a3),d1
		andi.w	#-$10,d1
		sub.w	d1,d4
		move.w	d4,-(sp)
		moveq	#-$10,d5
		bsr.w	sub_6C3C
		move.w	(sp)+,d4
		moveq	#-$10,d5
		moveq	#2,d6
		bsr.w	sub_6B06

loc_6AAC:
		bclr	#3,(a2)
		beq.s	locret_6AD6
		move.w	#$D0,d4
		move.w	4(a3),d1
		andi.w	#-$10,d1
		sub.w	d1,d4
		move.w	d4,-(sp)
		move.w	#$140,d5
		bsr.w	sub_6C3C
		move.w	(sp)+,d4
		move.w	#$140,d5
		moveq	#2,d6
		bsr.w	sub_6B06

locret_6AD6:
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_6AD8:				; XREF: LoadTilesAsYouMove
		moveq	#$15,d6
; End of function sub_6AD8


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_6ADA:				; XREF: sub_6954; LoadTilesFromStart2
		move.l	#$800000,d7
		move.l	d0,d1

loc_6AE2:
		movem.l	d4-d5,-(sp)
		bsr.w	sub_6BD6
		move.l	d1,d0
		bsr.w	sub_6B32
		addq.b	#4,d1
		andi.b	#$7F,d1
		movem.l	(sp)+,d4-d5
		addi.w	#$10,d5
		dbf	d6,loc_6AE2
		rts
; End of function sub_6ADA


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_6B04:				; XREF: LoadTilesAsYouMove
		moveq	#$F,d6
; End of function sub_6B04


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
; main draw section

sub_6B06:
		move.l	#$800000,d7
		move.l	d0,d1

loc_6B0E:
		movem.l	d4-d5,-(sp)
		bsr.w	sub_6BD6
		move.l	d1,d0
		bsr.w	sub_6B32
		addi.w	#$100,d1
		andi.w	#$FFF,d1
		movem.l	(sp)+,d4-d5
		addi.w	#$10,d4
		dbf	d6,loc_6B0E
		rts
; End of function sub_6B06


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_6B32:				; XREF: sub_6ADA; sub_6B06
		or.w	d2,d0
		swap	d0
		btst	#3,(a0)					; MJ: checking bit 3 not 4 (Flip)
		bne.s	loc_6B6E
		btst	#2,(a0)					; MJ: checking bit 2 not 3 (Mirror)
		bne.s	loc_6B4E
		move.l	d0,(a5)
		move.l	(a1)+,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		move.l	(a1)+,(a6)
		rts
; ===========================================================================

loc_6B4E:
		move.l	d0,(a5)
		move.l	(a1)+,d4
		eori.l	#$8000800,d4
		swap	d4
		move.l	d4,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		move.l	(a1)+,d4
		eori.l	#$8000800,d4
		swap	d4
		move.l	d4,(a6)
		rts
; ===========================================================================

loc_6B6E:
		btst	#2,(a0) 				; MJ: checking bit 2 not 3 (Mirror)
		bne.s	loc_6B90
		move.l	d0,(a5)
		move.l	(a1)+,d5
		move.l	(a1)+,d4
		eori.l	#$10001000,d4
		move.l	d4,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		eori.l	#$10001000,d5
		move.l	d5,(a6)
		rts
; ===========================================================================

loc_6B90:
		move.l	d0,(a5)
		move.l	(a1)+,d5
		move.l	(a1)+,d4
		eori.l	#$18001800,d4
		swap	d4
		move.l	d4,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		eori.l	#$18001800,d5
		swap	d5
		move.l	d5,(a6)
		rts
; End of function sub_6B326)

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
; Reading from layout

sub_6BD6:
		lea	($FFFFB000).w,a1			; MJ: load Block's location
		add.w	4(a3),d4				; MJ: load Y position to d4
		add.w	(a3),d5					; MJ: load X position to d5
		move.w	d4,d3					; MJ: copy Y position to d3
		andi.w	#$780,d3				; MJ: get within 780 (Not 380) (E00 pixels (not 700)) in multiples of 80
		lsr.w	#3,d5					; MJ: divide X position by 8
		move.w	d5,d0					; MJ: copy to d0
		lsr.w	#4,d0					; MJ: divide by 10 (Not 20)
		andi.w	#$7F,d0					; MJ: get within 7F
		lsl.w	#$01,d3					; MJ: multiply by 2 (So it skips the BG)
		add.w	d3,d0					; MJ: add calc'd Y pos
		moveq	#-1,d3					; MJ: prepare FFFF in d3
		move.b	(a4,d0.w),d3				; MJ: collect correct chunk ID from layout
		andi.w	#$FF,d3					; MJ: keep within 7F
		lsl.w	#$07,d3					; MJ: multiply by 80
		andi.w	#$0070,d4				; MJ: keep Y pos within 80 pixels
		andi.w	#$000E,d5				; MJ: keep X pos within 10
		add.w	d4,d3					; MJ: add calc'd Y pos to ror'd d3
		add.w	d5,d3					; MJ: add calc'd X pos to ror'd d3
		movea.l	d3,a0					; MJ: set address (Chunk to read)
		move.w	(a0),d3
		andi.w	#$3FF,d3
		lsl.w	#3,d3
		adda.w	d3,a1

locret_6C1E:
		rts
; End of function sub_6BD6

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
; getting VRam location

sub_6C20:
		add.w	4(a3),d4
		add.w	(a3),d5
		andi.w	#$F0,d4
		andi.w	#$1F0,d5
		lsl.w	#4,d4
		lsr.w	#2,d5
		add.w	d5,d4
		moveq	#3,d0
		swap	d0
		move.w	d4,d0
		rts
; End of function sub_6C20


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
; not used


sub_6C3C:
		add.w	4(a3),d4
		add.w	(a3),d5
		andi.w	#$F0,d4
		andi.w	#$1F0,d5
		lsl.w	#4,d4
		lsr.w	#2,d5
		add.w	d5,d4
		moveq	#2,d0
		swap	d0
		move.w	d4,d0
		rts
; End of function sub_6C3C

; ---------------------------------------------------------------------------
; Subroutine to	load tiles as soon as the level	appears
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadTilesFromStart:			; XREF: Level; EndingSequence
		lea	VDP_Control_Port,a5
		lea	VDP_Data_Port,a6
		lea	($FFFFF700).w,a3
		movea.l	Layout_Data,a4			; MJ: Load address of layout
		move.w	#$4000,d2
		bsr.s	LoadTilesFromStart2
		lea	($FFFFF708).w,a3
		movea.l	Layout_BG,a4			; MJ: Load address of layout BG
		move.w	#$6000,d2
; End of function LoadTilesFromStart


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadTilesFromStart2:			; XREF: LoadTilesFromStart
		moveq	#-$10,d4
		moveq	#$F,d6

loc_6C82:
		movem.l	d4-d6,-(sp)
		moveq	#0,d5
		move.w	d4,d1
		bsr.w	sub_6C20
		move.w	d1,d4
		moveq	#0,d5
		moveq	#$1F,d6
		bsr.w	sub_6ADA
		movem.l	(sp)+,d4-d6
		addi.w	#$10,d4
		dbf	d6,loc_6C82
		rts
; End of function LoadTilesFromStart2

; ---------------------------------------------------------------------------
; Main Load Block loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MainLoadBlockLoad:			; XREF: Level; EndingSequence
		moveq	#0,d0
		move.b	$FFFFFE10.w,d0
		lsl.w	#4,d0
		lea	MainLoadBlocks,a2
		lea	(a2,d0.w),a2
		move.l	a2,-(sp)
		addq.l	#4,a2
		movea.l	(a2)+,a0
		lea	$FFFFB000.w,a1 ; RAM address for 16x16 mappings
		move.w	#0,d0
		bsr.w	EniDec
		movea.l	(a2)+,a0
		lea	$FF0000,a1	; RAM address for 256x256 mappings
		bsr.w	KosDec
		bsr.w	LevelLayoutLoad
		move.w	(a2)+,d0
		move.w	(a2),d0
		andi.w	#$FF,d0

		cmpi.w	#$501,$FFFFFE10.w; is level SBZ2?
		beq.s	MLB_UsePal0E	; if yes, branch
		cmpi.w	#$502,$FFFFFE10.w; is level FZ?
		bne.s	MLB_NormalPal	; if not, branch

MLB_UsePal0E:
		moveq	#$E,d0		; use SBZ2/FZ pallet

MLB_NormalPal:
		bsr.w	PalLoad1	; load pallet (based on	d0)
		movea.l	(sp)+,a2
		cmpi.w	#7,$FFFFFE10.w
		beq.s	rts_666

		addq.w	#4,a2
		moveq	#0,d0
		move.b	$FFFFFE10.w,d0
		lsl.w	#2,d0
		addi.b	#Misc_PLC+1,d0
		bra.w	LoadPLC		; load pattern load cues
; End of function MainLoadBlockLoad

; ---------------------------------------------------------------------------
; Level	layout loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
; This method now releases free ram space from A408 - A7FF

LevelLayoutLoad:
	        moveq	#0,d0
		move.b	$FFFFFE10,d0	; get zone id
		lsl.w	#3,d0		; multiply with 8 (replace 3 with 2 for 4 acts, or with 4 for 16 acts)
		add.b	$FFFFFE11,d0	; add act id
		lsl.w	#2,d0		; multiply with 4 for Level index
	;	add.w	d0,d0
	;	add.w	d0,d0
	;	add.w	d0,d0
		lea	Level_Index,a1
		movea.l	(a1,d0.w),a1				; MJ: moving the address strait to a1 rather than adding a word to an address
		move.l	a1,Layout_Data				; MJ: save location of layout to $FFFFA400
		adda.w	#$0080,a1				; MJ: add 80 (As the BG line is always after the FG line)
		move.l	a1,Layout_BG				; MJ: save location of layout to $FFFFA404
rts_666:	rts						; MJ: Return

; End of function LevelLayoutLoad2


ShakeScreen:
		move.w	ShakeOffset.w,ShakeOffset_prev.w
		moveq	#0,d1
		cmpi.b	#6,Object_RAM+Routine.w
		bcc.s	.set
		move.w	ShakeOffset_Mode.w,d0
		beq.s	.set
		bmi.s	.constant

		subq.w	#1,d0				; If EECC is positive, then it's a timed screen shake
		move.w	d0,ShakeOffset_Mode.w
		move.b	ScreenShakeArray(pc,d0.w),d1
		ext.w	d1
		bra.s	.set
; ---------------------------------------------------------------------------

.constant	move.w	$FFFFFE04.w,d0			; If EECC is negative, it's a constant screen shake
		andi.w	#$3F,d0
		add.w	d0,d0
		move.w	ScreenShakeArray2(pc,d0.w),d1
.set		move.w	d1,ShakeOffset.w
		rts
; End of function ShakeScreen_Setup
; ---------------------------------------------------------------------------
ScreenShakeArray:	dc.b 1,$FF,1,$FF,2,$FE,2,$FE,3,$FD,3,$FD,4,$FC,4,$FC,5,$FB,5,$FB
ScreenShakeArray2:	include "misc/ScreenShake.asm"

; ---------------------------------------------------------------------------
; Dynamic screen resize	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DynScrResizeLoad:			; XREF: DeformBgLayer
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	Resize_Index(pc,d0.w),d0
		jsr	Resize_Index(pc,d0.w)
		lea	$FFFFF726.w,a0
		lea	$FFFFF72E.w,a1
		lea	$FFFFF704.w,a2

.do		moveq	#2,d1
		move.w	(a0),d0
		sub.w	(a1),d0
		beq.s	locret_6DAA
		bhs.s	loc_6DAC
		neg.w	d1
		move.w	(a2),d0
		cmp.w	(a0),d0
		bls.s	loc_6DA0
		move.w	d0,(a1)
		andi.w	#-2,(a1)

loc_6DA0:
		add.w	d1,(a1)
		move.b	#1,($FFFFF75C).w

locret_6DAA:
		rts
; ===========================================================================

loc_6DAC:				; XREF: DynScrResizeLoad
		move.w	($FFFFF704).w,d0
		addq.w	#8,d0
		cmp.w	($FFFFF72E).w,d0
		blo.s	loc_6DC4
		btst	#1,Object_RAM+Status
		beq.s	loc_6DC4
		add.w	d1,d1
		add.w	d1,d1

loc_6DC4:
		add.w	d1,($FFFFF72E).w
		move.b	#1,($FFFFF75C).w
		rts
; End of function DynScrResizeLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Offset index for dynamic screen resizing
; ---------------------------------------------------------------------------
Resize_Index:	dc.w Resize_GHZ-Resize_Index, Resize_LZ-Resize_Index
		dc.w Resize_MZ-Resize_Index, Resize_SLZ-Resize_Index
		dc.w Resize_SYZ-Resize_Index, Resize_SBZ-Resize_Index
		dc.w Resize_Ending-Resize_Index, Resize_ow-Resize_Index
; ===========================================================================
Resize_ow:
		jsr	ShakeScreen			; scrren shake ala Sonic 3
		move.w	#-1,ShakeOffset_Mode.w
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	.i(pc,d0.w),d1
		jmp	.i(pc,d1.w)

; ===========================================================================
.i		dc.w .chkLevStart-.i, .chkSonic-.i, .wait-.i
		dc.w .spawn-.i, .wait2-.i
		dc.w .loadbossgfx-.i, .loadbossgfx-.i, .loadbossgfx-.i, .loadbossgfx-.i
		dc.w .wait2-.i, .vscroll-.i, .final-.i, .fadeout-.i, .fadeout2-.i, .fadeout3-.i, .last-.i
; ===========================================================================
.chkLevStart	cmp.w	#$100,Object_RAM+y_pos.w
		ble.s	.main
		cmp.w	#$120,Object_RAM+y_pos.w
		bhi.s	.main
		addq.b	#2,$FFFFF742.w

.chkSonic	move.w	#$700,$FFFFF726.w

		move.w	Object_RAM+Y_vel.w,d1
		bpl.s	.pos
		neg.w	d1

.pos		cmp.w	#$400,d1
		bge.s	.nomove

		move.w	ShakeOffset.w,d0		; get offset
		add.w	d0,$FFFFF704.w			; add to screen y
.nomove		ori.b	#3,$FFFFF754.w

.next		cmp.w	#FZ2_Boss_Pos_Left+$20,Object_RAM+x_pos.w
		ble.s	.main
		move.w	$FFFFF70C.w,PlaneBY_Stored.w

.wait		addq.b	#2,$FFFFF742.w
.wait2		move.w	ShakeOffset.w,d0		; get offset
		add.w	d0,$FFFFF704.w			; add to screen y
		move.w	PlaneBY_Stored.w,$FFFFF70C.w

.main		rts

; ===========================================================================
.fadeout2	cmp.w	#$350,Object_RAM+y_pos.w
		blt.s	.nop
		move.w	#$4A0,$FFFFF726.w

		cmp.w	#$370,Object_RAM+y_pos.w
		blt.s	.nop
		addq.b	#2,$FFFFF742.w

.nop		subq.b	#1,$FFFFF743.w
		bpl.s	.fadeout
		move.b	#4,$FFFFF743.w

		jsr	RandomNumber
		and.l	#$FFFF,d0
		divu.w	#21,d0
		swap	d0			; get quotient
		asl.w	#4,d0
		add.w	$FFFFF700.w,d0
		andi.w	#$FFF0,d0		; fix to per-block position
		move.w	d0,d3
		move.w	#$378,d2		; Y-position of block
		moveq	#4-1,d7

.lp		jsr	Floor_ChkTile
		tst.b	(a1)
		bne.s	.found

		sub.w	#16,d2
		dbf	d7,.lp
		bra.s	.fadeout

; ===========================================================================
.found		move.w	#0,(a1)

		jsr	SingleObjLoad
		bne.s	.fadeout
		move.b	#5,(a1)
		move.w	d2,y_pos(a1)
		move.w	d3,x_pos(a1)

		move.w	#$4000,Art_Tile(a1)
		move.b	d7,Anim_Frame(a1)
		move.l	#FZ2_Boss_Map_FallingTiles,Mappings_Offset(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#1,Dirty_Flag.w
		addq.w	#4,sp

.fadeout	move.w	ShakeOffset.w,d0		; get offset
		add.w	d0,$FFFFF704.w			; add to screen y
		add.w	d0,$FFFFF704.w			; add to screen y
		add.w	d0,$FFFFF704.w			; add to screen y
		move.w	PlaneBY_Stored.w,$FFFFF70C.w	; limit the bg movement (to fix infinity scrolling bg issue)
.asd		bsr	.dmavscroll

		lea	FZ2_Boss_VScroll.w,a0		; get VScroll moving RAM
		lea	FZ2_Boss_VScrollFinal.w,a1	; get final array
		moveq	#FZ2_Boss_VScrollSize-1,d0	; get len

		moveq	#0,d2
		move.b	(a0),d2
		move.l	$FFFFF616.w,d1			; get base

.loopxx		move.l	d1,(a1)+
		add.b	d2,-3(a1)
		bchg	#0,d3
		beq.s	.lel
		neg.b	d2
.lel		dbf	d0,.loopxx
.x		rts

; ===========================================================================
.fadelist	dc.w $310+($76*0), $310+($76*1), $310+($76*2)

.fadeout3	moveq	#3-1,d0
		lea	.fadelist(pc),a0

.runfade	move.w	(a0)+,d1
		sub.w	$FFFFF704.w,d1
		cmp.w	#6,d1
		bhi.s	.nextfade

		move.w	#$202F,($FFFFF626).w
		jsr	Pal_FadeOut		; fade out gradually
		bra.s	.c

.nextfade	dbf	d0,.runfade
		move.w	#$8B00+%00000011,VDP_Control_Port; VScroll off, HScroll per Scan
		move.w	#$2602,$FFFFF72A.w

.c		cmp.w	#$49C,$FFFFF704.w
		ble.s	.123
		addq.b	#2,$FFFFF742.w
		moveq	#$FFFFFFE4+$15,d0	; music $11
		jmp	PlayMusic		; wait for a frame to ensure turret loads

.123		rts
; ===========================================================================

.last		cmp.w	#$1C00,$FFFFF700.w
		blt.s	.123
		move.b	#1,$FFFFF7CC.w ; lock	controls
		move.w	#$800,$FFFFF602.w ; make Sonic run to	the right

		cmp.w	#$2600,$FFFFF700.w
		blt.s	.123
		jmp	ToCredits

; ===========================================================================
.spawn		jsr	SingleObjLoad
		bne	.123

		move.b	#FZ_Boss_ID,(a1)
		move.w	#FZ_Boss_SP_X,x_pos(a1)
		move.w	#FZ_Boss_SP_Y,y_pos(a1)

		addq.b	#2,$FFFFF742.w
		sf	$FFFFF743.w
		moveq	#Misc_PLC+(8*4)-1,d0
		jmp	LoadPLC		; load boss patterns

; ===========================================================================
.list		dc.w $8000, $C60, LBZbossArt1-LBZbossArt1
		dc.w $8C60, $C60, LBZbossArt2-LBZbossArt1
		dc.w $98C0, $C20, LBZbossArt3-LBZbossArt1
		dc.w $75C0, $510, LBZbossArt4-LBZbossArt1
; ===========================================================================
.loadbossgfx	subq.b	#1,$FFFFF743.w
		bpl	.123
		move.b	#3,$FFFFF743.w
		addq.b	#2,$FFFFF742.w

		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	.list-(5*6)(pc,d0.w),a2

		move.l	#CompDec_RAM&$00FFFFFF,d1
		move.w	(a2)+,d2
		move.w	(a2)+,d3
		jsr	QueueDMATransfer

		lea	CompDec_RAM,a1
		lea	LBZbossArt1,a0
		move.w	(a2)+,d0
		add.w	d0,a0
		jmp	KosDec

; ===========================================================================
.final		move.w	ShakeOffset.w,d0		; get offset
		add.w	d0,$FFFFF704.w			; add to screen y
		add.w	d0,$FFFFF704.w			; add to screen y
		add.w	d0,$FFFFF704.w			; add to screen y

		move.w	#$8B00+%00000111,VDP_Control_Port; VScroll on, HScroll per Scan

		move.w	#FZ2_Boss_Pos_Down-$40,d0	; get the screen max pos
		sub.w	$FFFFF704.w,d0			; sub screen y from it
		bpl.s	.skip3				; if in range, branch
		move.w	#FZ2_Boss_Pos_Down-$42,$FFFFF704.w; keep the screen on acceptable ranges
		move.w	PlaneBY_Stored.w,$FFFFF70C.w	; limit the bg movement (to fix infinity scrolling bg issue)

.skip3		bsr	.dmavscroll

		lea	FZ2_Boss_VScroll.w,a0		; get VScroll moving RAM
		lea	FZ2_Boss_VScrollFinal.w,a1	; get final array
		moveq	#FZ2_Boss_VScrollSize-1,d0	; get len

		moveq	#0,d2
		move.b	(a0),d2
		addq.b	#1,(a0)
		move.l	$FFFFF616.w,d1			; get base

.loopv		move.l	d1,(a1)+
		add.b	d2,-3(a1)
		bchg	#0,d3
		beq.s	.l
		neg.b	d2
.l		dbf	d0,.loopv

		tst.b	d2
		bpl.s	.chk
		neg.b	d2

.chk		cmp.b	#6,d2
		blt.s	.end
		addq.b	#2,$FFFFF742.w

.end		rts
; ===========================================================================
.dmavscroll	move.l	DMAQueueMode.w,d6		; get stored DMA mode
		move.l	#$40000090,DMAQueueMode.w	; set to VSRAM DMA
		moveq	#0,d2				; set VSRAM target
		moveq	#80/2,d3			; 80 bytes

		moveq	#0,d1
		move.w	$FFFFF700.w,d1			; get screen x
		sub.w	#FZ2_Boss_Pos_Left+1,d1		; subtract Plane x-pos from d1
		asr.w	#4,d1				; divide by 16 (each block is counted as 1)
		asl.w	#2,d1				; divide by 16 (each block is counted as 1)
		add.l	#FZ2_Boss_VScrollFinal&$00FFFFFF,d1; get address of VScroll RAM
		jsr	QueueDMATransfer		; DMA the data to VSRAM
		move.l	d6,DMAQueueMode.w		; restore DMA mode
		rts

.vscroll	move.w	ShakeOffset.w,d0		; get offset
		add.w	d0,$FFFFF704.w			; add to screen y

		move.w	#FZ2_Boss_Pos_ScrDown+2,d0	; get the screen max pos
		sub.w	$FFFFF704.w,d0			; sub screen y from it
		bpl.s	.skip				; if in range, branch
		move.w	#FZ2_Boss_Pos_ScrDown,$FFFFF704.w; keep the screen on acceptable ranges
		move.w	PlaneBY_Stored.w,$FFFFF70C.w	; limit the bg movement (to fix infinity scrolling bg issue)

.skip		bsr	.dmavscroll

		lea	FZ2_Boss_VScroll.w,a0		; get VScroll moving RAM
		lea	FZ2_Boss_VScrollFinal.w,a1	; get final array
		lea	FZ2_Boss_VScrollMove.w,a2	;
		lea	FZ2_Boss_VScrollTimers.w,a3	;
		moveq	#FZ2_Boss_VScrollSize-1,d0	; get len

		move.l	$FFFFF616.w,d1			; get base
.loop		tst.b	(a3)+				; check timer
		bmi.s	.movelayer			; if negative, branch
		subq.b	#1,-1(a3)			; sub 1 from timer
		move.l	d1,(a1)+			; move base
		addq.w	#1,a2				;
		addq.w	#1,a0				; increase pointers
		dbf	d0,.loop			; loop
		bra.s	.com

.resetptr	move.b	#0,-1(a0)			; reset the target scroll
		bra.s	.skip2				; move thing

.movelayer	moveq	#2,d2				; increase
		move.b	(a0)+,d3			; get the max point
		bclr	#0,d3				; clear bit 0
		cmp.b	(a2),d3				; is current y same to moving point
		beq.s	.resetptr			; if same, clear target to 0
		bgt.s	.mv				; if greater, skip
		moveq	#-2,d2				; move down

.mv		add.b	d2,(a2)				; move the position
.skip2		move.l	d1,(a1)+			; move base
		move.b	(a2)+,d2			; get offset
		ext.w	d2				; sign-extend d2
		add.w	d2,-4(a1)			; sub from final array
		dbf	d0,.loop			; loop

.com		moveq	#0,d6
		move.w	Object_RAM+x_pos.w,d0
		sub.w	#FZ2_Boss_Pos_Left+1,d0
		asr.w	#4,d0
		lea	FZ2_Boss_VScrollMove.w,a1
		lea	(a1,d0.w),a1

		move.w	Object_RAM+y_pos.w,d0
		sub.w	#FZ2_Boss_Pos_ScrDown+$A8,d0
		move.b	(a1),d1
		beq.s	.rts
		ext.w	d1
		neg.w	d1

		cmp.w	d1,d0
		blt.s	.rts
		cmp.w	#$200,Object_RAM+y_vel.w
		ble.s	.up
		move.w	d1,-(sp)
		lea	Object_RAM,a0
		jsr	HurtSonic
		move.w	(sp)+,d1
		st	d6

.up		move.w	d1,d0
		add.w	#FZ2_Boss_Pos_ScrDown+$A8,d1
		move.w	d1,Object_RAM+y_pos.w
		lsl.w	#6,d0
		move.w	d0,Object_RAM+y_vel.w
		ori.b	#6,Object_RAM+Status.w

		tst.b	d6
		bmi.s	.rts
		move.b	#2,Object_RAM+Anim.w
.rts		rts

; ---------------------------------------------------------------------------
; Green	Hill Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_GHZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_GHZx(pc,d0.w),d0
		jmp	Resize_GHZx(pc,d0.w)
; ===========================================================================
Resize_GHZx:	dc.w Resize_GHZ1-Resize_GHZx
		dc.w Resize_GHZ2-Resize_GHZx
		dc.w Resize_GHZ3-Resize_GHZx
		dc.w Resize_GHZ1-Resize_GHZx
		dc.w Resize_GHZ1-Resize_GHZx
		dc.w Resize_GHZ1-Resize_GHZx
		dc.w Resize_GHZ1-Resize_GHZx
		dc.w Resize_GHZ7-Resize_GHZx
; ===========================================================================
Resize_GHZ7:
		addq.w	#6,Turbomode_flag+4.w
		move.w	Turbomode_flag+4.w,$FFFFF700.w
		move.w	$FFFFF700.w,$FFFFF728.w
		move.w	$FFFFF700.w,$FFFFF72A.w

		move.w	Turbomode_flag.w,d0
		move.w	d0,$FFFFF704.w
		move.w	d0,$FFFFF726.w
		move.w	d0,$FFFFF72C.w
		move.w	d0,$FFFFF72E.w

		tst.b	$FFFFF600.w
		bmi.s	.rts
		move.l	#Col_GHZ_1,CollIndx1.w
		move.l	#Col_GHZ_2,CollIndx2.w
		cmp.w	#$710,Turbomode_flag+4.w
		blo.s	.rts

		sub.l	#$8000,Turbomode_flag.w
		cmp.w	#$1500,Turbomode_flag+4.w
		blo.s	.rts
		move.b	#$1C,$FFFFF600.w

	SRAMEnable
		moveq	#0,d0
		lea	SRAM_Start,a1
		movep.w	d0,SRAM_LastLVL(a1)
	SRAMDisable

.rts		rts

Resize_GHZ1:
		move.w	#$300,($FFFFF726).w ; set lower	y-boundary
		cmpi.w	#$1780,($FFFFF700).w ; has the camera reached $1780 on x-axis?
		blo.s	locret_6E08	; if not, branch
		move.w	#$400,($FFFFF726).w ; set lower	y-boundary

locret_6E08:
		rts
; ===========================================================================

Resize_GHZ2:
		jsr	ShakeScreen
		move.w	ShakeOffset.w,d0
		add.w	d0,$FFFFF704.w

		cmpi.w	#GHZ2_Boss_Pos_Left,$FFFFF700.w
		blo.s	.skip
		move.w	#$302,d0
		sub.w	$FFFFF704.w,d0
		bpl.s	.skip
		move.w	#$300,$FFFFF704.w

.skip		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	.i(pc,d0.w),d0
		jmp	.i(pc,d0.w)
; ===========================================================================
.i		dc.w Resize_GHZ2Main-.i
		dc.w GHZ2Boss_Spawn-.i
		dc.w GHZ2Boss_nothing-.i
		dc.w Resize_GHZ2boss-.i
		dc.w Resize_GHZ3end-.i

GHZ2Boss_ScreenWidth:	equ 320
; ===========================================================================

GHZ2Boss_Spawn:
		cmpi.w	#GHZ2_Boss_SP_SCR_X,$FFFFF700.w
		blo.s	GHZ2Boss_nothing
		bsr.w	SingleObjLoad
		bne.s	.noLoad

		move.b	#GHZ2_Boss_ID,(a1)	; load GHZ boss	object
		move.w	#GHZ2_Boss_SP_X,8(a1)
		move.w	#GHZ2_Boss_SP_Y,$C(a1)

.noLoad		jsr	PlayBossMusic		; play boss music
		addq.b	#2,$FFFFF742.w
		moveq	#5,d0
		jmp	LoadPLC			; load boss patterns

GHZ2Bos_StopScroll:
		move.b	#8,Level_VBIRoutine.w		; set to normal VBlank routine
		move.w	#0,ShakeOffset_Mode.w		; If touching the floor, set up a timed screen shake

FZ2Boss_StopScroll:
		subq.b	#2,$FFFFF742.w			; set to normal resize type
		move.w	#$8B00+%00000011,VDP_Control_Port; VScroll off, HScroll per Scan

GHZ2Boss_nothing:
		rts

; ===========================================================================
FZ2Boss_Scl_GetLen:
		sub.w	d1,d6			; sub d1 from d0
		asr.w	#4,d6			; divide by 16 (each block is counted as 1)
		subq.w	#1,d6			; sub 1 for dbf
		rts

FZ2Boss_Scl_GetX:
		sub.w	#FZ2_Boss_Pos_Left,d0	; subtract minimum scroll position
		asr.w	#4,d0			; divide by 16 (each block is counted as 1)
		lea	FZ2_Boss_VScroll.w,a1	; get address of VScroll RAM
		adda.w	d0,a1			; set to correct position
		rts

FZ2Boss_StartScroll:
		bsr	GHZ2Boss_StartScroll_	; init scrolling (aka set VDP register)
		moveq	#$FFFFFFC0,d0
		jsr	PlaySample2

		move.w	d4,d0			; get big arm min x to d0
		bsr.s	FZ2Boss_Scl_GetX	; get its address
		move.l	a1,a2			; copy address

		move.w	d4,d1			;
		move.w	d5,d6			;
		bsr.s	FZ2Boss_Scl_GetLen	; get size of big arm in blocks
		bmi	.neg

		moveq	#-4,d1			; offset down
		moveq	#0,d0
		addq.b	#1,d6
		lea	FZ2_Boss_VScrollTimers-FZ2_Boss_VScroll(a1),a3
		lea	FZ2_Boss_VScrollMove-FZ2_Boss_VScroll(a1),a4

.loop		move.b	d1,(a1)+		; save offset
		move.b	d0,(a3)+		; save offset
		move.b	d0,(a4)+		; save offset
		dbf	d6,.loop		; loop until 0

		moveq	#14,d0			; get max num
		move.b	Coll2(a0),d1
		lsr.b	#1,d1

		sub.b	d1,d0			; sub hits
		muls.w	#5,d0			; multiply by 5
		move.w	d0,-(sp)		; store to stack

		move.w	d5,d0			; get big arm max x to d0
		bsr.s	FZ2Boss_Scl_GetX	; get its address too

		move.w	#FZ2_Boss_Pos_Right,d6	; get max x position
		move.w	d5,d1			; get big arm max x position
		bsr	FZ2Boss_Scl_GetLen	; get blocks inbetween
		bmi.s	.neg1

		lea	FZ2_Boss_VScrollTimers-FZ2_Boss_VScroll(a1),a3
		lea	FZ2_Boss_VScrollMove-FZ2_Boss_VScroll(a1),a4
		moveq	#0,d5
		move.w	(sp),d2
		move.w	d4,-(sp)
		move.l	#$00040000,d3
		moveq	#0,d4

.loop3		bsr.s	.doRandom
		move.l	a1,a5
		move.b	d5,(a1)+
		move.b	d4,(a3)+
		move.b	#0,(a4)+
		addq.b	#1,d4  			; increase timer
		dbf	d6,.loop3		; loop until 0

.neg1		move.w	(sp)+,d6		; get big arm min x
		move.w	#FZ_Boss_Pos_Left,d1	; get left side of screen
		bsr	FZ2Boss_Scl_GetLen	; get blocks inbetweem
		bmi.s	.neg

		lea	FZ2_Boss_VScrollTimers-FZ2_Boss_VScroll(a2),a3
		lea	FZ2_Boss_VScrollMove-FZ2_Boss_VScroll(a2),a4
		moveq	#0,d5
		moveq	#0,d4
		move.l	#$00040000,d3
		move.w	(sp)+,d2

.loop2		bsr.s	.doRandom
		move.l	a2,a5
		move.b	d5,-(a2)
		move.b	d4,-(a3)
		move.b	#0,-(a4)
		addq.b	#1,d4			; increase timer
		dbf	d6,.loop2		; loop until 0

.neg		rts				; end

; do next random number
.results	dc.b  2, -2, 3, -4, 2, 3, -3, 4

.doRandom	bsr	RandomNumber		; get random number
		andi.w	#7,d0			; limit to 0-7
		moveq	#0,d1			; clear d1 if negative
		move.b	.results(pc,d0.w),d0	; get result
		bmi.s	.loopx			; do only once

		move.l	d3,d1			; get max amount
		swap	d1			; swap to get loop count word
.loopx		add.b	d0,d5			; add d0 to d5
		dbf	d1,.loopx

		tst.b	d5			; text d5
		bmi.s	.negx			; if negative, add factor as negative
		cmp.b	d5,d2			; compare max bound with d5
		bge.s	.nolimit		; if not greater than d3, dont negate

.negx		asr.b	#1,d0			; make smaller range
		move.l	d3,d1			; get max amount
		swap	d1			; swap to get loop count word
		add.w	d1,d1			;
		add.w	d1,d1			; quadruple the amount

.sub		subq.w	#1,d1			; sub 1 step
		bmi.s	.reset2			; if negative, reset d5
		sub.b	d0,d5			; sub it from d5
		bmi.s	.sub			; if negative, keep subbing
		cmp.b	d5,d2			; compare max bound with d5
		blt.s	.sub			; if greater than d3, keep subbing

.nolimit	swap	d2			; swap high word to low
		sub.l	#$C000,d2		; sub $C000 (aka 3/4 of a pixel)
		bmi.s	.reset			; if negative, reset it
		swap	d2			; swap low to high again

		sub.l	#$8000,d3		; sub $4000 (aka i pixel divided by 4)
		bpl.s	.end			; if positive, dont reset
		moveq	#0,d3			; keep at 0
.end		rts				; end

.reset		moveq	#0,d2			; reset counter
.reset2		move.b	(a5),d5			; get last d5
		rts

; ===========================================================================
GHZ2Boss_StartScroll:
		move.w	d0,VScroll_Offset.w		; set Vertical scroll offset
		move.w	d1,VScroll_StartX.w		; set Vertical scroll start position
		move.b	#$1C,Level_VBIRoutine.w		; set to per-cell VScroll VBlank routine

GHZ2Boss_StartScroll_:
		addq.b	#2,$FFFFF742.w			; set to VScroll resize type
		move.w	#-1,ShakeOffset_Mode.w		; If touching the floor, set up a timed screen shake

GHZ2Boss_ResetScroll:
		moveq	#($50/4)-1,d0		; set transfer length
		move.l	$FFFFF616.w,d1		; get... A thing? (Probably base vertical offset for displaying Plane A and B)
		lea	VScroll_RAM.w,a1	; get RAM where VScroll values are to be stored
.fill		move.l	d1,(a1)+		; fill with value
		dbf	d0,.fill		; loop until done

		move.w	#$8B00+%00000111,VDP_Control_Port; VScroll on, HScroll per Scan
		rts

; ===========================================================================
GHZ2Boss_getList:
		lea	GHZ2Boss_PatternMain(pc),a1	; get normal pattern data
		move.w	VScroll_Offset.w,d1		; get Vertical scroll offset
		cmpi.w	#GHZ2Boss_Len*16,d1		; if big enough, use normal pattern data
		bhs.s	.end				; branch to rts

		asr.w	#1,d1				; else, shift bits to make slower cycle
		andi.w	#$FFFC,d1			; make sure no wrong bits are read
		move.l	.lists(pc,d1.w),a1		; get correct list to memory

.end		rts

; ===========================================================================
.lists:		dc.l GHZ2Bos_Pattern1, GHZ2Bos_Pattern2, GHZ2Bos_Pattern3, GHZ2Bos_Pattern4, GHZ2Bos_Pattern5, GHZ2Bos_Pattern6
		dc.l GHZ2Bos_Pattern7, GHZ2Bos_Pattern8, GHZ2Bos_Pattern9, GHZ2Bos_PatternA, GHZ2Bos_PatternB, GHZ2Bos_PatternC

; patterns to use
GHZ2Bos_Pattern1:	dc.w  0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  0
GHZ2Bos_Pattern2:	dc.w  0,  0,  1,  2,  5,  2,  0,  0,  0,  0,  0
GHZ2Bos_Pattern3:	dc.w  0,  1,  2,  3,  5,  7,  4,  2,  0,  0,  0
GHZ2Bos_Pattern4:	dc.w  0,  1,  2,  3,  6,  8,  9,  7,  5,  2,  0
GHZ2Bos_Pattern5:	dc.w  2,  3,  5,  7,  9,  11, 8,  6,  5,  2,  1
GHZ2Bos_Pattern6:	dc.w  3,  5,  8,  10, 12, 13, 10, 7,  6,  4,  2
GHZ2Bos_Pattern7:	dc.w  4,  7,  11, 13, 13, 12, 9,  7,  5,  3,  1
GHZ2Bos_Pattern8:	dc.w  4,  8,  12, 15, 12, 10, 8,  5,  4,  3,  1
GHZ2Bos_Pattern9:	dc.w  4,  8,  12, 14, 11, 10, 7,  4,  4,  2,  1
GHZ2Bos_PatternA:	dc.w  3,  7,  11, 13, 11, 11, 8,  5,  4,  3,  2
GHZ2Bos_PatternB:	dc.w  3,  7,  11, 13, 11, 11, 8,  5,  4,  3,  2
GHZ2Bos_PatternC:	dc.w  2,  5,  9,  11, 12, 12, 10, 8,  6,  3,  2
GHZ2Boss_PatternMain:	dc.w  1,  3,  7,  10, 12, 13, 12, 10, 7,  3,  1
GHZ2Boss_Len:		equ 6
; ===========================================================================

Resize_GHZ2boss:
		bsr	GHZ2Boss_ResetScroll	; clear VScroll values
		addq.w	#4,VScroll_Offset.w	; increase VScroll offset

		move.w	VScroll_StartX.w,d0	; get the start position of VScroll
		sub.w	$FFFFF700.w,d0		; subtract Plane x-pos from d0
		asr.w	#4,d0			; divide by 16 (each block is counted as 1)
		asl.w	#2,d0			; multiply by 4 (each entry is a long-word)

		bsr	GHZ2Boss_getList	; get the pattern list
		pea	GHZ2Boss_ChkDespawn(pc)	; last check if should stop the VScroll
		pea	GHZ2Boss_ChkSonic(pc)	; check Sonic's position and if he should be affected
		pea	GHZ2Boss_DoSecond(pc)	; next do the right edge

		; but first, do left edge!
		move.w	VScroll_Offset.w,d1	; get offset
		asr.w	#4,d1			; divide by 16 (each block is counted as 1)
		asl.w	#2,d1			; multiply by 4 (each entry is a long-word)

		move.w	d0,d2			; copy calculated start position
		sub.w	d1,d2			; substract offset from position
		subi.w	#GHZ2Boss_Len*4,d2	; set to center of position

GHZ2Boss_DoCommon:
		move.l	a1,-(sp)		; store list address to stack
		lea	VScroll_RAM.w,a0	; get address of VScroll RAM
		adda.w	d2,a0			; set to correct position
		moveq	#(GHZ2Boss_Len*2)-2,d1	; set lenght

.loop		move.w	(a1)+,d2	; get next offset from list
		add.w	d2,(a0)		; add it to VScroll position
		lea	4(a0),a0	; get next VScroll position entry
		dbf	d1,.loop	; loop until done
		move.l	(sp)+,a1	; return list address from stack
		rts

GHZ2Boss_DoSecond:
		move.w	VScroll_Offset.w,d1	; get offset
		asr.w	#4,d1			; divide by 16 (each block is counted as 1)
		asl.w	#2,d1			; multiply by 4 (each entry is a long-word)

		move.w	d0,d2			; copy calculated start position
		add.w	d1,d2			; add offset to position
		subi.w	#GHZ2Boss_Len*4,d2	; set to center of position

		move.l	a1,-(sp)		; store list address to stack
		lea	VScroll_RAM.w,a0	; get address of VScroll RAM
		adda.w	d2,a0			; set to correct position
		moveq	#(GHZ2Boss_Len*2)-2,d1	; set lenght
		lea	11*2(a1),a1		; get end of list

.loop		move.w	-(a1),d2	; get next offset from list
		add.w	d2,(a0)		; add it to VScroll position
		lea	4(a0),a0	; get next VScroll position entry
		dbf	d1,.loop	; loop until done
		move.l	(sp)+,a1	; return list address from stack
		rts

GHZ2Boss_ChkDespawn:
		moveq	#(GHZ2Boss_Len*16)+16,d0; get size to memory
		moveq	#0,d2			; clear d2
		move.w	$FFFFF700.w,d2		; get Plane X-pos to d2

		; do left side first
		moveq	#0,d1			; clear d1
		move.w	VScroll_StartX.w,d1	; get VScroll start X-position
		sub.w	VScroll_Offset.w,d1	; substract VScroll offset
		add.w	d0,d1			; add size to d1

		cmp.w	d2,d1			; compare Plane x-pos to d1
		bhi.s	rts_333			; if still on screen, don't despawn

		; do right side last
		moveq	#0,d1			; clear d1
		move.w	VScroll_StartX.w,d1	; get VScroll start X-position
		add.w	VScroll_Offset.w,d1	; add VScroll offset
		sub.w	d0,d1			; substract size to d1

		sub.w	#GHZ2Boss_ScreenWidth,d1; substract screen width from d1
		cmp.w	d2,d1			; compare Plane x-pos to d1
		bhs	GHZ2Bos_StopScroll	; if not on screen, stop scrolling

rts_333		rts

GHZ2Boss_ChkSonic:
		cmpi.w	#$39C,Object_RAM+Y_Pos.w	;
		ble.s	rts_333				; save time by neglecting checks above required Y-pos

		moveq	#(GHZ2Boss_Len*16),d3		; get width to memory
		moveq	#0,d1
		move.w	Object_RAM+X_Pos.w,d0		; get X-position to d1
		move.w	VScroll_StartX.w,d1		; also get VScroll starting position

		cmp.w	d0,d1				; compare them
		ble	GHZ2Boss_ChkSonic_Right		; if to the right from start pos, branch to approriate code

		; Left
		sub.w	VScroll_Offset.w,d1		; align to middle of left bump
		cmp.w	d0,d1				;
		ble	.right				; if right from aligned pos, branch

		; Left
		sub.w	d3,d1				; align to the left edge
		cmp.w	d0,d1				;
		bge	rts_333				; if not in bounds of the bump, branch

		moveq	#-Sonic_SpeedModifier,d2
		bra	GHZ2Boss_S_GetPos

.right		add.w	d3,d1				; align to the right edge
		cmp.w	d0,d1				;
		ble	rts_333				;

		moveq	#Sonic_SpeedModifier/3,d2
		bra	GHZ2Boss_S_GetPos

GHZ2Boss_ChkSonic_Right:
		add.w	VScroll_Offset.w,d1		; align to middle of right bump
		cmp.w	d0,d1				;
		ble	.right				; if right from aligned pos, branch

		; Left
		sub.w	d3,d1				; align to the left edge
		cmp.w	d0,d1				;
		bge	rts_333				; if not in bounds of the bump, branch

		moveq	#-Sonic_SpeedModifier/3,d2
		bra	GHZ2Boss_S_GetPos

.right		add.w	d3,d1				; align to the right edge
		cmp.w	d0,d1				;
		ble	rts_333				;

		moveq	#Sonic_SpeedModifier,d2
	;	bsr	GHZ2Boss_S_GetPos
	;	rts

GHZ2Boss_S_GetPos:
		move.w	$FFFFF700.w,d1		;
		move.w	Object_RAM+X_Pos.w,d0	;
		sub.w	d1,d0			; substract Plane X-pos from Sonic X-pos
		asr.w	#4,d0			; divide by 16 (each block is counted as 1)
		asl.w	#2,d0			; multiply by 4 (each entry is a long-word)

		lea	VScroll_RAM.w,a0	; get address of VScroll RAM
		move.w	(a0,d0.w),d0		; get correct value

		move.w	$FFFFF616.w,d1		; get... A thing? (Probably base vertical offset for displaying Plane A and B)
		sub.w	d0,d1			; substract thing from VScroll value
		muls.w	d1,d2			; multiply speed modifier with VScroll value
		neg.w	d2
		addi.w	#$3AC,d1		; add base Y-pos value to d1

		cmp.w	Object_RAM+Y_Pos.w,d1	; check if in below the bump
		bgt.s	.noTouch		; if not, skip this
		move.w	d1,Object_RAM+Y_Pos.w	; set Y-positio

		move.b	#1,Player_DoubleJump.w	;
		bset	#7,Shield_UseType.w	; make sure we can't abuse double jump moves
		clr.l	Player_DJ_Data.w	; stop flying and gliding
		moveq	#0,d0
		move.l	d0,If_Spindash.w
		move.b	d0,PeelOut_Flag.w
		move.b	d0,Object_RAM+Off3C.w	; clear jumping
		move.b	d0,SpinDust_RAM+Anim.w	; clear Spin Dash dust animation
                move.w	d0,Spindash_HorizDelay.w; clear screen delay counter
                move.b	#$1C,Object_RAM+Anim.w	; set animation
                move.w	#3,Object_RAM+Off3E.w	; set input lock timer
	;	move.b	#1,($FFFFF7CA).w ; lock	controls (except jumping)

		move.w	Object_RAM+Inertia.w,d0	; get Sonic's inertia
		bpl.s	.positive		; if positive, dont negate
		neg.w	d0			; negative to positive

.positive	cmpi.w	#$500,d0		; is inertia greater than $300?
		ble.s	.speed			; if less or equal, branch
		asr.w	Object_RAM+Inertia.w	; slow speed

.speed		add.w	d2,Object_RAM+Inertia.w	; add value to inertia

		move.w	Object_RAM+X_Vel.w,d0	; get Sonic's x-velocity
		bpl.s	.positive2		; if positive, dont negate
		neg.w	d0			; negative to positive

.positive2	cmpi.w	#$500,d0		; is x-velocity greater than $300?
		ble.s	.speed2			; if less or equal, branch
		asr.w	Object_RAM+X_Vel.w	; slow speed

.speed2		add.w	d2,Object_RAM+X_Vel.w	; add value to x-velocity

.noTouch	rts
Sonic_SpeedModifier:	equ 9

Resize_GHZ2Main:
		move.w	#$300,($FFFFF726).w
		cmpi.w	#$ED0,($FFFFF700).w
		blo.s	locret_6E3A
		move.w	#$200,($FFFFF726).w
		cmpi.w	#$1600,($FFFFF700).w
		blo.s	locret_6E3A
		move.w	#$400,($FFFFF726).w

		move.w	#0,($FFFFF72C).w
		cmpi.w	#$1C40,($FFFFF700).w
		blo.s	locret_6E3A
		move.w	#$300,($FFFFF72C).w

		cmpi.w	#$1D60,($FFFFF700).w
		blo.s	locret_6E3A
		move.w	#$300,($FFFFF726).w
		cmpi.w	#$1F00,($FFFFF700).w
		blo.s	locret_6E3A

		move.w	#$1F00,($FFFFF728).w
		addq.b	#2,($FFFFF742).w

locret_6E3A:
		rts
; ===========================================================================
resize_ghz3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_6E4A(pc,d0.w),d0
		jmp	off_6E4A(pc,d0.w)
; ===========================================================================
off_6E4A:	dc.w Resize_GHZ3main-off_6E4A
		dc.w Resize_GHZ3boss-off_6E4A
		dc.w Resize_GHZ3end-off_6E4A
; ===========================================================================

Resize_GHZ3main:
		move.w	#$300,($FFFFF726).w
		cmpi.w	#$380,($FFFFF700).w
		blo.s	locret_6E96
		move.w	#$310,($FFFFF726).w
		cmpi.w	#$960,($FFFFF700).w
		blo.s	locret_6E96
		cmpi.w	#$280,($FFFFF704).w
		blo.s	loc_6E98
		move.w	#$400,($FFFFF726).w
		cmpi.w	#$1380,($FFFFF700).w
		bhs.s	loc_6E8E
		move.w	#$4C0,($FFFFF726).w
		move.w	#$4C0,($FFFFF72E).w

loc_6E8E:
		cmpi.w	#$1700,($FFFFF700).w
		bhs.s	loc_6E98

locret_6E96:
		rts
; ===========================================================================

loc_6E98:
		move.w	#$300,($FFFFF726).w
		addq.b	#2,($FFFFF742).w
		rts
; ===========================================================================

Resize_GHZ3boss:
		cmpi.w	#$960,($FFFFF700).w
		bhs.s	loc_6EB0
		subq.b	#2,($FFFFF742).w

loc_6EB0:
		cmpi.w	#$2960,($FFFFF700).w
		blo.s	locret_6EE8
		bsr.w	SingleObjLoad
		bne.s	loc_6ED0
		move.b	#$3D,(a1)	; load GHZ boss	object
		move.w	#$2A60,8(a1)
		move.w	#$280,$C(a1)

loc_6ED0:
		jsr	PlayBossMusic	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#5,d0
		jmp	LoadPLC		; load boss patterns
; ===========================================================================
Resize_LZ6end:
		jsr	Resumemusic
		move.b	#0,Hacky_Mode.w
		move.w	($FFFFF700).w,($FFFFF72A).w

Resize_GHZ3end:
		move.w	($FFFFF700).w,($FFFFF728).w
locret_6EE8:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Labyrinth Zone dynamic screen	resizing
; ---------------------------------------------------------------------------

Resize_LZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_LZx(pc,d0.w),d0
		jmp	Resize_LZx(pc,d0.w)
; ===========================================================================
Resize_LZx:	dc.w Resize_LZ1-Resize_LZx
		dc.w Resize_LZ2-Resize_LZx
		dc.w Resize_LZ3-Resize_LZx
		dc.w Resize_LZ4-Resize_LZx
		dc.w Resize_LZ1-Resize_LZx
		dc.w Resize_LZ6-Resize_LZx
		dc.w Resize_LZ1-Resize_LZx
		dc.w Resize_LZ1-Resize_LZx
; ===========================================================================
Resize_LZ6:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	.i(pc,d0.w),d0
		jmp	.i(pc,d0.w)
; ===========================================================================
.i		dc.w Resize_LZ6LoadBoss-.i
		dc.w Resize_LZ6Wait-.i
		dc.w Resize_LZ6Delay-.i
		dc.w Resize_LZ6Boss-.i
		dc.w Resize_LZ6end-.i

Resize_LZ6LoadBoss:
		move.w	#$40,$FFFFF72A.w	; scroll the stage
		move.w	#$330,$FFFFF726.w	; scroll the stage
		addq.b	#2,$FFFFF743.w
		cmpi.b	#4,$FFFFF743.w
		bne.w	locret_6F8C

		jsr	ClearPLC
		bsr.w	SingleObjLoad
		bne.s	.noLoad
		move.b	#LZ6_Boss_ID,(a1)	; load GHZ boss	object
		move.w	#LZ6_Boss_SP_X,X_Pos(a1)
		move.w	#LZ6_Boss_SP_Y,Y_Pos(a1)

.noLoad		jsr	PlayBossMusic	; play boss music
		move.b	#2,$FFFFF742.w
		moveq	#5,d0
		jmp	LoadPLC		; load boss patterns

Resize_LZ6Delay:
		subq.b	#4,$FFFFF743.w
		bpl.s	Resize_LZ6Boss
		move.b	#1,Dirty_Flag.w
		addq.b	#2,$FFFFF742.w

Resize_LZ6Boss:
		lea	Object_RAM,a0
		lea	Object_RAM,a2

		bset	#3,($FFFFF754).w	; tell we are scrolling forwards
		bclr	#0,Status(a0)
		bclr	#0,Render_Flags(a0)
		cmpi.w	#LZ6_Boss_SonMinSpeed,X_Vel(a0)
		bge.s	.in
		move.w	#LZ6_Boss_SonMinSpeed,X_Vel(a0)

.in		cmpi.w	#LZ6_Boss_SonMinSpeed,Inertia(a0)
		bge.s	.skip
		move.w	#LZ6_Boss_SonMinSpeed,Inertia(a0)

.skip		move.w	X_Pos(a0),d0
		sub.w	$FFFFF700.w,d0
		subi.w	#$A0,d0
		bmi.s	.Force

		cmpi.w	#6,d0
		blt.s	.c

		moveq	#6,d0
.c		add.w	d0,$FFFFF728.w

.Force		move.w	$FFFFF728.w,$FFFFF700.w; scroll the stage

.cont		addi.w	#LZ6_Boss_ScrollSpeed,$FFFFF728.w; scroll the stage
		addi.w	#LZ6_Boss_ScrollSpeed-1,$FFFFF708.w; scroll the stage
		andi.w	#$0FFF,$FFFFF708.w		; wrap by the size of plane B

.and		cmp.w	#LZ6_Boss_Pos_Right+$20,$FFFFF728.w
		bls.s	.rts
		andi.w	#LZ6_Boss_Pos_Right,$FFFFF728.w	; wrap by the size of the arena
		subi.w	#LZ6_Boss_Pos_Right,X_Pos(a0)
		move.l	ShakeOffset.w,a1
		subi.w	#LZ6_Boss_Pos_Right,Boss_X(a1)

.rts		move.w	$FFFFF728.w,d0
		cmp.w	X_Pos(a0),d0
		bls.s	.nop

		btst	#7,Status(a0)	; kill sonic if he is stuck in a kill tag
		beq.s	.nop
		btst	#3,Status(a0)	; kill sonic if he is stuck in a kill tag
		bne.s	.nop


.ye		jsr	KillSonic

.nop		move.w	$FFFFF728.w,d0
		addi.w	#$10,d0
		cmp.w	X_Pos(a0),d0
		bls.s	.n
		move.w	d0,X_Pos(a0)

.n		bclr	#3,Status(a0)
		bclr	#7,Status(a0)
		rts

Resize_LZ4:
		cmpi.w	#$D00,($FFFFF700).w
		blo.s	locret_6F8C
		cmpi.w	#$18,($FFFFD00C).w ; has Sonic reached the top of the level?
		bhs.s	locret_6F8C	; if not, branch
		sf	($FFFFFE30).w
		move.w	#1,($FFFFFE02).w ; restart level
		move.w	#$502,($FFFFFE10).w ; set level	number to 0502 (FZ)
		move.b	#1,($FFFFF7C8).w ; freeze Sonic
		rts

Resize_LZ6Wait:
locret_6F8C:
Resize_LZ1:
		rts

Resize_LZ2:
		cmpi.w	#LZ6_Boss_Cut_X,($FFFFF700).w
		blo.s	locret_6F8C
		move.b	#5,$FFFFFE11.w	; set act ID
		move.b	#0,$FFFFFE30.w	; clear lamppost counter
		subi.w	#LZ6_Boss_Cut_X,Object_RAM+X_Pos.w
		subi.w	#LZ6_Boss_Cut_X,$FFFFF700.w
		move.b	#0,$FFFFF76C.w
		move.w	#LZ6_Water_UpY,$FFFFF64A.w
		jmp	LevelLayoutLoad
; ===========================================================================

Resize_LZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	.i(pc,d0.w),d0
		jmp	.i(pc,d0.w)
; ===========================================================================
.i		dc.w .0-.i
		dc.w locret_6F62-.i
		dc.w Resize_MZ2End-.i

.0		tst.b	($FFFFF7EF).w				; has switch $F	been pressed?
		beq.s	loc_6F28				; if not, branch
		cmp.l	#Level_LZ3_WALL,Layout_Data		; MJ: is it already set to wall version?
		beq.s	loc_6F28				; MJ: if so, branch to skip
		move.l	#Level_LZ3_WALL,Layout_Data		; MJ: Set wall version of act 3's layout to be read
		move.w	#$B7,d0
		jsr	PlaySound ; play rumbling sound

loc_6F28:
		cmpi.w	#$1CA0,($FFFFF700).w
		blo.s	locret_6F62
		cmpi.w	#$600,($FFFFF704).w
		bhs.s	locret_6F62
		jsr	SingleObjLoad
		bne.s	loc_6F4A
		move.b	#$77,(a1)	; load LZ boss object

loc_6F4A:
		jsr	PlayBossMusic	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#5,d0
		jmp	LoadPLC		; load boss patterns
; ===========================================================================

locret_6F62:
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Marble Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_MZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_MZx(pc,d0.w),d0
		jmp	Resize_MZx(pc,d0.w)
; ===========================================================================
Resize_MZx:	dc.w Resize_MZ1-Resize_MZx
		dc.w Resize_MZ2-Resize_MZx
		dc.w Resize_MZ3-Resize_MZx
		dc.w locret_6FE8-Resize_MZx
		dc.w locret_6FE8-Resize_MZx
		dc.w locret_6FE8-Resize_MZx
		dc.w locret_6FE8-Resize_MZx
		dc.w locret_6FE8-Resize_MZx
; ===========================================================================

Resize_MZ1:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_6FB2(pc,d0.w),d0
		jmp	off_6FB2(pc,d0.w)
; ===========================================================================
off_6FB2:	dc.w loc_6FBA-off_6FB2
		dc.w loc_6FEA-off_6FB2
		dc.w loc_702E-off_6FB2
		dc.w loc_7050-off_6FB2
; ===========================================================================

loc_6FBA:
		move.w	#$1D0,($FFFFF726).w
		cmpi.w	#$700,($FFFFF700).w
		blo.s	locret_6FE8
		move.w	#$220,($FFFFF726).w
		cmpi.w	#$D00,($FFFFF700).w
		blo.s	locret_6FE8
		move.w	#$340,($FFFFF726).w
		cmpi.w	#$340,($FFFFF704).w
		blo.s	locret_6FE8
		addq.b	#2,($FFFFF742).w

locret_6FE8:
		rts
; ===========================================================================

loc_6FEA:
		cmpi.w	#$340,($FFFFF704).w
		bhs.s	loc_6FF8
		subq.b	#2,($FFFFF742).w
		rts
; ===========================================================================

loc_6FF8:
		move.w	#0,($FFFFF72C).w
		cmpi.w	#$E00,($FFFFF700).w
		bhs.s	locret_702C
		move.w	#$340,($FFFFF72C).w
		move.w	#$340,($FFFFF726).w
		cmpi.w	#$A90,($FFFFF700).w
		bhs.s	locret_702C
		move.w	#$500,($FFFFF726).w
		cmpi.w	#$370,($FFFFF704).w
		blo.s	locret_702C
		addq.b	#2,($FFFFF742).w

locret_702C:
		rts
; ===========================================================================

loc_702E:
		cmpi.w	#$370,($FFFFF704).w
		bhs.s	loc_703C
		subq.b	#2,($FFFFF742).w
		rts
; ===========================================================================

loc_703C:
		cmpi.w	#$500,($FFFFF704).w
		blo.s	locret_704E
		move.w	#$500,($FFFFF72C).w
		addq.b	#2,($FFFFF742).w

locret_704E:
		rts
; ===========================================================================

loc_7050:
		cmpi.w	#$E70,($FFFFF700).w
		blo.s	locret_7072
		move.w	#0,($FFFFF72C).w
		move.w	#$500,($FFFFF726).w
		cmpi.w	#$1430,($FFFFF700).w
		blo.s	locret_7072
		move.w	#$210,($FFFFF726).w

locret_7072:
		rts
; ===========================================================================

Resize_MZ2:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	.i(pc,d0.w),d0
		jmp	.i(pc,d0.w)
; ===========================================================================
.i		dc.w Resize_MZ2Main-.i
		dc.w Resize_MZ2Boss-.i
		dc.w Resize_MZ2End-.i
; ===========================================================================

Resize_MZ2Boss:
		jsr	ShakeScreen
		move.w	ShakeOffset.w,d0
		add.w	d0,$FFFFF704.w

Resize_MZ2End:
		move.w	($FFFFF700).w,($FFFFF728).w
locret_7088:
		rts

Resize_MZ2Main:
		move.w	#$520,($FFFFF726).w
		cmpi.w	#$1710,($FFFFF700).w
		blo.s	locret_7088
		cmpi.w	#MZ2_Boss_Pos_Up,Object_RAM+Y_Pos.w
		bge.s	.loadBoss
		move.w	#$200,($FFFFF726).w
		cmpi.w	#MZ2_Boss_Pos_Left-2,($FFFFF700).w
		blo.s	locret_7088
		moveq	#$E,d0
		jsr	LoadPLC		; load boss patterns

.loadBoss	move.w	#MZ2_Boss_Pos_Left,($FFFFF700).w
		move.w	#MZ2_Boss_Pos_Left,($FFFFF728).w
		move.w	#MZ2_Boss_Pos_Left,($FFFFF72A).w
	;	move.w	#$3C0,($FFFFF726).w
	;	move.w	#$390,($FFFFF72C).w
		bsr.w	SingleObjLoad
		bne.s	.noLoad

		move.b	#MZ2_Boss_ID,(a1)	; load GHZ boss	object
		move.w	#MZ2_Boss_SP_X,X_Pos(a1)
		move.w	#MZ2_Boss_SP_Y,Y_Pos(a1)

		cmpi.w	#MZ2_Boss_Pos_Up,Object_RAM+Y_Pos.w
		blt.s	.noLoad
		bsr.w	SingleObjLoad
		bne.s	.noLoad

		move.b	#$37,(a1)		; load GHZ boss	object
		addq.b	#2,Routine(a1)
		move.w	Object_RAM+X_Pos.w,X_Pos(a1)
		move.w	#MZ2_Boss_Pos_Up,Y_Pos(a1)
		move.b	#8,Y_Radius(a1)
		move.b	#8,X_Radius(a1)
		move.l	#Map_obj25,Mappings_Offset(a1)
		move.w	#$27B2,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#3,Priority(a1)
		move.b	#$47,Coll(a1)
		move.b	#8,X_Visible(a1)
		move.b	#-1,($FFFFFEC6).w

.noLoad		addq.b	#2,$FFFFF742.w
		jmp	PlayBossMusic	; play boss music
; ===========================================================================

Resize_MZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_7098(pc,d0.w),d0
		jmp	off_7098(pc,d0.w)
; ===========================================================================
off_7098:	dc.w Resize_MZ3boss-off_7098
		dc.w Resize_MZ3end-off_7098
; ===========================================================================

Resize_MZ3boss:
		move.w	#$720,($FFFFF726).w
		cmpi.w	#$15A0,($FFFFF700).w
		blo.s	locret_70E8
		move.w	#$210,($FFFFF726).w
		cmpi.w	#$17F0,($FFFFF700).w
		blo.s	locret_70E8
		bsr.w	SingleObjLoad
		bne.s	loc_70D0
		move.b	#$73,(a1)	; load MZ boss object
		move.w	#$19F0,X_pos(a1)
		move.w	#$22C,Y_Pos(a1)

loc_70D0:
		jsr	PlayBossMusic	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#5,d0
		jmp	LoadPLC		; load boss patterns
; ===========================================================================

Resize_MZ3end:
Resize_SLZ3end:
		move.w	($FFFFF700).w,($FFFFF728).w
locret_70E8:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Star Light Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_SLZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_SLZx(pc,d0.w),d0
		jmp	Resize_SLZx(pc,d0.w)
; ===========================================================================
Resize_SLZx:	dc.w Resize_SLZ12-Resize_SLZx
		dc.w Resize_SLZ2-Resize_SLZx
		dc.w Resize_SLZ3-Resize_SLZx
		dc.w Resize_SLZ12-Resize_SLZx
		dc.w Resize_SLZ12-Resize_SLZx
		dc.w Resize_SLZ12-Resize_SLZx
		dc.w Resize_SLZ12-Resize_SLZx
; ===========================================================================

Resize_SLZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_7118(pc,d0.w),d0
		jmp	off_7118(pc,d0.w)
; ===========================================================================
off_7118:	dc.w Resize_SLZ3main-off_7118
		dc.w Resize_SLZ3boss-off_7118
		dc.w Resize_SLZ3end-off_7118
; ===========================================================================

Resize_SLZ2:
		tst.b	$FFFFF742.w
		bmi.s	Resize_SLZ3end
		cmpi.w	#SLZ2_Boss_Pos_Left,$FFFFF700.w
		blo.s	Resize_SLZ12
		move.w	#SLZ2_Boss_Pos_Up,$FFFFF726.w
		move.b	#-2,$FFFFF742.w

		bsr.w	SingleObjLoad
		bne.s	.next
		move.b	#SLZ2_Boss_ID,(a1)	; load SLZ boss object
		move.w	#SLZ2_Boss_SP_X,X_pos(a1)
		move.w	#SLZ2_Boss_SP_Y,Y_Pos(a1)

.next		jsr	PlayBossMusic		; play boss music
		move.b	#1,$FFFFF7AA.w		; lock screen
		moveq	#5,d0
		jmp	LoadPLC			; load boss patterns
; ===========================================================================

Resize_SLZ3main:
		move.w	$FFFFF700.w,d0
		moveq	#0,d1
		move.b	ExtCam_pos,d1	; put the stuff in d1
		ext.w	d1		; extend to work (fixes issues for negative values)
		sub.w	d1,d0		; add to d0 (screen position)
		cmpi.w	#$1E70,d0
		blo.s	locret_7130
		cmpi.w	#$1E70,$FFFFF700.w
		blo.s	locret_7130
		move.w	#$210,($FFFFF726).w
		addq.b	#2,($FFFFF742).w

Resize_SLZ12:
locret_715C:
locret_7130:
		rts

Resize_SLZ3boss:
		cmpi.w	#$2000,($FFFFF700).w
		blo.s	locret_715C
		bsr.w	SingleObjLoad
		bne.s	loc_7144
		move.b	#$7A,(a1)	; load SLZ boss	object

loc_7144:
		jsr	PlayBossMusic	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#5,d0
		jmp	LoadPLC		; load boss patterns
; ===========================================================================
; ---------------------------------------------------------------------------
; Spring Yard Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_SYZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_SYZx(pc,d0.w),d0
		jmp	Resize_SYZx(pc,d0.w)
; ===========================================================================
Resize_SYZx:	dc.w Resize_SYZ1-Resize_SYZx
		dc.w Resize_SYZ2-Resize_SYZx
		dc.w Resize_SYZ3-Resize_SYZx
		dc.w Resize_SYZ1-Resize_SYZx
		dc.w Resize_SYZ1-Resize_SYZx
		dc.w Resize_SYZ1-Resize_SYZx
		dc.w Resize_SYZ1-Resize_SYZx
		dc.w Resize_SYZ1-Resize_SYZx
; ===========================================================================
Resize_SYZ2end:
		jsr	ShakeScreen
		move.w	ShakeOffset.w,d0
		add.w	d0,$FFFFF704.w
		move.w	($FFFFF700).w,($FFFFF728).w
		move.w	VScroll_RAM.w,$FFFFF70C.w

		cmpi.w	#$514,$FFFFF704.w
		bls.s	.rts
		move.w	#$512,$FFFFF704.w

.rts		rts

Resize_SYZ2:
		tst.b	($FFFFF742).w
		bmi	Resize_SYZ2end
		move.w	#$520,($FFFFF726).w

		cmpi.w	#SYZ2_Boss_Pos_Left,($FFFFF700).w
		blo.s	locret_71A2
		bsr.w	SingleObjLoad
		bne.s	Resize_SYZ1

		move.b	#SYZ2_Boss_ID,(a1)	; load GHZ boss	object
		move.w	#SYZ2_Boss_SP_X,X_Pos(a1)
		move.w	#SYZ2_Boss_SP_Y,Y_Pos(a1)

		move.b	#-1,($FFFFF742).w
		move.w	#$510,($FFFFF726).w
		move.w	$FFFFF70C.w,VScroll_RAM.w
		jsr	PlayBossMusic	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen

		moveq	#0,d0
		move.b	$FFFFFE10,d0
		lsl.w	#2,d0
		addi.w	#Misc_PLC+3,d0
		jsr	LoadPLC	; load extra boss things
		moveq	#5,d0
		jmp	LoadPLC		; load boss patterns

; ===========================================================================

Resize_SYZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_71B2(pc,d0.w),d0
		jmp	off_71B2(pc,d0.w)
; ===========================================================================
off_71B2:	dc.w Resize_SYZ3main-off_71B2
		dc.w Resize_SYZ3boss-off_71B2
		dc.w Resize_SYZ3end-off_71B2
; ===========================================================================

Resize_SYZ3main:
		cmpi.w	#$2AC0,($FFFFF700).w
		blo.s	locret_71CE
		bsr.w	SingleObjLoad
		bne.s	locret_71CE
		move.b	#$76,(a1)	; load blocks that boss	picks up
		addq.b	#2,($FFFFF742).w

Resize_SYZ1:
locret_71A2:
locret_71CE:
		rts
; ===========================================================================

Resize_SYZ3boss:
		cmpi.w	#$2C00,($FFFFF700).w
		blo.s	locret_7200
		move.w	#$4CC-$1C,($FFFFF726).w
		bsr.w	SingleObjLoad
		bne.s	loc_71EC
		move.b	#$75,(a1)	; load SYZ boss	object
		addq.b	#2,($FFFFF742).w

loc_71EC:
		jsr	PlayBossMusic	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		moveq	#5,d0
		jmp	LoadPLC		; load boss patterns
; ===========================================================================

Resize_SYZ3end:
		move.w	($FFFFF700).w,($FFFFF728).w

locret_7200:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Scrap	Brain Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_SBZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_SBZx(pc,d0.w),d0
		jmp	Resize_SBZx(pc,d0.w)
; ===========================================================================
Resize_SBZx:	dc.w Resize_SBZ1-Resize_SBZx
		dc.w Resize_SBZ2-Resize_SBZx
		dc.w Resize_FZ-Resize_SBZx
		dc.w locret_7242-Resize_SBZx
		dc.w locret_7242-Resize_SBZx
		dc.w locret_7242-Resize_SBZx
		dc.w locret_7242-Resize_SBZx
		dc.w locret_7242-Resize_SBZx
; ===========================================================================

Resize_SBZ1:
		move.w	#$720,($FFFFF726).w
		cmpi.w	#$1880,($FFFFF700).w
		blo.s	locret_7242
		move.w	#$620,($FFFFF726).w
		cmpi.w	#$2000,($FFFFF700).w
		blo.s	locret_7242
		move.w	#$2A0,($FFFFF726).w

locret_7242:
		rts
; ===========================================================================

Resize_SBZ2:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_7252(pc,d0.w),d0
		jmp	off_7252(pc,d0.w)
; ===========================================================================
off_7252:	dc.w Resize_SBZ2main-off_7252
		dc.w Resize_SBZ2boss-off_7252
		dc.w Resize_SBZ2boss2-off_7252
		dc.w Resize_SBZ2end-off_7252
; ===========================================================================

Resize_SBZ2main:
		move.w	#$800,($FFFFF726).w
		cmpi.w	#$1800,($FFFFF700).w
		blo.s	locret_727A
		move.w	#$510,($FFFFF726).w
		cmpi.w	#$1E00,($FFFFF700).w
		blo.s	locret_727A
		addq.b	#2,($FFFFF742).w

locret_727A:
locret_7298:
		rts
; ===========================================================================

Resize_SBZ2boss:
		cmpi.w	#$1EB0,($FFFFF700).w
		blo.s	locret_7298
		bsr.w	SingleObjLoad
		bne.s	locret_7298
		move.b	#$83,(a1)	; load collapsing block	object
		addq.b	#2,($FFFFF742).w
		moveq	#11,d0
		jmp	LoadPLC		; load SBZ2 Eggman patterns
; ===========================================================================

Resize_SBZ2boss2:
		cmpi.w	#$1F60,($FFFFF700).w
		blo.s	loc_72B6
		bsr.w	SingleObjLoad
		bne.s	loc_72B0
		move.b	#$82,(a1)	; load SBZ2 Eggman object
		addq.b	#2,($FFFFF742).w

loc_72B0:
		move.b	#1,($FFFFF7AA).w ; lock	screen

loc_72B6:
		bra.s	loc_72C2
; ===========================================================================

Resize_SBZ2end:
		cmpi.w	#$2050,($FFFFF700).w
		bhs.s	locret_7322

Resize_FZend2:
loc_72C2:
		move.w	($FFFFF700).w,($FFFFF728).w
locret_7322:
Resize_Ending:
		rts
; ===========================================================================

Resize_FZ:
		jsr	ShakeScreen
		move.w	ShakeOffset.w,d0
;		add.w	d0,$FFFFF704.w
		add.w	d0,$FFFFF704.w
		move.w	#$A0,$FFFFF70C.w	; static BG pos
		move.w	#$A0,$FFFFF714.w	; static BG pos

		move.w	#$512,d0
		sub.w	$FFFFF704.w,d0
		bpl.s	.skip
		move.w	#$510,$FFFFF704.w

.skip		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_72D8(pc,d0.w),d0
		jmp	off_72D8(pc,d0.w)
; ===========================================================================
off_72D8:	dc.w Resize_FZmain-off_72D8, Resize_FZboss-off_72D8
		dc.w Resize_FZend-off_72D8, locret_7322-off_72D8
		dc.w Resize_fz_splosions-off_72D8, Resize_Ending-off_72D8
; ===========================================================================

Resize_FZmain:
		cmpi.w	#$2148,($FFFFF700).w
		blo.s	loc_72C2
		addq.b	#2,($FFFFF742).w
		moveq	#12,d0
		jsr	LoadPLC		; load FZ boss patterns
		bra.s	loc_72C2
; ===========================================================================

Resize_FZboss:
		cmpi.w	#$2300,($FFFFF700).w
		blo.s	loc_72C2
		bsr.w	SingleObjLoad
		bne.s	loc_72C2
		move.b	#$85,(a1)	; load FZ boss object
		addq.b	#2,($FFFFF742).w
		move.b	#1,($FFFFF7AA).w ; lock	screen
		bra.s	loc_72C2
; ===========================================================================

Resize_FZend:
		cmpi.w	#$2450,($FFFFF700).w
		blo	loc_72C2
		addq.b	#2,($FFFFF742).w
		bra	loc_72C2

Resize_fz_splosions:
		move.w	($FFFFF700).w,($FFFFF728).w
		move.b	$FFFFFE0F.w,d0		; get some universal counter
		andi.b	#7,d0			; check bits 0, 1, and 2
		bne	.end			; if nonzero, branch

		move.w	#$C4,d0
		jsr	PlaySound		; play exploding bomb sound
		moveq	#1,d7
.load		jsr	SingleObjLoad		; load an object
		bne.s	.end			; if slots are used, skip code

		move.b	#$3F,(a1)		; load explosion object
		move.w	$FFFFF700.w,X_pos(a1)	;
		move.w	$FFFFF704.w,Y_Pos(a1)	; copy positions to explosion
		move.w	#$85A0,Art_Tile(a1)
		move.b	#7,Priority(a1)
		addq.b	#2,Routine(a1)
		move.l	#Map_obj3F,Mappings_Offset(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#0,Coll(a1)
		move.b	#$C,X_Visible(a1)
		move.b	#7,Anim_Dur(a1)
		move.b	#0,Anim_Frame(a1)

		jsr	RandomNumber		; generate random number
		moveq	#0,d1
		move.w	d0,d1			; copy d0 to d1
		divu.w	#224-$20,d1
		swap	d1
		add.w	#$10,d1
		add.w	d1,Y_pos(a1)		; add it to the X-position of explosion

		andi.l	#$FFF,d0
		divu.w	#320-$20,d0
		swap	d0
		add.w	#$10,d0
		add.w	d0,X_Pos(a1)		; add it to the Y-position of explosion

		dbf	d7,.load
.end		rts

; ===========================================================================
LoadNextFZPalette:
		move.w	VScroll_RAM.w,d0
		lea	.list(pc,d0.w),a1
		add.w	#32*3,VScroll_RAM.w

		lea	Palette_NCurr+32.w,a2
		moveq	#(16*3)-1,d0
		jmp	Loc_Pal

.list		incbin "pallet/sbz2_1.bin"
		incbin "pallet/sbz2_2.bin"
		incbin "pallet/sbz2_3.bin"
		incbin "pallet/sbz2_4.bin"
Pal_ow5:	incbin "pallet/sbz2_5.bin"
Pal_ow6:	incbin "pallet/sbz2_6.bin"
Pal_ow7:	incbin "pallet/sbz2_7.bin"
Pal_ow:		incbin "pallet/sbz2_8.bin"
		incbin "pallet/sbz2_8.bin"

; ===========================================================================
ToCredits:
		move.w	#7,$FFFFFE10.w
		move.w	#1,$FFFFFE02.w

	SRAMEnable
		moveq	#0,d0
		move.l	d0,$FFFFF700.w
		lea	SRAM_Start,a1
		movep.w	d0,SRAM_LastLVL(a1)
		move.l	DCL_Rings.w,d0
		movep.l	d0,SRAM_Rings(a1)
		move.l	Bought_Items.w,d0
		movep.l	d0,SRAM_Items(a1)
		move.b	Current_Character.w,SRAM_Char(a1)
		st	SRAM_GameCompl(a1)	; set game as completed
	SRAMDisable
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 02 - HPZ waterfall object
; ---------------------------------------------------------------------------

WaterFall:
		moveq	#0,d0
		move.b	routine(a0),d0
		move.w	.I(pc,d0.w),d1
		jmp	.I(pc,d1.w)
; ===========================================================================
.I		dc.w WF_Init-.I
		dc.w WF_Main-.I
		dc.w WF_ChkDel-.I
; ===========================================================================
WF_LoadWater:
		jsr	SingleObjLoad2
		bne	.rts
		move.b	#2,(a1)
		move.b	#4,routine(a1)
		move.w	x_pos(a0),x_pos(a1)
		move.w	y_pos(a0),y_pos(a1)
		move.l	#Map_WaterFall,mappings(a1)
		move.w	#$E3EB,art_tile(a1)
		move.b	#4,render_flags(a1)
		move.b	#$10,width_pixels(a1)
		move.b	#1,priority(a1)

.rts		rts
; ===========================================================================
WF_Init
		addq.b	#2,routine(a0)
		move.l	#Map_WaterFall,mappings(a0)
		move.w	#$E3EB,art_tile(a0)
		move.b	#4,render_flags(a0)
		move.b	#$10,width_pixels(a0)
		move.b	#1,priority(a0)
		move.b	#$12,mapping_frame(a0)
		bsr	WF_LoadWater
		move.b	#$A0,y_radius(a1)
		bset	#4,render_flags(a1)
		move.l	a1,off38(a0)
		move.w	y_pos(a0),off34(a0)
		move.w	y_pos(a0),off36(a0)
		cmpi.b	#$10,subtype(a0)
		blo	.1
		bsr	WF_LoadWater
		move.l	a1,off3C(a0)
		move.w	y_pos(a0),y_pos(a1)
		addi.w	#$98,y_pos(a1)

.1		moveq	#0,d1
		move.b	subtype(a0),d1
		move.w	off34(a0),d0
		subi.w	#$78,d0
		lsl.w	#4,d1
		add.w	d1,d0
		move.w	d0,y_pos(a0)
		move.w	d0,off34(a0)

WF_Main:
		movea.l	off38(a0),a1
		move.b	#$12,mapping_frame(a0)
		move.w	off34(a0),d0
		move.w	$FFFFF64A,d1
		cmp.w	d0,d1
		bhs	.2
		move.w	d1,d0

.2		move.w	d0,y_pos(a0)
		sub.w	off36(a0),d0
		addi.w	#$80,d0
		bmi	WF_NoDisplay
		lsr.w	#4,d0
		move.w	d0,d1
		cmpi.w	#$F,d0
		blo	.3
		moveq	#$F,d0

.3		move.b	d0,mapping_frame(a1)
		cmpi.b	#$10,subtype(a0)
		blo	WF_ChkDel
		movea.l	off3C(a0),a1
		subi.w	#$F,d1
		bhs	.4
		moveq	#0,d1

.4		addi.w	#$13,d1
		move.b	d1,mapping_frame(a1)
		bra	WF_ChkDel
; ===========================================================================
WF_NoDisplay:
		moveq	#$13,d0
		move.b	d0,mapping_frame(a0)
		move.b	d0,mapping_frame(a1)
		move.w	x_pos(a0),d0
		andi.w	#$FF80,d0
		sub.w	$FFFFF700,d0
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi	DeleteObject
WF_RTS		rts
; ===========================================================================
WF_ChkDel:
		move.w	x_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	$FFFFF700,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi	DeleteObject
		cmpi.b	#3,$FFFFFE11
		bne	DisplaySprite
		cmpi.b	#$12,Anim_Frame(a0)
		beq	WF_RTS
		bra	DisplaySprite

Map_WaterFall:	include	_maps/waterfall.asm
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 11 - GHZ bridge
; ---------------------------------------------------------------------------
obj11:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj11_Index(pc,d0.w),d1
		jmp	Obj11_Index(pc,d1.w)
; ===========================================================================
Obj11_Index:	dc.w Obj11_Main-Obj11_Index, Obj11_Action-Obj11_Index
		dc.w Obj11_Action2-Obj11_Index,	Obj11_Delete2-Obj11_Index
		dc.w Obj11_Delete2-Obj11_Index,	Obj11_Display2-Obj11_Index
; ===========================================================================

Obj11_Main:				; XREF: Obj11_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj11,Mappings_Offset(a0)
		move.w	#$438E,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.w	#3,Priority(a0)
		move.b	#$80,X_Visible(a0)
		move.w	Y_Pos(a0),d2
		move.w	X_Pos(a0),d3
		move.b	(a0),d4	; copy object number ($11) to d4
		lea	Subtype(a0),a2	; copy bridge subtype to a2
		moveq	#0,d1
		move.b	(a2),d1		; copy a2 to d1
		move.b	#0,(a2)+
		move.w	d1,d0
		lsr.w	#1,d0
		lsl.w	#4,d0
		sub.w	d0,d3
		subq.b	#2,d1
		blo.s	Obj11_Action

Obj11_MakeBdg:
		bsr.w	SingleObjLoad
		bne.s	Obj11_Action
		addq.b	#1,Subtype(a0)
		cmp.w	X_Pos(a0),d3
		bne.s	loc_73B8
		addi.w	#$10,d3
		move.w	d2,Y_Pos(a0)
		move.w	d2,Off3C(a0)
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		addq.b	#1,Subtype(a0)

loc_73B8:				; XREF: ROM:00007398j
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#$A,Routine(a1)
		move.b	d4,(a1)	; load bridge object (d4 = $11)
		move.w	d2,Y_Pos(a1)
		move.w	d2,Off3C(a1)
		move.w	d3,X_Pos(a1)
		move.l	#Map_obj11,Mappings_Offset(a1)
		move.w	#$438E,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#3,Priority(a1)
		move.b	#8,X_Visible(a1)
		addi.w	#$10,d3
		dbf	d1,Obj11_MakeBdg ; repeat d1 times (length of bridge)

Obj11_Action:				; XREF: Obj11_Index
		bsr.s	Obj11_Solid
		tst.b	Off3E(a0)
		beq.s	Obj11_Display
		subq.b	#4,Off3E(a0)
		bsr.w	Obj11_Bend

Obj11_Display:
		bsr.w	DisplaySprite
		bra.w	Obj11_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_Solid:				; XREF: Obj11_Action
		moveq	#0,d1
		move.b	Subtype(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		add.w	d2,d2
		lea	($FFFFD000).w,a1
		tst.w	Y_Vel(a1)
		bmi.w	locret_751E
		move.w	X_Pos(a1),d0
		sub.w	X_Pos(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		cmp.w	d2,d0
		bhs.w	locret_751E
		bra.s	Platform2
; End of function Obj11_Solid

; ---------------------------------------------------------------------------
; Platform subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PlatformObject:
		lea	($FFFFD000).w,a1
		tst.w	Y_Vel(a1)
		bmi.w	locret_751E
		move.w	X_Pos(a1),d0
		sub.w	X_Pos(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bhs.w	locret_751E

Platform2:
		move.w	Y_Pos(a0),d0
		subq.w	#8,d0

Platform3:
		move.w	Y_Pos(a1),d2
		move.b	Y_Radius(a1),d1
		ext.w	d1
		add.w	d2,d1
		addq.w	#4,d1
		sub.w	d1,d0
		bhi.w	locret_751E
		cmpi.w	#-$10,d0
		blo.w	locret_751E
		tst.b	($FFFFF7C8).w
		bmi.w	locret_751E
		cmpi.b	#6,Routine(a1)
		bhs.w	locret_751E
		add.w	d0,d2
		addq.w	#3,d2
		move.w	d2,Y_Pos(a1)
		addq.b	#2,Routine(a0)

loc_74AE:
		btst	#3,Status(a1)
		beq.s	loc_74DC
		moveq	#0,d0
		move.b	Off3D(a1),d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a2
		bclr	#3,Status(a2)
		sf	$25(a2)
		cmpi.b	#4,Routine(a2)
		bne.s	loc_74DC
		subq.b	#2,Routine(a2)

loc_74DC:
		move.w	a0,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,Off3D(a1)
		move.b	#0,$26(a1)
		move.w	#0,Y_Vel(a1)
		move.w	X_vel(a1),Inertia(a1)
		btst	#1,Status(a1)
		beq.s	loc_7512
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	Sonic_ResetOnFloor
		movea.l	(sp)+,a0

loc_7512:
		bset	#3,Status(a1)
		bset	#3,Status(a0)

locret_751E:
		rts
; End of function PlatformObject

; ---------------------------------------------------------------------------
; Sloped platform subroutine (GHZ collapsing ledges and	SLZ seesaws)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SlopeObject:				; XREF: Obj1A_Slope; Obj5E_Slope
		lea	($FFFFD000).w,a1
		tst.w	Y_Vel(a1)
		bmi.w	locret_751E
		move.w	X_Pos(a1),d0
		sub.w	X_Pos(a0),d0
		add.w	d1,d0
		bmi.s	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bhs.s	locret_751E
		btst	#0,Render_Flags(a0)
		beq.s	loc_754A
		not.w	d0
		add.w	d1,d0

loc_754A:
		lsr.w	#1,d0
		moveq	#0,d3
		move.b	(a2,d0.w),d3
		move.w	Y_Pos(a0),d0
		sub.w	d3,d0
		bra.w	Platform3
; End of function SlopeObject


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Solid:				; XREF: Obj15_SetSolid
		lea	($FFFFD000).w,a1
		tst.w	Y_Vel(a1)
		bmi.w	locret_751E
		move.w	X_Pos(a1),d0
		sub.w	X_Pos(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bhs.w	locret_751E
		move.w	Y_Pos(a0),d0
		sub.w	d3,d0
		bra.w	Platform3
; End of function Obj15_Solid

; ===========================================================================

Obj11_Action2:				; XREF: Obj11_Index
		bsr.s	Obj11_WalkOff
		bsr.w	DisplaySprite
		bra.w	Obj11_ChkDel

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk off a bridge
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_WalkOff:				; XREF: Obj11_Action2
		moveq	#0,d1
		move.b	Subtype(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		bsr.s	ExitPlatform2
		bhs.s	locret_75BE
		lsr.w	#4,d0
		move.b	d0,Off3F(a0)
		move.b	Off3E(a0),d0
		cmpi.b	#$40,d0
		beq.s	loc_75B6
		addq.b	#4,Off3E(a0)

loc_75B6:
		bsr.w	Obj11_Bend
		bsr.w	Obj11_MoveSonic

locret_75BE:
		moveq	#-1,d0
		rts
; End of function Obj11_WalkOff

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk or jump off	a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ExitPlatform:
		move.w	d1,d2

ExitPlatform2:
		add.w	d2,d2
		lea	($FFFFD000).w,a1
		btst	#1,Status(a1)
		bne.s	loc_75E0
		move.w	X_Pos(a1),d0
		sub.w	X_Pos(a0),d0
		add.w	d1,d0
		bmi.s	loc_75E0
		cmp.w	d2,d0
		blo.s	locret_75F2

loc_75E0:
		bclr	#3,Status(a1)
		move.b	#2,Routine(a0)
		bclr	#3,Status(a0)

locret_75F2:
		rts
; End of function ExitPlatform


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_MoveSonic:			; XREF: Obj11_WalkOff
		moveq	#0,d0
		move.b	Off3F(a0),d0
		move.b	Off29(a0,d0.w),d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a2
		lea	($FFFFD000).w,a1
		move.w	Y_Pos(a2),d0
		subq.w	#8,d0
		moveq	#0,d1
		move.b	Y_Radius(a1),d1
		sub.w	d1,d0
		move.w	d0,Y_Pos(a1)	; change Sonic's position on y-axis
		rts
; End of function Obj11_MoveSonic


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_Bend:				; XREF: Obj11_Action; Obj11_WalkOff
		move.b	Off3E(a0),d1
		bsr.w	CalcSine
		move.w	d0,d4
		lea	(Obj11_BendData2).l,a4
		moveq	#0,d0
		move.b	Subtype(a0),d0
		lsl.w	#4,d0
		moveq	#0,d3
		move.b	Off3F(a0),d3
		move.w	d3,d2
		add.w	d0,d3
		moveq	#0,d5
		lea	(Obj11_BendData).l,a5
		move.b	(a5,d3.w),d5
		andi.w	#$F,d3
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		lea	Off29(a0),a2

loc_765C:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		moveq	#0,d0
		move.b	(a3)+,d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	Off3C(a1),d0
		move.w	d0,Y_Pos(a1)
		dbf	d2,loc_765C
		moveq	#0,d0
		move.b	Subtype(a0),d0
		moveq	#0,d3
		move.b	Off3F(a0),d3
		addq.b	#1,d3
		sub.b	d0,d3
		neg.b	d3
		bmi.s	locret_76CA
		move.w	d3,d2
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		adda.w	d2,a3
		subq.w	#1,d2
		blo.s	locret_76CA

loc_76A4:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		moveq	#0,d0
		move.b	-(a3),d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	Off3C(a1),d0
		move.w	d0,Y_Pos(a1)
		dbf	d2,loc_76A4

locret_76CA:
		rts
; End of function Obj11_Bend

; ===========================================================================
; ---------------------------------------------------------------------------
; GHZ bridge-bending data
; (Defines how the bridge bends	when Sonic walks across	it)
; ---------------------------------------------------------------------------
Obj11_BendData:	incbin	misc\ghzbend1.bin
		even
Obj11_BendData2:incbin	misc\ghzbend2.bin
		even

; ===========================================================================

Obj11_ChkDel:				; XREF: Obj11_Display; Obj11_Action2
		move.w	X_Pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj11_DelAll
		rts
; ===========================================================================

Obj11_DelAll:				; XREF: Obj11_ChkDel
		moveq	#0,d2
		lea	Subtype(a0),a2	; load bridge length
		move.b	(a2)+,d2	; move bridge length to	d2
		subq.b	#1,d2		; subtract 1
		blo.s	Obj11_Delete

Obj11_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		cmp.w	a0,d0
		beq.s	loc_791E
		bsr.w	DeleteObject2

loc_791E:
		dbf	d2,Obj11_DelLoop ; repeat d2 times (bridge length)

Obj11_Delete:
; ===========================================================================

Obj11_Delete2:				; XREF: Obj11_Index
		bra.w	DeleteObject
; ===========================================================================

Obj11_Display2:				; XREF: Obj11_Index
		bra.w	DisplaySprite
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - GHZ	bridge
; ---------------------------------------------------------------------------
Map_obj11:
	include "_maps\obj11.asm"
Map_obj11_HPZ:
	include "_maps\obj11_HPZ.asm"
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 15 - swinging platforms (GHZ, MZ, SLZ)
;	    - spiked ball on a chain (SBZ)
; ---------------------------------------------------------------------------

Obj15:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj15_Index(pc,d0.w),d1
		jmp	Obj15_Index(pc,d1.w)
; ===========================================================================
Obj15_Index:	dc.w Obj15_Main-Obj15_Index, Obj15_SetSolid-Obj15_Index
		dc.w Obj15_Action2-Obj15_Index,	Obj15_Delete-Obj15_Index
		dc.w Obj15_Delete-Obj15_Index, Obj15_Display-Obj15_Index
		dc.w Obj15_Action-Obj15_Index
; ===========================================================================

Obj15_Main:				; XREF: Obj15_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj15,Mappings_Offset(a0) ; GHZ and MZ specific code
		move.w	#$4380,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#$18,X_Visible(a0)
		move.b	#8,Y_Radius(a0)
		move.w	Y_Pos(a0),Off38(a0)
		move.w	X_pos(a0),Off3A(a0)
		cmpi.b	#3,($FFFFFE10).w ; check if level is SLZ
		bne.s	Obj15_NotSLZ
		move.l	#Map_obj15a,Mappings_Offset(a0) ; SLZ	specific code
		move.w	#$43DC,Art_Tile(a0)
		move.b	#$20,X_Visible(a0)
		move.b	#$10,Y_Radius(a0)
		move.b	#$99,Coll(a0)

Obj15_NotSLZ:
		cmpi.b	#5,($FFFFFE10).w ; check if level is SBZ
		bne.s	Obj15_SetLength
		move.l	#Map_obj15b,Mappings_Offset(a0) ; SBZ	specific code
		move.w	#$391,Art_Tile(a0)
		move.b	#$18,X_Visible(a0)
		move.b	#$18,Y_Radius(a0)
		move.b	#$86,Coll(a0)
		move.b	#$C,Routine(a0)

Obj15_SetLength:
		move.b	0(a0),d4
		moveq	#0,d1
		lea	Subtype(a0),a2	; move chain length to a2
		move.b	(a2),d1		; move a2 to d1
		move.w	d1,-(sp)
		andi.w	#$F,d1
		move.b	#0,(a2)+
		move.w	d1,d3
		lsl.w	#4,d3
		addq.b	#8,d3
		move.b	d3,Off3C(a0)
		subq.b	#8,d3
		tst.b	Anim_Frame(a0)
		beq.s	Obj15_MakeChain
		addq.b	#8,d3
		subq.w	#1,d1

Obj15_MakeChain:
		bsr.w	SingleObjLoad
		bne.s	loc_7A92
		addq.b	#1,Subtype(a0)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#$A,Routine(a1)
		move.b	d4,(a1)		; load swinging	object
		move.l	Mappings_Offset(a0),Mappings_Offset(a1)
		move.w	Art_Tile(a0),Art_Tile(a1)
		bclr	#6,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#4,Priority(a1)
		move.b	#8,X_Visible(a1)
		move.b	#1,Anim_Frame(a1)
		move.b	d3,Off3C(a1)
		subi.b	#$10,d3
		bhs.s	loc_7A8E
		move.b	#2,Anim_Frame(a1)
		move.b	#3,Priority(a1)
		bset	#6,Art_Tile(a1)

loc_7A8E:
		dbf	d1,Obj15_MakeChain ; repeat d1 times (chain length)

loc_7A92:
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.w	#$4080,Angle(a0)
		move.w	#-$200,Off3E(a0)
		move.w	(sp)+,d1
		btst	#4,d1		; is object type $8X ?
		beq.s	loc_7AD4	; if not, branch
		move.l	#Map_obj48,Mappings_Offset(a0) ; use GHZ ball	mappings
		move.w	#$43AA,Art_Tile(a0)
		move.b	#1,Anim_Frame(a0)
		move.b	#2,Priority(a0)
		move.b	#$81,Coll(a0)	; make object hurt when	touched

loc_7AD4:
		cmpi.b	#5,($FFFFFE10).w ; is zone SBZ?
		beq.s	Obj15_Action	; if yes, branch

Obj15_SetSolid:				; XREF: Obj15_Index
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		moveq	#0,d3
		move.b	Y_Radius(a0),d3
		bsr.w	Obj15_Solid

Obj15_Action:				; XREF: Obj15_Index
		bsr.w	Obj15_Move
		bsr.w	DisplaySprite
		bra.w	Obj15_ChkDel
; ===========================================================================

Obj15_Action2:				; XREF: Obj15_Index
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		bsr.w	ExitPlatform
		move.w	X_pos(a0),-(sp)
		bsr.w	Obj15_Move
		move.w	(sp)+,d2
		moveq	#0,d3
		move.b	Y_Radius(a0),d3
		addq.b	#1,d3
		bsr.w	MvSonicOnPtfm
		bsr.w	DisplaySprite
		bra.w	Obj15_ChkDel

		rts

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's position with a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MvSonicOnPtfm:
		lea	Object_RAM,a1
		move.w	Y_Pos(a0),d0
		sub.w	d3,d0
		bra.s	MvSonic2
; End of function MvSonicOnPtfm

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's position with a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MvSonicOnPtfm2:
		lea	Object_RAM,a1
		move.w	Y_Pos(a0),d0
		subi.w	#9,d0

MvSonic2:
		tst.b	($FFFFF7C8).w
		bmi.s	locret_7B62
		cmpi.b	#6,Object_RAM+Routine
		bhs.s	locret_7B62
		tst.b	$FFFFFE08.w
		bne.s	locret_7B62
		moveq	#0,d1
		move.b	Y_Radius(a1),d1
		sub.w	d1,d0
		move.w	d0,Y_Pos(a1)
		sub.w	X_pos(a0),d2
		sub.w	d2,X_pos(a1)

locret_7B62:
		rts
; End of function MvSonicOnPtfm2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Move:				; XREF: Obj15_Action; Obj15_Action2
		move.b	($FFFFFE78).w,d1
		moveq	#$FFFFFF80,d0
		btst	#0,Status(a0)
		beq.s	loc_7B78
		neg.w	d1
		add.w	d0,d1

loc_7B78:
		bra.s	Obj15_Move2
; End of function Obj15_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj48_Move:				; XREF: Obj48_Display2
		tst.b	Off3D(a0)
		bne.s	loc_7B9C
		move.w	Off3E(a0),d0
		addq.w	#8,d0
		move.w	d0,Off3E(a0)
		add.w	d0,Angle(a0)
		cmpi.w	#$200,d0
		bne.s	loc_7BB6
		move.b	#1,Off3D(a0)
		bra.s	loc_7BB6
; ===========================================================================

loc_7B9C:
		move.w	Off3E(a0),d0
		subq.w	#8,d0
		move.w	d0,Off3E(a0)
		add.w	d0,Angle(a0)
		cmpi.w	#-$200,d0
		bne.s	loc_7BB6
		move.b	#0,Off3D(a0)

loc_7BB6:
		move.b	Angle(a0),d1
; End of function Obj48_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Move2:				; XREF: Obj15_Move; Obj48_Display
		jsr	CalcSine
		move.w	Off38(a0),d2
		move.w	Off3A(a0),d3
		lea	Subtype(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

loc_7BCE:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFD000,d4
		movea.l	d4,a1
		moveq	#0,d4
		move.b	Off3C(a1),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,Y_Pos(a1)
		move.w	d5,X_pos(a1)
		dbf	d6,loc_7BCE
		rts
; End of function Obj15_Move2

Obj15_Move3:				; XREF: Obj15_Move; Obj48_Display
		jsr	CalcSine
		move.w	Off38(a0),d2
		move.w	Off3A(a0),d3
		lea	Subtype(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6
		subq.b	#1,d6
		bra.s	loc_7BCE

Obj15_Move4:				; XREF: Obj15_Move; Obj48_Display
		move.w	Off38(a0),d2
		move.w	Off3A(a0),d3
		lea	Subtype(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

.loop		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFD000,d4
		movea.l	d4,a1
		moveq	#0,d4
		moveq	#0,d1
		move.b	Angle(a1),d1
		jsr	CalcSine
		move.b	Off3C(a1),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,Y_Pos(a1)
		move.w	d5,X_pos(a1)
		dbf	d6,.loop
		rts
; ===========================================================================

Obj15_ChkDel:				; XREF: Obj15_Action; Obj15_Action2
		move.w	Off3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj15_DelAll
		rts
; ===========================================================================

Obj15_DelAll:				; XREF: Obj15_ChkDel
		moveq	#0,d2
		lea	Subtype(a0),a2
		move.b	(a2)+,d2

Obj15_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		bsr.w	DeleteObject2
		dbf	d2,Obj15_DelLoop ; repeat for length of	chain
		rts
; ===========================================================================

Obj15_Delete:				; XREF: Obj15_Index
		bsr.w	DeleteObject
		rts
; ===========================================================================

Obj15_Display:				; XREF: Obj15_Index
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - GHZ	and MZ swinging	platforms
; ---------------------------------------------------------------------------
Map_obj15:
	include "_maps\obj15ghz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - SLZ	swinging platforms
; ---------------------------------------------------------------------------
Map_obj15a:
	include "_maps\obj15slz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 17 - helix of spikes on a pole	(GHZ)
; ---------------------------------------------------------------------------

Obj17:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj17_Index(pc,d0.w),d1
		jmp	Obj17_Index(pc,d1.w)
; ===========================================================================
Obj17_Index:	dc.w Obj17_Main-Obj17_Index
		dc.w Obj17_Action-Obj17_Index
		dc.w Obj17_Action-Obj17_Index
		dc.w Obj17_Delete-Obj17_Index
		dc.w Obj17_Display-Obj17_Index
; ===========================================================================

Obj17_Main:				; XREF: Obj17_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj17,Mappings_Offset(a0)
		move.w	#$4398,Art_Tile(a0)
		move.b	#7,Status(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#8,X_Visible(a0)
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		move.b	0(a0),d4
		lea	Subtype(a0),a2	; move helix length to a2
		moveq	#0,d1
		move.b	(a2),d1		; move a2 to d1
		move.b	#0,(a2)+
		move.w	d1,d0
		lsr.w	#1,d0
		lsl.w	#4,d0
		sub.w	d0,d3
		subq.b	#2,d1
		blo.s	Obj17_Action
		moveq	#0,d6

Obj17_MakeHelix:
		bsr.w	SingleObjLoad
		bne.s	Obj17_Action
		addq.b	#1,Subtype(a0)
		move.w	a1,d5
		subi.w	#$D000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#8,Routine(a1)
		move.b	d4,0(a1)
		move.w	d2,Y_Pos(a1)
		move.w	d3,X_pos(a1)
		move.l	Mappings_Offset(a0),Mappings_Offset(a1)
		move.w	#$4398,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#3,Priority(a1)
		move.b	#8,X_Visible(a1)
		move.b	d6,Off3E(a1)
		addq.b	#1,d6
		andi.b	#7,d6
		addi.w	#$10,d3
		cmp.w	X_pos(a0),d3
		bne.s	loc_7D78
		move.b	d6,Off3E(a0)
		addq.b	#1,d6
		andi.b	#7,d6
		addi.w	#$10,d3
		addq.b	#1,Subtype(a0)

loc_7D78:
		dbf	d1,Obj17_MakeHelix ; repeat d1 times (helix length)

Obj17_Action:				; XREF: Obj17_Index
		bsr.w	Obj17_RotateSpikes
		bsr.w	DisplaySprite
		bra.w	Obj17_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj17_RotateSpikes:			; XREF: Obj17_Action; Obj17_Display
		move.b	($FFFFFEC1).w,d0
		move.b	#0,Coll(a0)	; make object harmless
		add.b	Off3E(a0),d0
		andi.b	#7,d0
		move.b	d0,Anim_Frame(a0)	; change current frame
		bne.s	locret_7DA6
		move.b	#$84,Coll(a0)	; make object harmful

locret_7DA6:
		rts
; End of function Obj17_RotateSpikes

; ===========================================================================

Obj17_ChkDel:				; XREF: Obj17_Action
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj17_DelAll
		rts
; ===========================================================================

Obj17_DelAll:				; XREF: Obj17_ChkDel
		moveq	#0,d2
		lea	Subtype(a0),a2	; move helix length to a2
		move.b	(a2)+,d2	; move a2 to d2
		subq.b	#2,d2
		blo.s	Obj17_Delete

Obj17_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		bsr.w	DeleteObject2	; delete object
		dbf	d2,Obj17_DelLoop ; repeat d2 times (helix length)

Obj17_Delete:				; XREF: Obj17_Index
		bsr.w	DeleteObject
		rts
; ===========================================================================

Obj17_Display:				; XREF: Obj17_Index
		bsr.w	Obj17_RotateSpikes
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - helix of spikes on a pole (GHZ)
; ---------------------------------------------------------------------------
Map_obj17:
	include "_maps\obj17.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 18 - platforms	(GHZ, SYZ, SLZ)
; ---------------------------------------------------------------------------

Obj18:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj18_Index(pc,d0.w),d1
		jmp	Obj18_Index(pc,d1.w)
; ===========================================================================
Obj18_Index:	dc.w Obj18_Main-Obj18_Index
		dc.w Obj18_Solid-Obj18_Index
		dc.w Obj18_Action2-Obj18_Index
		dc.w Obj18_Delete-Obj18_Index
		dc.w Obj18_Action-Obj18_Index
; ===========================================================================

Obj18_Main:				; XREF: Obj18_Index
		addq.b	#2,Routine(a0)
		move.w	#$4000,Art_Tile(a0)
		move.l	#Map_obj18,Mappings_Offset(a0)
		move.b	#$20,X_Visible(a0)
		cmpi.b	#4,($FFFFFE10).w ; check if level is SYZ
		bne.s	Obj18_NotSYZ
		move.l	#Map_obj18a,Mappings_Offset(a0) ; SYZ	specific code
		move.b	#$20,X_Visible(a0)

Obj18_NotSYZ:
		cmpi.b	#3,($FFFFFE10).w ; check if level is SLZ
		bne.s	Obj18_NotSLZ
		move.l	#Map_obj18b,Mappings_Offset(a0) ; SLZ	specific code
		move.b	#$20,X_Visible(a0)
		move.w	#$4000,Art_Tile(a0)
		move.b	#3,Subtype(a0)

Obj18_NotSLZ:
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.w	Y_Pos(a0),Off2C(a0)
		move.w	Y_Pos(a0),Off34(a0)
		move.w	X_pos(a0),Off32(a0)
		move.w	#$80,Angle(a0)
		moveq	#0,d1
		move.b	Subtype(a0),d0
		cmpi.b	#$A,d0		; is object type $A (large platform)?
		bne.s	Obj18_SetFrame	; if not, branch
		addq.b	#1,d1		; use frame #1
		move.b	#$20,X_Visible(a0)	; set width

Obj18_SetFrame:
		move.b	d1,Anim_Frame(a0)	; set frame to d1

Obj18_Solid:				; XREF: Obj18_Index
		tst.b	Off38(a0)
		beq.s	loc_7EE0
		subq.b	#4,Off38(a0)

loc_7EE0:
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		bsr.w	PlatformObject

Obj18_Action:				; XREF: Obj18_Index
		bsr.w	Obj18_Move
		bsr.w	Obj18_Nudge
		bsr.w	DisplaySprite
		bra.w	Obj18_ChkDel
; ===========================================================================

Obj18_Action2:				; XREF: Obj18_Index
		cmpi.b	#$40,Off38(a0)
		beq.s	loc_7F06
		addq.b	#4,Off38(a0)

loc_7F06:
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		bsr.w	ExitPlatform
		move.w	X_pos(a0),-(sp)
		bsr.w	Obj18_Move
		bsr.w	Obj18_Nudge
		move.w	(sp)+,d2
		bsr.w	MvSonicOnPtfm2
		bsr.w	DisplaySprite
		bra.w	Obj18_ChkDel

		rts

; ---------------------------------------------------------------------------
; Subroutine to	move platform slightly when you	stand on it
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj18_Nudge:				; XREF: Obj18_Action; Obj18_Action2
		move.b	Off38(a0),d1
		jsr	CalcSine
		move.w	#$400,d1
		muls.w	d1,d0
		swap	d0
		add.w	Off2C(a0),d0
		move.w	d0,Y_Pos(a0)
		rts
; End of function Obj18_Nudge

; ---------------------------------------------------------------------------
; Subroutine to	move platforms
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj18_Move:				; XREF: Obj18_Action; Obj18_Action2
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj18_TypeIndex(pc,d0.w),d1
		jmp	Obj18_TypeIndex(pc,d1.w)
; End of function Obj18_Move

; ===========================================================================
Obj18_TypeIndex:dc.w Obj18_Type00-Obj18_TypeIndex, Obj18_Type01-Obj18_TypeIndex
		dc.w Obj18_Type02-Obj18_TypeIndex, Obj18_Type03-Obj18_TypeIndex
		dc.w Obj18_Type04-Obj18_TypeIndex, Obj18_Type05-Obj18_TypeIndex
		dc.w Obj18_Type06-Obj18_TypeIndex, Obj18_Type07-Obj18_TypeIndex
		dc.w Obj18_Type08-Obj18_TypeIndex, Obj18_Type00-Obj18_TypeIndex
		dc.w Obj18_Type0A-Obj18_TypeIndex, Obj18_Type0B-Obj18_TypeIndex
		dc.w Obj18_Type0C-Obj18_TypeIndex
; ===========================================================================

Obj18_Type00:
		rts			; platform 00 doesn't move
; ===========================================================================

Obj18_Type05:
		move.w	Off32(a0),d0
		move.b	Angle(a0),d1	; load platform-motion variable
		neg.b	d1		; reverse platform-motion
		addi.b	#$40,d1
		bra.s	Obj18_01_Move
; ===========================================================================

Obj18_Type01:
		move.w	Off32(a0),d0
		move.b	Angle(a0),d1	; load platform-motion variable
		subi.b	#$40,d1

Obj18_01_Move:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,X_pos(a0)	; change position on x-axis
		bra.w	Obj18_ChgMotion
; ===========================================================================

Obj18_Type0C:
		move.w	Off34(a0),d0
		move.b	($FFFFFE6C).w,d1 ; load	platform-motion	variable
		neg.b	d1		; reverse platform-motion
		addi.b	#$30,d1
		bra.s	Obj18_02_Move
; ===========================================================================

Obj18_Type0B:
		move.w	Off34(a0),d0
		move.b	($FFFFFE6C).w,d1 ; load	platform-motion	variable
		subi.b	#$30,d1
		bra.s	Obj18_02_Move
; ===========================================================================

Obj18_Type06:
		move.w	Off34(a0),d0
		move.b	Angle(a0),d1	; load platform-motion variable
		neg.b	d1		; reverse platform-motion
		addi.b	#$40,d1
		bra.s	Obj18_02_Move
; ===========================================================================

Obj18_Type02:
		move.w	Off34(a0),d0
		move.b	Angle(a0),d1	; load platform-motion variable
		subi.b	#$40,d1

Obj18_02_Move:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,Off2C(a0)	; change position on y-axis
		bra.w	Obj18_ChgMotion
; ===========================================================================

Obj18_Type03:
		tst.w	Off3A(a0)		; is time delay	set?
		bne.s	Obj18_03_Wait	; if yes, branch
		btst	#3,Status(a0)	; is Sonic standing on the platform?
		beq.s	Obj18_03_NoMove	; if not, branch
		move.w	#30,Off3A(a0)	; set time delay to 0.5	seconds

Obj18_03_NoMove:
		rts
; ===========================================================================

Obj18_03_Wait:
		subq.w	#1,Off3A(a0)	; subtract 1 from time
		bne.s	Obj18_03_NoMove	; if time is > 0, branch
		move.w	#32,Off3A(a0)
		addq.b	#1,Subtype(a0)	; change to type 04 (falling)
		rts
; ===========================================================================

Obj18_Type04:
		tst.w	Off3A(a0)
		beq.s	loc_8048
		subq.w	#1,Off3A(a0)
		bne.s	loc_8048
		btst	#3,Status(a0)
		beq.s	loc_8042
		bset	#1,Status(a1)
		bclr	#3,Status(a1)
		move.b	#2,Routine(a1)
		bclr	#3,Status(a0)
		sf	Routine2(a0)
		move.w	Y_Vel(a0),Y_Vel(a1)

loc_8042:
		move.b	#8,Routine(a0)

loc_8048:
		move.l	Off2C(a0),d3
		move.w	Y_Vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d3,Off2C(a0)
		addi.w	#$38,Y_Vel(a0)
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	Off2C(a0),d0
		bhs.s	locret_8074
		move.b	#6,Routine(a0)

locret_8074:
		rts
; ===========================================================================

Obj18_Type07:
		tst.w	Off3A(a0)		; is time delay	set?
		bne.s	Obj18_07_Wait	; if yes, branch
		lea	($FFFFF7E0).w,a2 ; load	switch statuses
		moveq	#0,d0
		move.b	Subtype(a0),d0	; move object type ($x7) to d0
		lsr.w	#4,d0		; divide d0 by 8, round	down
		tst.b	(a2,d0.w)	; has switch no. d0 been pressed?
		beq.s	Obj18_07_NoMove	; if not, branch
		move.w	#60,Off3A(a0)	; set time delay to 1 second

Obj18_07_NoMove:
		rts
; ===========================================================================

Obj18_07_Wait:
		subq.w	#1,Off3A(a0)	; subtract 1 from time delay
		bne.s	Obj18_07_NoMove	; if time is > 0, branch
		addq.b	#1,Subtype(a0)	; change to type 08
		rts
; ===========================================================================

Obj18_Type08:
		subq.w	#2,Off2C(a0)	; move platform	up
		move.w	Off34(a0),d0
		subi.w	#$200,d0
		cmp.w	Off2C(a0),d0	; has platform moved $200 pixels?
		bne.s	Obj18_08_NoStop	; if not, branch
		sf	Subtype(a0)		; change to type 00 (stop moving)

Obj18_08_NoStop:
		rts
; ===========================================================================

Obj18_Type0A:
		move.w	Off34(a0),d0
		move.b	Angle(a0),d1	; load platform-motion variable
		subi.b	#$40,d1
		ext.w	d1
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,Off2C(a0)	; change position on y-axis

Obj18_ChgMotion:
		move.b	($FFFFFE78).w,Angle(a0) ;	update platform-movement variable
		rts
; ===========================================================================

Obj18_ChkDel:				; XREF: Obj18_Action; Obj18_Action2
		move.w	Off32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj18_Delete
		rts
; ===========================================================================

Obj18_Delete:				; XREF: Obj18_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - unused
; ---------------------------------------------------------------------------
Map_obj18x:
	include "_maps\obj18x.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - GHZ	platforms
; ---------------------------------------------------------------------------
Map_obj18:
	include "_maps\obj18ghz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - SYZ	platforms
; ---------------------------------------------------------------------------
Map_obj18a:
	include "_maps\obj18syz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - SLZ	platforms
; ---------------------------------------------------------------------------
Map_obj18b:
	include "_maps\obj18slz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1A - GHZ collapsing ledge
; ---------------------------------------------------------------------------

Obj1A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj1A_Index(pc,d0.w),d1
		jmp	Obj1A_Index(pc,d1.w)
; ===========================================================================
Obj1A_Index:	dc.w Obj1A_Main-Obj1A_Index, Obj1A_ChkTouch-Obj1A_Index
		dc.w Obj1A_Touch-Obj1A_Index, Obj1A_Display-Obj1A_Index
		dc.w Obj1A_Delete-Obj1A_Index, Obj1A_WalkOff-Obj1A_Index
; ===========================================================================

Obj1A_Main:				; XREF: Obj1A_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj1A,Mappings_Offset(a0)
		move.l	#Obj53_Data1,Off34(a0)
		move.l	#Obj1A_SlopeData,Off3C(a0)
		move.w	#$4000,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#7,Off38(a0)	; set time delay for collapse
		move.b	#$64,X_Visible(a0)
		move.b	Subtype(a0),Anim_Frame(a0)
		move.b	#$38,Y_Radius(a0)
		bset	#4,Render_Flags(a0)

		cmpi.b	#1,$FFFFFE10.w
		bne.s	Obj1A_ChkTouch
		move.l	#M1A_HPZ,mappings(a0)
		move.w	#$4458,art_tile(a0)
		move.b	#$30,width_pixels(a0)
                move.l	#HPZ_SlopeData,Off3C(a0)
                move.l	#HPZ_CollapseData,Off34(a0)

Obj1A_ChkTouch:				; XREF: Obj1A_Index
		tst.b	Off3A(a0)	; has Sonic touched the	platform?
		beq	Obj1A_Slope	; if not, branch
		tst.b	Off38(a0)	; has time reached zero?
		beq	Obj1A_Collapse	; if yes, branch
		subq.b	#1,Off38(a0)	; subtract 1 from time

Obj1A_Slope:
		move.w	#$30,d1
		movea.l	off3C(a0),a2
		bsr	SlopeObject
		bra	MarkObjGone
; ===========================================================================

Obj1A_Touch:				; XREF: Obj1A_Index
		tst.b	Off38(a0)
		beq	loc_847A
		move.b	#1,Off3A(a0)	; set object as	"touched"
		subq.b	#1,Off38(a0)

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj1A_WalkOff:				; XREF: Obj1A_Index
		move.w	#$30,d1
		bsr.w	ExitPlatform
		move.w	#$30,d1
		movea.l	off3C(a0),a2
		move.w	X_pos(a0),d2
		bsr	SlopeObject2
		bra	MarkObjGone
; End of function Obj1A_WalkOff

; ===========================================================================

Obj1A_Display:				; XREF: Obj1A_Index
		tst.b	Off38(a0)	; has time delay reached zero?
		beq	Obj1A_TimeZero	; if yes, branch
		tst.b	Off3A(a0)	; has Sonic touched the	object?
		bne	loc_82D0	; if yes, branch
		subq.b	#1,Off38(a0)	; subtract 1 from time
		bra	DisplaySprite
; ===========================================================================

loc_82D0:				; XREF: Obj1A_Display
		subq.b	#1,Off38(a0)
		bsr	Obj1A_WalkOff
		lea	Object_RAM,a1
		btst	#3,Status(a1)
		beq	loc_82FC
		tst.b	Off38(a0)
		bne	locret_8308
		bclr	#3,Status(a1)
		bclr	#5,Status(a1)
		move.b	#1,Anim_Restart(a1)

loc_82FC:
		move.b	#0,Off3A(a0)
		move.b	#6,Routine(a0)	; run "Obj1A_Display" routine

locret_8308:
		rts
; ===========================================================================

Obj1A_TimeZero:				; XREF: Obj1A_Display
		bsr	ObjectFall
		bsr	DisplaySprite
		tst.b	Render_Flags(a0)
		bmi.s	locret_8308

Obj1A_Delete:				; XREF: Obj1A_Index
		bra	DeleteObject

M1A_HPZ:	include _maps/HPZ_platform.asm
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 53 - collapsing floors	(MZ, SLZ, SBZ)
; ---------------------------------------------------------------------------

Obj53:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj53_Index(pc,d0.w),d1
		jmp	Obj53_Index(pc,d1.w)
; ===========================================================================
Obj53_Index:	dc.w Obj53_Main-Obj53_Index, Obj53_ChkTouch-Obj53_Index
		dc.w Obj53_Touch-Obj53_Index, Obj53_Display-Obj53_Index
		dc.w Obj53_Delete-Obj53_Index, Obj53_WalkOff-Obj53_Index
; ===========================================================================

Obj53_Main:				; XREF: Obj53_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj53,Mappings_Offset(a0)
		move.w	#$42B8,Art_Tile(a0)
		cmpi.b	#3,($FFFFFE10).w ; check if level is SLZ
		bne.s	Obj53_NotSLZ
		move.w	#$44E0,Art_Tile(a0)	; SLZ specific code
		addq.b	#2,Anim_Frame(a0)

Obj53_NotSLZ:
		cmpi.b	#5,($FFFFFE10).w ; check if level is SBZ
		blt.s	Obj53_NotSBZ
		move.w	#$43F5,Art_Tile(a0)	; SBZ specific code

Obj53_NotSBZ:
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#7,Off38(a0)
		move.b	#$44,X_Visible(a0)

Obj53_ChkTouch:				; XREF: Obj53_Index
		tst.b	Off3A(a0)		; has Sonic touched the	object?
		beq.s	Obj53_Solid	; if not, branch
		tst.b	Off38(a0)		; has time delay reached zero?
		beq.w	Obj53_Collapse	; if yes, branch
		subq.b	#1,Off38(a0)	; subtract 1 from time

Obj53_Solid:
		move.w	#$20,d1
		bsr.w	PlatformObject
		tst.b	Subtype(a0)
		bpl.s	Obj53_MarkAsGone
		btst	#3,Status(a1)
		beq.s	Obj53_MarkAsGone
		bclr	#0,Render_Flags(a0)
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		bhs.s	Obj53_MarkAsGone
		bset	#0,Render_Flags(a0)

Obj53_MarkAsGone:
		bra.w	MarkObjGone
; ===========================================================================

Obj53_Touch:				; XREF: Obj53_Index
		tst.b	Off38(a0)
		beq.w	loc_8458
		move.b	#1,Off3A(a0)	; set object as	"touched"
		subq.b	#1,Off38(a0)

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj53_WalkOff:				; XREF: Obj53_Index
		move.w	#$20,d1
		bsr.w	ExitPlatform
		move.w	X_pos(a0),d2
		bsr.w	MvSonicOnPtfm2
		bra.w	MarkObjGone
; End of function Obj53_WalkOff

; ===========================================================================

Obj53_Display:				; XREF: Obj53_Index
		tst.b	Off38(a0)		; has time delay reached zero?
		beq.s	Obj53_TimeZero	; if yes, branch
		tst.b	Off3A(a0)		; has Sonic touched the	object?
		bne.w	loc_8402	; if yes, branch
		subq.b	#1,Off38(a0)	; subtract 1 from time
		bra.w	DisplaySprite
; ===========================================================================

loc_8402:
		subq.b	#1,Off38(a0)
		bsr.w	Obj53_WalkOff
		lea	Object_RAM,a1
		btst	#3,Status(a1)
		beq.s	loc_842E
		tst.b	Off38(a0)
		bne.s	locret_843A
		bclr	#3,Status(a1)
		bclr	#5,Status(a1)
		move.b	#1,Anim_Restart(a1)

loc_842E:
		move.b	#0,Off3A(a0)
		move.b	#6,Routine(a0)	; run "Obj53_Display" routine

locret_843A:
		rts
; ===========================================================================

Obj53_TimeZero:				; XREF: Obj53_Display
		bsr.w	ObjectFall
		bsr.w	DisplaySprite
		tst.b	Render_Flags(a0)
		bpl.s	Obj53_Delete
		rts
; ===========================================================================

Obj53_Delete:				; XREF: Obj53_Index
		bsr.w	DeleteObject
		rts
; ===========================================================================

Obj53_Collapse:				; XREF: Obj53_ChkTouch
		move.b	#0,Off3A(a0)

loc_8458:				; XREF: Obj53_Touch
		lea	(Obj53_Data2).l,a4
		btst	#0,Subtype(a0)
		beq.s	loc_846C
		lea	(Obj53_Data3).l,a4

loc_846C:
		moveq	#7,d1
		addq.b	#1,Anim_Frame(a0)
		bra.s	loc_8486
; ===========================================================================

Obj1A_Collapse:				; XREF: Obj1A_ChkTouch
		move.b	#0,Off3A(a0)

loc_847A:				; XREF: Obj1A_Touch
		movea.l	Off34(a0),a4
		addq.b	#2,Anim_Frame(a0)

loc_8486:				; XREF: Obj53_Collapse
		moveq	#$FFFFFFB9,d0
		jsr	PlaySound	; play collapsing sound

loc_8486_2:
		moveq	#0,d0
		move.b	Anim_Frame(a0),d0
		add.w	d0,d0
		movea.l	Mappings_Offset(a0),a3
		adda.w	(a3,d0.w),a3
		move.b	(a3)+,d1
		subq.w	#1,d1
		bset	#5,Render_Flags(a0)
		move.b	(a0),d4
		move.b	Render_Flags(a0),d5
		movea.l	a0,a1
		bra	loc_84B2
; ===========================================================================

loc_84AA:
		bsr	SingleObjLoad
		bne	loc_84F2
		addq.w	#5,a3

loc_84B2:
		move.b	#6,Routine(a1)
		move.b	d4,(a1)
		move.l	a3,Mappings_Offset(a1)
		move.b	d5,Render_Flags(a1)
		move.l	X_pos(a0),X_pos(a1)
		move.l	Y_Pos(a0),Y_Pos(a1)
		move.w	Art_Tile(a0),Art_Tile(a1)
		move.b	Priority(a0),Priority(a1)
		move.b	X_Visible(a0),X_Visible(a1)
		move.b	(a4)+,Off38(a1)
		cmpa.l	a0,a1
		bhs	loc_84EE
		bsr	DisplaySprite2

loc_84EE:
		dbf	d1,loc_84AA

loc_84F2:
		bra	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Disintegration data for collapsing ledges (MZ, SLZ, SBZ)
; ---------------------------------------------------------------------------
Obj53_Data1:	dc.b $1C, $18, $14, $10, $1A, $16, $12,	$E, $A,	6, $18,	$14, $10, $C, 8, 4
		dc.b $16, $12, $E, $A, 6, 2, $14, $10, $C, 0
Obj53_Data2:	dc.b $1E, $16, $E, 6, $1A, $12,	$A, 2
Obj53_Data3:	dc.b $16, $1E, $1A, $12, 6, $E,	$A, 2

; ---------------------------------------------------------------------------
; Sloped platform subroutine (GHZ collapsing ledges and	MZ platforms)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SlopeObject2:				; XREF: Obj1A_WalkOff; et al
		lea	Object_RAM,a1
		btst	#3,Status(a1)
		beq.s	locret_856E
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d1,d0
		lsr.w	#1,d0
		btst	#0,Render_Flags(a0)
		beq.s	loc_854E
		not.w	d0
		add.w	d1,d0

loc_854E:
		moveq	#0,d1
		move.b	(a2,d0.w),d1
		move.w	Y_Pos(a0),d0
		sub.w	d1,d0
		moveq	#0,d1
		move.b	Y_Radius(a1),d1
		sub.w	d1,d0
		move.w	d0,Y_Pos(a1)
		sub.w	X_pos(a0),d2
		sub.w	d2,X_pos(a1)

locret_856E:
		rts
; End of function SlopeObject2

; ===========================================================================
; ---------------------------------------------------------------------------
; Collision data for GHZ collapsing ledge
; ---------------------------------------------------------------------------
Obj1A_SlopeData:
		dcb.b 8, $20
		dc.b $21, $21, $22, $22, $23, $23, $24, $24, $25, $25
		dc.b $26, $26, $27, $27, $28, $28, $29, $29, $2A, $2A
		dc.b $2B, $2B, $2C, $2C, $2D, $2D, $2E, $2E, $2F, $2F
		dcb.b 10, $30

HPZ_SlopeData:	dcb.b 48,$10

HPZ_CollapseData: dc.b $18,$1C,$20,$1E,$1A,$16,6,$E,$14,$12,$A,2
; ---------------------------------------------------------------------------
; Sprite mappings - GHZ	collapsing ledge
; ---------------------------------------------------------------------------
Map_obj1A:
	include "_maps\obj1A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - collapsing floors (MZ, SLZ,	SBZ)
; ---------------------------------------------------------------------------
Map_obj53:
	include "_maps\obj53.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1C - scenery (GHZ bridge stump, SLZ lava thrower)
; ---------------------------------------------------------------------------

Obj1C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj1C_Index(pc,d0.w),d1
		jmp	Obj1C_Index(pc,d1.w)
; ===========================================================================
Obj1C_Index:	dc.w Obj1C_Main-Obj1C_Index
		dc.w Obj1C_ChkDel-Obj1C_Index
; ===========================================================================

Obj1C_Main:				; XREF: Obj1C_Index
		addq.b	#2,Routine(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; copy object type to d0
		mulu.w	#$A,d0		; multiply by $A
		lea	Obj1C_Var(pc,d0.w),a1
		move.l	(a1)+,Mappings_Offset(a0)
		move.w	(a1)+,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	(a1)+,Anim_Frame(a0)
		move.b	(a1)+,X_Visible(a0)
		move.b	(a1)+,Priority(a0)
		move.b	(a1)+,Coll(a0)
		sf	anim(a0)

Obj1C_ChkDel:				; XREF: Obj1C_Index
		cmpi.b	#4,Subtype(a0)
		bne	.noAni
		lea	Anim_Orbs,a1
		bsr	AnimateSprite

.noAni		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Variables for	object $1C are stored in an array
; ---------------------------------------------------------------------------
Obj1C_Var:	dc.l Map_obj1C		; mappings address
		dc.w $44D8		; VRAM setting
		dc.b 0,	8, 2, 0		; frame, width,	priority, collision response
		dc.l Map_obj1C
		dc.w $44D8
		dc.b 0,	8, 2, 0
		dc.l Map_obj1C
		dc.w $44D8
		dc.b 0,	8, 2, 0
		dc.l Map_obj11
		dc.w $438E
		dc.b 1,	$10, 1,	0
		dc.l Map_Orbs		; HPZ
		dc.w $E420
		dc.b 0, 16, 0, 0


Anim_Orbs:	dc.w .-Anim_Orbs
.		dc.b 5, 0, 0, 0, 1, 2, 3, 3, 2, 1, 2, 3, 3, 1, $FF
		even
; ---------------------------------------------------------------------------
; Sprite mappings - SLZ	lava thrower
; ---------------------------------------------------------------------------
Map_obj1C:	include "_maps\obj1C.asm"
Map_Orbs:	include "_maps\Orbs.asm"
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1D - switch that activates when Sonic touches it
; (this	is not used anywhere in	the game)
; ---------------------------------------------------------------------------

Obj1D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj1D_Index(pc,d0.w),d1
		jmp	Obj1D_Index(pc,d1.w)
; ===========================================================================
Obj1D_Index:	dc.w Obj1D_Main-Obj1D_Index
		dc.w Obj1D_Action-Obj1D_Index
		dc.w Obj1D_Delete-Obj1D_Index
; ===========================================================================

Obj1D_Main:				; XREF: Obj1D_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj1D,Mappings_Offset(a0)
		move.w	#$4000,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.w	Y_Pos(a0),Off30(a0)	; save position	on y-axis
		move.b	#$10,X_Visible(a0)
		move.b	#5,Priority(a0)

Obj1D_Action:				; XREF: Obj1D_Index
		move.w	Off30(a0),Y_Pos(a0)	; restore position on y-axis
		move.w	#$10,d1
		bsr	Obj1D_ChkTouch
		beq	Obj1D_ChkDel
		addq.w	#2,Y_Pos(a0)	; move object 2	pixels
		moveq	#1,d0
		move.w	d0,($FFFFF7E0).w ; set switch 0	as "pressed"

Obj1D_ChkDel:
		bsr.w	DisplaySprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj1D_Delete
		rts
; ===========================================================================

Obj1D_Delete:				; XREF: Obj1D_Index
		bsr.w	DeleteObject
		rts
; ---------------------------------------------------------------------------
; Subroutine to	check if Sonic touches the object
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj1D_ChkTouch:				; XREF: Obj1D_Action
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d1,d0
		bmi.s	loc_8918
		add.w	d1,d1
		cmp.w	d1,d0
		bhs.s	loc_8918
		move.w	Y_Pos(a1),d2
		move.b	Y_Radius(a1),d1
		ext.w	d1
		add.w	d2,d1
		move.w	Y_Pos(a0),d0
		subi.w	#$10,d0
		sub.w	d1,d0
		bhi.s	loc_8918
		cmpi.w	#-$10,d0
		blo.s	loc_8918
		moveq	#-1,d0
		rts
; ===========================================================================

loc_8918:
		moveq	#0,d0
		rts
; End of function Obj1D_ChkTouch

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - object 1D
; ---------------------------------------------------------------------------
Map_obj1D:
	include "_maps\obj1D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2A - doors (SBZ)
; ---------------------------------------------------------------------------

Obj2A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj2A_Index(pc,d0.w),d1
		jmp	Obj2A_Index(pc,d1.w)
; ===========================================================================
Obj2A_Index:	dc.w Obj2A_Main-Obj2A_Index
		dc.w Obj2A_OpenShut-Obj2A_Index
; ===========================================================================

Obj2A_Main:				; XREF: Obj2A_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj2A,Mappings_Offset(a0)
		move.w	#$42E8,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#8,X_Visible(a0)
		move.b	#4,Priority(a0)

Obj2A_OpenShut:				; XREF: Obj2A_Index
		move.w	#$40,d1
		sf	Anim(a0)		; use "closing"	animation
		move.w	Object_RAM+X_Pos,d0
		add.w	d1,d0
		cmp.w	X_pos(a0),d0
		blo.s	Obj2A_Animate
		sub.w	d1,d0
		sub.w	d1,d0
		cmp.w	X_pos(a0),d0
		bhs.s	Obj2A_Animate
		add.w	d1,d0
		cmp.w	X_pos(a0),d0
		bhs.s	loc_899A
		btst	#0,Status(a0)
		bne.s	Obj2A_Animate
		bra.s	Obj2A_Open
; ===========================================================================

loc_899A:				; XREF: Obj2A_OpenShut
		btst	#0,Status(a0)
		beq.s	Obj2A_Animate

Obj2A_Open:				; XREF: Obj2A_OpenShut
		move.b	#1,Anim(a0)	; use "opening"	animation

Obj2A_Animate:				; XREF: Obj2A_OpenShut; loc_899A
		lea	(Ani_obj2A).l,a1
		bsr.w	AnimateSprite
		tst.b	Anim_Frame(a0)		; is the door open?
		bne.s	Obj2A_MarkAsUsed ; if yes, branch
		move.w	#$11,d1
		move.w	#$20,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject

Obj2A_MarkAsUsed:
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj2A:
	include "_anim\obj2A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - doors (SBZ)
; ---------------------------------------------------------------------------
Map_obj2A:
	include "_maps\obj2A.asm"

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj44_SolidWall:			; XREF: Obj44_Solid
		bsr.w	Obj44_SolidWall2
		beq.s	loc_8AA8
		bmi.w	loc_8AC4
		tst.w	d0
		beq.w	loc_8A92
		bmi.s	loc_8A7C
		tst.w	X_Vel(a1)
		bmi.s	loc_8A92
		bra.s	loc_8A82
; ===========================================================================

loc_8A7C:
		tst.w	X_Vel(a1)
		bpl.s	loc_8A92

loc_8A82:
		sub.w	d0,X_pos(a1)
		move.w	#0,Inertia(a1)
		move.w	#0,X_Vel(a1)

loc_8A92:
		btst	#1,Status(a1)
		bne.s	loc_8AB6
		bset	#5,Status(a1)
		bset	#5,Status(a0)
		rts
; ===========================================================================

loc_8AA8:
		btst	#5,Status(a0)
		beq.s	locret_8AC2
		move.w	#1,Anim(a1)

loc_8AB6:
		bclr	#5,Status(a0)
		bclr	#5,Status(a1)

locret_8AC2:
		rts
; ===========================================================================

loc_8AC4:
		tst.w	Y_Vel(a1)
		bpl.s	locret_8AD8
		tst.w	d3
		bpl.s	locret_8AD8
		sub.w	d3,Y_Pos(a1)
		move.w	#0,Y_Vel(a1)

locret_8AD8:
		rts
; End of function Obj44_SolidWall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj44_SolidWall2:			; XREF: Obj44_SolidWall
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d1,d0
		bmi.s	loc_8B48
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.s	loc_8B48
		move.b	Y_Radius(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	Y_Pos(a1),d3
		sub.w	Y_Pos(a0),d3
		add.w	d2,d3
		bmi.s	loc_8B48
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bhs.s	loc_8B48
		tst.b	($FFFFF7C8).w
		bmi.s	loc_8B48
		cmpi.b	#6,Object_RAM+Routine
		bhs.s	loc_8B48
		tst.b	$FFFFFE08.w
		bne.s	loc_8B48
		move.w	d0,d5
		cmp.w	d0,d1
		bhs.s	loc_8B30
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_8B30:
		move.w	d3,d1
		cmp.w	d3,d2
		bhs.s	loc_8B3C
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_8B3C:
		cmp.w	d1,d5
		bhi.s	loc_8B44
		moveq	#1,d4
		rts
; ===========================================================================

loc_8B44:
		moveq	#-1,d4
		rts
; ===========================================================================

loc_8B48:
		moveq	#0,d4
		rts
; End of function Obj44_SolidWall2

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1E - Ball Hog enemy (SBZ)
; ---------------------------------------------------------------------------

Obj1E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj1E_Index(pc,d0.w),d1
		jmp	Obj1E_Index(pc,d1.w)
; ===========================================================================
Obj1E_Index:	dc.w Obj1E_Main-Obj1E_Index
		dc.w Obj1E_Action-Obj1E_Index
; ===========================================================================

Obj1E_Main:				; XREF: Obj1E_Index
		move.b	#$13,Y_Radius(a0)
		move.b	#8,X_Radius(a0)
		move.l	#Map_obj1E,Mappings_Offset(a0)
		move.w	#$2302,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#5,Coll(a0)
		move.b	#$C,X_Visible(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_8BAC
		add.w	d1,Y_Pos(a0)
		move.w	#0,Y_Vel(a0)
		addq.b	#2,Routine(a0)

locret_8BAC:
		rts
; ===========================================================================

Obj1E_Action:				; XREF: Obj1E_Index
		lea	(Ani_obj1E).l,a1
		bsr.w	AnimateSprite
		cmpi.b	#1,Anim_Frame(a0)	; is final frame (01) displayed?
		bne.s	Obj1E_SetBall	; if not, branch
		tst.b	Off32(a0)		; is it	set to launch cannonball?
		beq.s	Obj1E_MakeBall	; if yes, branch
		bra.s	Obj1E_MarkAsGone
; ===========================================================================

Obj1E_SetBall:				; XREF: Obj1E_Action
		sf	Off32(a0)		; set to launch	cannonball

Obj1E_MarkAsGone:			; XREF: Obj1E_Action
		bra.w	MarkObjGone
; ===========================================================================

Obj1E_MakeBall:				; XREF: Obj1E_Action
		move.b	#1,Off32(a0)
		bsr.w	SingleObjLoad
		bne.s	loc_8C1A
		move.b	#$20,0(a1)	; load cannonball object ($20)
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.w	#-$100,X_Vel(a1)	; cannonball bounces to	the left
		move.w	#0,Y_Vel(a1)
		moveq	#-4,d0
		btst	#0,Status(a0)	; is Ball Hog facing right?
		beq.s	loc_8C0A	; if not, branch
		neg.w	d0
		neg.w	X_Vel(a1)		; cannonball bounces to	the right

loc_8C0A:
		add.w	d0,X_pos(a1)
		addi.w	#$C,Y_Pos(a1)
		move.b	Subtype(a0),Subtype(a1)	; copy object type from	Ball Hog

loc_8C1A:
		bra.s	Obj1E_MarkAsGone
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 20 - cannonball that Ball Hog throws (SBZ)
; ---------------------------------------------------------------------------

Obj20:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj20_Index(pc,d0.w),d1
		jmp	Obj20_Index(pc,d1.w)
; ===========================================================================
Obj20_Index:	dc.w Obj20_Main-Obj20_Index
		dc.w Obj20_Bounce-Obj20_Index
; ===========================================================================

Obj20_Main:				; XREF: Obj20_Index
		addq.b	#2,Routine(a0)
		move.b	#7,Y_Radius(a0)
		move.l	#Map_obj1E,Mappings_Offset(a0)
		move.w	#$2302,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#$87,Coll(a0)
		move.b	#8,X_Visible(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; move object type to d0
		mulu.w	#60,d0		; multiply by 60 frames	(1 second)
		move.w	d0,Off30(a0)	; set explosion	time
		move.b	#4,Anim_Frame(a0)

Obj20_Bounce:				; XREF: Obj20_Index
		jsr	ObjectFall
		tst.w	Y_Vel(a0)
		bmi.s	Obj20_ChkExplode
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	Obj20_ChkExplode
		add.w	d1,Y_Pos(a0)
		move.w	#-$300,Y_Vel(a0)
		tst.b	d3
		beq.s	Obj20_ChkExplode
		bmi.s	loc_8CA4
		tst.w	X_Vel(a0)
		bpl.s	Obj20_ChkExplode
		neg.w	X_Vel(a0)
		bra.s	Obj20_ChkExplode
; ===========================================================================

loc_8CA4:				; XREF: Obj20_Bounce
		tst.w	X_Vel(a0)
		bmi.s	Obj20_ChkExplode
		neg.w	X_Vel(a0)

Obj20_ChkExplode:			; XREF: Obj20_Bounce
		subq.w	#1,Off30(a0)	; subtract 1 from explosion time
		bpl.s	Obj20_Animate	; if time is > 0, branch
		move.b	#$3F,(a0)	; change object	to an explosion	($3F)
		move.w	#0,Art_Tile(a0)
		move.b	#0,Routine(a0)	; reset	routine	counter
		bra.w	Obj3F		; jump to explosion code
; ===========================================================================

Obj20_Animate:				; XREF: Obj20_ChkExplode
		subq.b	#1,Anim_Dur(a0)	; subtract 1 from frame	duration
		bpl.s	Obj20_Display
		move.b	#5,Anim_Dur(a0)	; set frame duration to	5 frames
		bchg	#0,Anim_Frame(a0)	; change frame

Obj20_Display:
		bsr.w	DisplaySprite
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	Y_Pos(a0),d0	; has object fallen off	the level?
		blo.w	DeleteObject	; if yes, branch
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 24 - explosion	from a destroyed monitor
; ---------------------------------------------------------------------------

Obj24:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj24_Index(pc,d0.w),d1
		jmp	Obj24_Index(pc,d1.w)
; ===========================================================================
Obj24_Index:	dc.w Obj24_Main-Obj24_Index
		dc.w Obj24_Animate-Obj24_Index
; ===========================================================================

Obj24_Main:				; XREF: Obj24_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj24,Mappings_Offset(a0)
		move.w	#$41C,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#1,Priority(a0)
		move.b	#0,Coll(a0)
		move.b	#$C,X_Visible(a0)
		move.b	#9,Anim_Dur(a0)
		move.b	#0,Anim_Frame(a0)
		move.w	#$A5,d0
		jsr	(PlaySound).l ;	play explosion sound

Obj24_Animate:				; XREF: Obj24_Index
		subq.b	#1,Anim_Dur(a0)	; subtract 1 from frame	duration
		bpl.s	Obj24_Display
		move.b	#9,Anim_Dur(a0)	; set frame duration to	9 frames
		addq.b	#1,Anim_Frame(a0)	; next frame
		cmpi.b	#4,Anim_Frame(a0)	; is the final frame (04) displayed?
		beq.w	DeleteObject	; if yes, branch

Obj24_Display:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 27 - explosion	from a destroyed enemy
; ---------------------------------------------------------------------------

Obj27:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj27_Index(pc,d0.w),d1
		jmp	Obj27_Index(pc,d1.w)
; ===========================================================================
Obj27_Index:	dc.w Obj27_LoadAnimal-Obj27_Index
		dc.w Obj27_Main-Obj27_Index
		dc.w Obj27_Animate-Obj27_Index
		dc.w Obj27_Main2-Obj27_Index
; ===========================================================================
Obj27_Main2:
		subq.b	#2,Routine(a0)
		move.l	#Map_obj27,Mappings_Offset(a0)
		move.w	#$5A0,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#1,Priority(a0)
		move.b	#0,Coll(a0)
		move.b	#$C,X_Visible(a0)
		move.b	#7,Anim_Dur(a0)		; set frame duration to	7 frames
		move.b	#2,Anim_Frame(a0)
		move.w	#$C1,d0
		jsr	PlaySound 	; play breaking enemy sound
		bra	Obj27_Animate

Obj27_LoadAnimal:				; XREF: Obj27_Index
		addq.b	#2,Routine(a0)
		bsr.w	SingleObjLoad
		bne.s	Obj27_Main
		move.b	#$28,0(a1)		; load animal object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.w	Off3E(a0),Off3E(a1)

Obj27_Main:					; XREF: Obj27_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj27,Mappings_Offset(a0)
		move.w	#$5A0,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#1,Priority(a0)
		move.b	#0,Coll(a0)
		move.b	#$C,X_Visible(a0)
		move.b	#7,Anim_Dur(a0)		; set frame duration to	7 frames
		move.b	#0,Anim_Frame(a0)
		move.w	#$C1,d0
		jsr	PlaySound	; play breaking enemy sound

Obj27_Animate:					; XREF: Obj27_Index
		subq.b	#1,Anim_Dur(a0)		; subtract 1 from frame	duration
		bpl.s	Obj27_Display
		move.b	#7,Anim_Dur(a0)		; set frame duration to	7 frames
		addq.b	#1,Anim_Frame(a0)	; next frame
		cmpi.b	#5,Anim_Frame(a0)	; is the final frame (05) displayed?
		beq.w	DeleteObject		; if yes, branch

Obj27_Display:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3F - explosion	from a destroyed boss, bomb or cannonball
; ---------------------------------------------------------------------------

Obj3F:						; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj3F_Index(pc,d0.w),d1
		jmp	Obj3F_Index(pc,d1.w)
; ===========================================================================
Obj3F_Index:	dc.w Obj3F_Main-Obj3F_Index
		dc.w Obj27_Animate-Obj3F_Index
; ===========================================================================

Obj3F_Main:				; XREF: Obj3F_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj3F,Mappings_Offset(a0)
		andi.w	#$8000,Art_Tile(a0)
		ori.w	#$5A0,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#1,Priority(a0)
		move.b	#0,Coll(a0)
		move.b	#$C,X_Visible(a0)
		move.b	#7,Anim_Dur(a0)
		move.b	#0,Anim_Frame(a0)
		move.w	#$C4,d0
		jmp	PlaySound	; play exploding bomb sound
; ===========================================================================
Ani_obj1E:
	include "_anim\obj1E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Ball Hog enemy (SBZ)
; ---------------------------------------------------------------------------
Map_obj1E:
	include "_maps\obj1E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion
; ---------------------------------------------------------------------------
Map_obj24:
	include "_maps\obj24.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion
; ---------------------------------------------------------------------------
Map_obj27:	dc.w byte_8ED0-Map_obj27, byte_8ED6-Map_obj27
		dc.w byte_8EDC-Map_obj27, byte_8EE2-Map_obj27
		dc.w byte_8EF7-Map_obj27
byte_8ED0:	dc.b 1
		dc.b $F8, 9, 0,	0, $F4
byte_8ED6:	dc.b 1
		dc.b $F0, $F, 0, 6, $F0
byte_8EDC:	dc.b 1
		dc.b $F0, $F, 0, $16, $F0
byte_8EE2:	dc.b 4
		dc.b $EC, $A, 0, $26, $EC
		dc.b $EC, 5, 0,	$2F, 4
		dc.b 4,	5, $18,	$2F, $EC
		dc.b $FC, $A, $18, $26,	$FC
byte_8EF7:	dc.b 4
		dc.b $EC, $A, 0, $33, $EC
		dc.b $EC, 5, 0,	$3C, 4
		dc.b 4,	5, $18,	$3C, $EC
		dc.b $FC, $A, $18, $33,	$FC
		even
; ---------------------------------------------------------------------------
; Sprite mappings - explosion from when	a boss is destroyed
; ---------------------------------------------------------------------------
Map_obj3F:	dc.w byte_8ED0-Map_obj3F
		dc.w byte_8F16-Map_obj3F
		dc.w byte_8F1C-Map_obj3F
		dc.w byte_8EE2-Map_obj3F
		dc.w byte_8EF7-Map_obj3F
byte_8F16:	dc.b 1
		dc.b $F0, $F, 0, $40, $F0
byte_8F1C:	dc.b 1
		dc.b $F0, $F, 0, $50, $F0
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 28 - animals
; ---------------------------------------------------------------------------

Obj28:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj28_Index(pc,d0.w),d1
		jmp	Obj28_Index(pc,d1.w)
; ===========================================================================
Obj28_Index:	dc.w Obj28_Ending-Obj28_Index, loc_912A-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_91C0-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_9184-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_91C0-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_9240-Obj28_Index
		dc.w loc_9260-Obj28_Index, loc_9260-Obj28_Index
		dc.w loc_9280-Obj28_Index, loc_92BA-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9332-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9332-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9370-Obj28_Index
		dc.w loc_92D6-Obj28_Index

Obj28_VarIndex:	dc.b 0,	5, 2, 3, 6, 3, 4, 5, 4,	1, 0, 1

Obj28_Variables:dc.w $FE00, $FC00
		dc.l Map_obj28
		dc.w $FE00, $FD00	; horizontal speed, vertical speed
		dc.l Map_obj28a		; mappings address
		dc.w $FE80, $FD00
		dc.l Map_obj28
		dc.w $FEC0, $FE80
		dc.l Map_obj28a
		dc.w $FE40, $FD00
		dc.l Map_obj28b
		dc.w $FD00, $FC00
		dc.l Map_obj28a
		dc.w $FD80, $FC80
		dc.l Map_obj28b

Obj28_EndSpeed:	dc.w $FBC0, $FC00, $FBC0, $FC00, $FBC0,	$FC00, $FD00, $FC00
		dc.w $FD00, $FC00, $FE80, $FD00, $FE80,	$FD00, $FEC0, $FE80
		dc.w $FE40, $FD00, $FE00, $FD00, $FD80,	$FC80

Obj28_EndMap:	dc.l Map_obj28a, Map_obj28a, Map_obj28a, Map_obj28, Map_obj28
		dc.l Map_obj28,	Map_obj28, Map_obj28a, Map_obj28b, Map_obj28a
		dc.l Map_obj28b

Obj28_EndVram:	dc.w $5A5, $5A5, $5A5, $553, $553, $573, $573, $585, $593
		dc.w $565, $5B3
; ===========================================================================

Obj28_Ending:				; XREF: Obj28_Index
		tst.b	Subtype(a0)	; did animal come from a destroyed enemy?
		beq.w	Obj28_FromEnemy	; if yes, branch
		moveq	#0,d0
		move.b	Subtype(a0),d0	; move object type to d0
		add.w	d0,d0		; multiply d0 by 2
		move.b	d0,Routine(a0)	; move d0 to routine counter
		subi.w	#$14,d0
		move.w	Obj28_EndVram(pc,d0.w),Art_Tile(a0)
		add.w	d0,d0
		move.l	Obj28_EndMap(pc,d0.w),Mappings_Offset(a0)
		lea	Obj28_EndSpeed(pc),a1
		move.w	(a1,d0.w),Off32(a0) ; load horizontal speed
		move.w	(a1,d0.w),X_Vel(a0)
		move.w	2(a1,d0.w),Off34(a0) ; load vertical speed
		move.w	2(a1,d0.w),Y_Vel(a0)
		move.b	#$C,Y_Radius(a0)
		move.b	#4,Render_Flags(a0)
		bset	#0,Render_Flags(a0)
		move.b	#6,Priority(a0)
		move.b	#8,X_Visible(a0)
		move.b	#7,Anim_Dur(a0)
		bra.w	DisplaySprite
; ===========================================================================

Obj28_FromEnemy:			; XREF: Obj28_Ending
		addq.b	#2,Routine(a0)
		jsr	RandomNumber
		andi.w	#1,d0
		moveq	#0,d1
		move.b	($FFFFFE10).w,d1
		add.w	d1,d1
		add.w	d0,d1
		lea	Obj28_VarIndex(pc),a1
		move.b	(a1,d1.w),d0
		move.b	d0,Off30(a0)
		lsl.w	#3,d0
		lea	Obj28_Variables(pc),a1
		adda.w	d0,a1
		move.w	(a1)+,Off32(a0)	; load horizontal speed
		move.w	(a1)+,Off34(a0)	; load vertical	speed
		move.l	(a1)+,Mappings_Offset(a0)	; load mappings
		move.w	#$580,Art_Tile(a0)	; VRAM setting for 1st animal
		btst	#0,Off30(a0)	; is 1st animal	used?
		beq.s	loc_90C0	; if yes, branch
		move.w	#$592,Art_Tile(a0)	; VRAM setting for 2nd animal

loc_90C0:
		move.b	#$C,Y_Radius(a0)
		move.b	#4,Render_Flags(a0)
		bset	#0,Render_Flags(a0)
		move.b	#6,Priority(a0)
		move.b	#8,X_Visible(a0)
		move.b	#7,Anim_Dur(a0)
		move.b	#2,Anim_Frame(a0)
		move.w	#-$400,Y_Vel(a0)
		tst.b	($FFFFF7A7).w
		bne.s	loc_911C

Obj28_Display:
		bra.w	DisplaySprite
; ===========================================================================

loc_911C:
		move.b	#$12,Routine(a0)
		clr.w	X_Vel(a0)
		bra.w	DisplaySprite
; ===========================================================================

loc_912A:				; XREF: Obj28_Index
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		bsr.w	ObjectFall
		tst.w	Y_Vel(a0)
		bmi.s	loc_9180
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_9180
		add.w	d1,Y_Pos(a0)
		move.w	Off32(a0),X_Vel(a0)
		move.w	Off34(a0),Y_Vel(a0)
		move.b	#1,Anim_Frame(a0)
		move.b	Off30(a0),d0
		add.b	d0,d0
		addq.b	#4,d0
		move.b	d0,Routine(a0)
		tst.b	($FFFFF7A7).w
		beq.s	loc_9180
		btst	#4,($FFFFFE0F).w
		beq.s	loc_9180
		neg.w	X_Vel(a0)
		bchg	#0,Render_Flags(a0)

loc_9180:
		bra.w	DisplaySprite
; ===========================================================================

loc_9184:				; XREF: Obj28_Index
		bsr.w	ObjectFall
		move.b	#1,Anim_Frame(a0)
		tst.w	Y_Vel(a0)
		bmi.s	loc_91AE
		move.b	#0,Anim_Frame(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_91AE
		add.w	d1,Y_Pos(a0)
		move.w	Off34(a0),Y_Vel(a0)

loc_91AE:
		tst.b	Subtype(a0)
		bne.s	loc_9224
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_91C0:				; XREF: Obj28_Index
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)
		tst.w	Y_Vel(a0)
		bmi.s	loc_91FC
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_91FC
		add.w	d1,Y_Pos(a0)
		move.w	Off34(a0),Y_Vel(a0)
		tst.b	Subtype(a0)
		beq.s	loc_91FC
		cmpi.b	#$A,Subtype(a0)
		beq.s	loc_91FC
		neg.w	X_Vel(a0)
		bchg	#0,Render_Flags(a0)

loc_91FC:
		subq.b	#1,Anim_Dur(a0)
		bpl.s	loc_9212
		move.b	#1,Anim_Dur(a0)
		addq.b	#1,Anim_Frame(a0)
		andi.b	#1,Anim_Frame(a0)

loc_9212:
		tst.b	Subtype(a0)
		bne.s	loc_9224
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_9224:				; XREF: Obj28_Index
		move.w	X_pos(a0),d0
		sub.w	Object_RAM+X_Pos,d0
		blo.s	loc_923C
		subi.w	#$180,d0
		bpl.s	loc_923C
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject

loc_923C:
		bra.w	DisplaySprite
; ===========================================================================

loc_9240:				; XREF: Obj28_Index
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		subq.w	#1,Off36(a0)
		bne.w	loc_925C
		move.b	#2,Routine(a0)
		move.b	#3,Priority(a0)

loc_925C:
		bra.w	DisplaySprite
; ===========================================================================

loc_9260:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bhs.s	loc_927C
		move.w	Off32(a0),X_Vel(a0)
		move.w	Off34(a0),Y_Vel(a0)
		move.b	#$E,Routine(a0)
		bra.w	loc_91C0
; ===========================================================================

loc_927C:
		bra.w	loc_9224
; ===========================================================================

loc_9280:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_92B6
		clr.w	X_Vel(a0)
		clr.w	Off32(a0)
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)
		bsr.w	loc_93C4
		bsr.w	loc_93EC
		subq.b	#1,Anim_Dur(a0)
		bpl.s	loc_92B6
		move.b	#1,Anim_Dur(a0)
		addq.b	#1,Anim_Frame(a0)
		andi.b	#1,Anim_Frame(a0)

loc_92B6:
		bra.w	loc_9224
; ===========================================================================

loc_92BA:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_9310
		move.w	Off32(a0),X_Vel(a0)
		move.w	Off34(a0),Y_Vel(a0)
		move.b	#4,Routine(a0)
		bra.w	loc_9184
; ===========================================================================

loc_92D6:				; XREF: Obj28_Index
		bsr.w	ObjectFall
		move.b	#1,Anim_Frame(a0)
		tst.w	Y_Vel(a0)
		bmi.s	loc_9310
		move.b	#0,Anim_Frame(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_9310
		not.b	$29(a0)
		bne.s	loc_9306
		neg.w	X_Vel(a0)
		bchg	#0,Render_Flags(a0)

loc_9306:
		add.w	d1,Y_Pos(a0)
		move.w	Off34(a0),Y_Vel(a0)

loc_9310:
		bra.w	loc_9224
; ===========================================================================

loc_9314:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_932E
		clr.w	X_Vel(a0)
		clr.w	Off32(a0)
		bsr.w	ObjectFall
		bsr.w	loc_93C4
		bsr.w	loc_93EC

loc_932E:
		bra.w	loc_9224
; ===========================================================================

loc_9332:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_936C
		bsr.w	ObjectFall
		move.b	#1,Anim_Frame(a0)
		tst.w	Y_Vel(a0)
		bmi.s	loc_936C
		move.b	#0,Anim_Frame(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_936C
		neg.w	X_Vel(a0)
		bchg	#0,Render_Flags(a0)
		add.w	d1,Y_Pos(a0)
		move.w	Off34(a0),Y_Vel(a0)

loc_936C:
		bra.w	loc_9224
; ===========================================================================

loc_9370:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_93C0
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)
		tst.w	Y_Vel(a0)
		bmi.s	loc_93AA
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_93AA
		not.b	$29(a0)
		bne.s	loc_93A0
		neg.w	X_Vel(a0)
		bchg	#0,Render_Flags(a0)

loc_93A0:
		add.w	d1,Y_Pos(a0)
		move.w	Off34(a0),Y_Vel(a0)

loc_93AA:
		subq.b	#1,Anim_Dur(a0)
		bpl.s	loc_93C0
		move.b	#1,Anim_Dur(a0)
		addq.b	#1,Anim_Frame(a0)
		andi.b	#1,Anim_Frame(a0)

loc_93C0:
		bra.w	loc_9224
; ===========================================================================

loc_93C4:
		move.b	#1,Anim_Frame(a0)
		tst.w	Y_Vel(a0)
		bmi.s	locret_93EA
		move.b	#0,Anim_Frame(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_93EA
		add.w	d1,Y_Pos(a0)
		move.w	Off34(a0),Y_Vel(a0)

locret_93EA:
		rts
; ===========================================================================

loc_93EC:
		bset	#0,Render_Flags(a0)
		move.w	X_pos(a0),d0
		sub.w	Object_RAM+X_Pos,d0
		bhs.s	locret_9402
		bclr	#0,Render_Flags(a0)

locret_9402:
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_9404:
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		subi.w	#$B8,d0
		rts
; End of function sub_9404

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - animals
; ---------------------------------------------------------------------------
Map_obj28:
	include "_maps\obj28.asm"

Map_obj28a:
	include "_maps\obj28a.asm"

Map_obj28b:
	include "_maps\obj28b.asm"


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1F - Crabmeat enemy (GHZ, SYZ)
; ---------------------------------------------------------------------------

Obj1F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj1F_Index(pc,d0.w),d1
		jmp	Obj1F_Index(pc,d1.w)
; ===========================================================================
Obj1F_Index:	dc.w Obj1F_Main-Obj1F_Index
		dc.w Obj1F_Action-Obj1F_Index
		dc.w Obj1F_Delete-Obj1F_Index
		dc.w Obj1F_BallMain-Obj1F_Index
		dc.w Obj1F_BallMove-Obj1F_Index
; ===========================================================================

Obj1F_Main:				; XREF: Obj1F_Index
		move.b	#$10,Y_Radius(a0)
		move.b	#8,X_Radius(a0)
		move.l	#Map_obj1F,Mappings_Offset(a0)
		move.w	#$400,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#6,Coll(a0)
		move.b	#$15,X_Visible(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_955A
		add.w	d1,Y_Pos(a0)
		move.b	d3,Angle(a0)
		move.w	#0,Y_Vel(a0)
		addq.b	#2,Routine(a0)

locret_955A:
		rts
; ===========================================================================

Obj1F_Action:				; XREF: Obj1F_Index
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj1F_Index2(pc,d0.w),d1
		jsr	Obj1F_Index2(pc,d1.w)
		lea	(Ani_obj1F).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj1F_Index2:	dc.w Obj1F_WaitFire-Obj1F_Index2
		dc.w Obj1F_WalkOnFloor-Obj1F_Index2
; ===========================================================================

Obj1F_WaitFire:				; XREF: Obj1F_Index2
		subq.w	#1,Off30(a0)	; subtract 1 from time delay
		bpl.s	locret_95B6
		tst.b	Render_Flags(a0)
		bpl.s	Obj1F_Move
		bchg	#1,Off32(a0)
		bne.s	Obj1F_MakeFire

Obj1F_Move:
		addq.b	#2,Routine2(a0)
		move.w	#127,Off30(a0)	; set time delay to approx 2 seconds
		move.w	#$80,X_Vel(a0)	; move Crabmeat	to the right
		bsr.w	Obj1F_SetAni
		addq.b	#3,d0
		move.b	d0,Anim(a0)
		bchg	#0,Status(a0)
		bne.s	locret_95B6
		neg.w	X_Vel(a0)		; change direction

locret_95B6:
		rts
; ===========================================================================

Obj1F_MakeFire:				; XREF: Obj1F_WaitFire
		move.w	#$3B,Off30(a0)
		move.b	#6,Anim(a0)	; use firing animation
		bsr.w	SingleObjLoad
		bne.s	Obj1F_MakeFire2
		move.b	#$1F,(a1)	; load left fireball
		move.b	#6,Routine(a1)
		move.w	X_pos(a0),X_pos(a1)
		subi.w	#$10,X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.w	#-$100,X_Vel(a1)

Obj1F_MakeFire2:
		bsr.w	SingleObjLoad
		bne.s	locret_9618
		move.b	#$1F,(a1)	; load right fireball
		move.b	#6,Routine(a1)
		move.w	X_pos(a0),X_pos(a1)
		addi.w	#$10,X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.w	#$100,X_Vel(a1)

locret_9618:
		rts
; ===========================================================================

Obj1F_WalkOnFloor:			; XREF: Obj1F_Index2
		subq.w	#1,Off30(a0)
		bmi.s	loc_966E
		bsr.w	ObjectMove
		bchg	#0,Off32(a0)
		bne.s	loc_9654
		move.w	X_pos(a0),d3
		addi.w	#$10,d3
		btst	#0,Status(a0)
		beq.s	loc_9640
		subi.w	#$20,d3

loc_9640:
		jsr	ObjHitFloor2
		cmpi.w	#-8,d1
		blt.s	loc_966E
		cmpi.w	#$C,d1
		bge.s	loc_966E
		rts
; ===========================================================================

loc_9654:				; XREF: Obj1F_WalkOnFloor
		jsr	ObjHitFloor
		add.w	d1,Y_Pos(a0)
		move.b	d3,Angle(a0)
		bsr.w	Obj1F_SetAni
		addq.b	#3,d0
		move.b	d0,Anim(a0)
		rts
; ===========================================================================

loc_966E:				; XREF: Obj1F_WalkOnFloor
		subq.b	#2,Routine2(a0)
		move.w	#59,Off30(a0)
		move.w	#0,X_Vel(a0)
		bsr.w	Obj1F_SetAni
		move.b	d0,Anim(a0)
		rts
; ---------------------------------------------------------------------------
; Subroutine to	set the	correct	animation for a	Crabmeat
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj1F_SetAni:				; XREF: loc_966E
		moveq	#0,d0
		move.b	Angle(a0),d3
		bmi.s	loc_96A4
		cmpi.b	#6,d3
		blo.s	locret_96A2
		moveq	#1,d0
		btst	#0,Status(a0)
		bne.s	locret_96A2
		moveq	#2,d0

locret_96A2:
		rts
; ===========================================================================

loc_96A4:				; XREF: Obj1F_SetAni
		cmpi.b	#-6,d3
		bhi.s	locret_96B6
		moveq	#2,d0
		btst	#0,Status(a0)
		bne.s	locret_96B6
		moveq	#1,d0

locret_96B6:
		rts
; End of function Obj1F_SetAni

; ===========================================================================

Obj1F_Delete:				; XREF: Obj1F_Index
		bsr.w	DeleteObject
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sub-object - missile that the	Crabmeat throws
; ---------------------------------------------------------------------------

Obj1F_BallMain:				; XREF: Obj1F_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj1F,Mappings_Offset(a0)
		move.w	#$400,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#$87,Coll(a0)
		move.b	#8,X_Visible(a0)
		move.w	#-$400,Y_Vel(a0)
		move.b	#7,Anim(a0)

Obj1F_BallMove:				; XREF: Obj1F_Index
		lea	Ani_obj1F,a1
		bsr.w	AnimateSprite
		bsr.w	ObjectFall
		bsr.w	DisplaySprite
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	Y_Pos(a0),d0	; has object moved below the level boundary?
		blo.s	Obj1F_Delete2	; if yes, branch
		rts
; ===========================================================================

Obj1F_Delete2:
		bra.w	DeleteObject
; ===========================================================================
Ani_obj1F:
	include "_anim\obj1F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Crabmeat enemy (GHZ, SYZ)
; ---------------------------------------------------------------------------
Map_obj1F:
	include "_maps\obj1F.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 22 - Buzz Bomber enemy	(GHZ, MZ, SYZ)
; ---------------------------------------------------------------------------

Obj22:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj22_Index(pc,d0.w),d1
		jmp	Obj22_Index(pc,d1.w)
; ===========================================================================
Obj22_Index:	dc.w Obj22_Main-Obj22_Index
		dc.w Obj22_Action-Obj22_Index
		dc.w Obj22_Delete-Obj22_Index
; ===========================================================================

Obj22_Main:				; XREF: Obj22_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj22,Mappings_Offset(a0)
		move.w	#$444,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#8,Coll(a0)
		move.b	#$18,X_Visible(a0)

Obj22_Action:				; XREF: Obj22_Index
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj22_Index2(pc,d0.w),d1
		jsr	Obj22_Index2(pc,d1.w)
		lea	(Ani_obj22).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj22_Index2:	dc.w Obj22_Move-Obj22_Index2
		dc.w Obj22_ChkNrSonic-Obj22_Index2
; ===========================================================================

Obj22_Move:				; XREF: Obj22_Index2
		subq.w	#1,Off32(a0)	; subtract 1 from time delay
		bpl.s	locret_986C	; if time remains, branch
		btst	#1,Off34(a0)	; is Buzz Bomber near Sonic?
		bne.s	Obj22_Fire	; if yes, branch
		addq.b	#2,Routine2(a0)
		move.w	#127,Off32(a0)	; set time delay to just over 2	seconds
		move.w	#$400,X_Vel(a0)	; move Buzz Bomber to the right
		move.b	#1,Anim(a0)	; use "flying" animation
		btst	#0,Status(a0)	; is Buzz Bomber facing	left?
		bne.s	locret_986C	; if not, branch
		neg.w	X_Vel(a0)		; move Buzz Bomber to the left

locret_986C:
		rts
; ===========================================================================

Obj22_Fire:				; XREF: Obj22_Move
		bsr.w	SingleObjLoad
		bne.s	locret_98D0
		move.b	#$23,(a1)	; load missile object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		addi.w	#$1C,Y_Pos(a1)
		move.w	#$200,Y_Vel(a1)	; move missile downwards
		move.w	#$200,X_Vel(a1)	; move missile to the right
		move.w	#$18,d0
		btst	#0,Status(a0)	; is Buzz Bomber facing	left?
		bne.s	loc_98AA	; if not, branch
		neg.w	d0
		neg.w	X_Vel(a1)		; move missile to the left

loc_98AA:
		add.w	d0,X_pos(a1)
		move.b	Status(a0),Status(a1)
		move.w	#$E,Off32(a1)
		move.l	a0,Off3C(a1)
		move.b	#1,Off34(a0)	; set to "already fired" to prevent refiring
		move.w	#$3B,Off32(a0)
		move.b	#2,Anim(a0)	; use "firing" animation

locret_98D0:
		rts
; ===========================================================================

Obj22_ChkNrSonic:			; XREF: Obj22_Index2
		subq.w	#1,Off32(a0)	; subtract 1 from time delay
		bmi.s	Obj22_ChgDir
		bsr.w	ObjectMove
		tst.b	Off34(a0)
		bne.s	locret_992A
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bpl.s	Obj22_SetNrSonic
		neg.w	d0

Obj22_SetNrSonic:
		cmpi.w	#$60,d0		; is Buzz Bomber within	$60 pixels of Sonic?
		bhs.s	locret_992A	; if not, branch
		tst.b	Render_Flags(a0)
		bpl.s	locret_992A
		move.b	#2,Off34(a0)	; set Buzz Bomber to "near Sonic"
		move.w	#29,Off32(a0)	; set time delay to half a second
		bra.s	Obj22_Stop
; ===========================================================================

Obj22_ChgDir:				; XREF: Obj22_ChkNrSonic
		move.b	#0,Off34(a0)	; set Buzz Bomber to "normal"
		bchg	#0,Status(a0)	; change direction
		move.w	#59,Off32(a0)

Obj22_Stop:				; XREF: Obj22_SetNrSonic
		subq.b	#2,Routine2(a0)	; run "Obj22_Fire" routine
		move.w	#0,X_Vel(a0)	; stop Buzz Bomber moving
		move.b	#0,Anim(a0)	; use "hovering" animation

locret_992A:
		rts
; ===========================================================================

Obj22_Delete:				; XREF: Obj22_Index
		bsr.w	DeleteObject
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 23 - missile that Buzz	Bomber throws
; ---------------------------------------------------------------------------

Obj23:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj23_Index(pc,d0.w),d1
		jmp	Obj23_Index(pc,d1.w)
; ===========================================================================
Obj23_Index:	dc.w Obj23_Main-Obj23_Index
		dc.w Obj23_Animate-Obj23_Index
		dc.w Obj23_FromBuzz-Obj23_Index
		dc.w Obj23_Delete-Obj23_Index
		dc.w Obj23_FromNewt-Obj23_Index
; ===========================================================================

Obj23_Main:				; XREF: Obj23_Index
		subq.w	#1,Off32(a0)
		bpl.s	Obj23_ChkCancel
		addq.b	#2,Routine(a0)
		move.l	#Map_obj23,Mappings_Offset(a0)
		move.w	#$2444,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#8,X_Visible(a0)
		andi.b	#3,Status(a0)
		tst.b	Subtype(a0)		; was object created by	a Newtron?
		beq.s	Obj23_Animate	; if not, branch
		move.b	#8,Routine(a0)	; run "Obj23_FromNewt" routine
		move.b	#$87,Coll(a0)
		move.b	#1,Anim(a0)
		bra.s	Obj23_Animate2
; ===========================================================================

Obj23_Animate:				; XREF: Obj23_Index
		bsr.s	Obj23_ChkCancel
		lea	(Ani_obj23).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ---------------------------------------------------------------------------
; Subroutine to	check if the Buzz Bomber which fired the missile has been
; destroyed, and if it has, then cancel	the missile
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj23_ChkCancel:			; XREF: Obj23_Main
		movea.l	Off3C(a0),a1
		cmpi.b	#$27,0(a1)	; has Buzz Bomber been destroyed?
		beq.s	Obj23_Delete	; if yes, branch
		rts
; End of function Obj23_ChkCancel

; ===========================================================================

Obj23_FromBuzz:				; XREF: Obj23_Index
		btst	#7,Status(a0)
		bne.s	Obj23_Explode
		move.b	#$87,Coll(a0)
		move.b	#1,Anim(a0)
		bsr.w	ObjectMove
		lea	(Ani_obj23).l,a1
		bsr.w	AnimateSprite
		bsr.w	DisplaySprite
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	Y_Pos(a0),d0	; has object moved below the level boundary?
		blo.s	Obj23_Delete	; if yes, branch
		rts
; ===========================================================================

Obj23_Explode:				; XREF: Obj23_FromBuzz
		move.b	#$24,0(a0)	; change object	to an explosion	(Obj24)
		move.b	#0,Routine(a0)
		bra.w	Obj24
; ===========================================================================

Obj23_Delete:				; XREF: Obj23_Index
		bsr.w	DeleteObject
		rts
; ===========================================================================

Obj23_FromNewt:				; XREF: Obj23_Index
		tst.b	Render_Flags(a0)
		bpl.s	Obj23_Delete
		bsr.w	ObjectMove

Obj23_Animate2:				; XREF: Obj23_Main
		lea	(Ani_obj23).l,a1
		bsr.w	AnimateSprite
		bsr.w	DisplaySprite
		rts
; ===========================================================================
Ani_obj22:
	include "_anim\obj22.asm"

Ani_obj23:
	include "_anim\obj23.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Buzz Bomber	enemy
; ---------------------------------------------------------------------------
Map_obj22:
	include "_maps\obj22.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - missile that Buzz Bomber throws
; ---------------------------------------------------------------------------
Map_obj23:
	include "_maps\obj23.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 25 - rings
; ---------------------------------------------------------------------------

Obj25:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj25_Index(pc,d0.w),d1
		jmp	Obj25_Index(pc,d1.w)
; ===========================================================================
Obj25_Index:	dc.w Obj25_Main-Obj25_Index
		dc.w Obj25_Animate-Obj25_Index
		dc.w Obj25_Collect-Obj25_Index
		dc.w Obj25_Sparkle-Obj25_Index
		dc.w Obj25_Delete-Obj25_Index
; ---------------------------------------------------------------------------
; Distances between rings (format: horizontal, vertical)
; ---------------------------------------------------------------------------
Obj25_PosData:	dc.b $10, 0		; horizontal tight
		dc.b $18, 0		; horizontal normal
		dc.b $20, 0		; horizontal wide
		dc.b 0,	$10		; vertical tight
		dc.b 0,	$18		; vertical normal
		dc.b 0,	$20		; vertical wide
		dc.b $10, $10		; diagonal
		dc.b $18, $18
		dc.b $20, $20
		dc.b $F0, $10
		dc.b $E8, $18
		dc.b $E0, $20
		dc.b $10, 8
		dc.b $18, $10
		dc.b $F0, 8
		dc.b $E8, $10
; ===========================================================================

Obj25_Main:				; XREF: Obj25_Index
		tst.b	$3F(a0)		; is debug mode active?
		bne.s	Obj25_MakeRingsD ; if it is, branch away
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		lea	2(a2,d0.w),a2
		move.b	(a2),d4
		move.b	Subtype(a0),d1
		move.b	d1,d0
		andi.w	#7,d1
		cmpi.w	#7,d1
		bne.s	loc_9B80
		moveq	#6,d1

loc_9B80:
		swap	d1
		move.w	#0,d1
		lsr.b	#4,d0
		add.w	d0,d0
		move.b	Obj25_PosData(pc,d0.w),d5 ; load ring spacing data
		ext.w	d5
		move.b	Obj25_PosData+1(pc,d0.w),d6
		ext.w	d6
		movea.l	a0,a1
		move.w	X_pos(a0),d2
		move.w	Y_Pos(a0),d3
		lsr.b	#1,d4
		blo.w	loc_9C02
		bclr	#7,(a2)
		bra.s	loc_9BBA
; ===========================================================================
Obj25_MakeRingsD: ; this routine makes the rings work, and not spawn million of them
		addq.b	#2,Routine(a0) ; add 2 to the routine counter
		move.w	X_Pos(a0),Off32(a0) ; move x-position to secondary x-position
		move.l	#Map_obj25,Mappings_Offset(a0) ; load mappings
		move.w	#$27B2,Art_Tile(a0) ; load right art
		move.b	#4,Render_Flags(a0) ; setup objects render flags
		move.b	#2,Priority(a0) ; setup priority
		move.b	#$47,Coll(a0) ; setup touch response
		move.b	#8,X_Visible(a0) ; setup how wide this object is
		move.b	#0,Respawn(a0) ; we don't want this to use any object spawn table slots
		bra	Obj25_Animate ; branch away

Obj25_MakeRings:
		swap	d1
		lsr.b	#1,d4
		blo.s	loc_9C02
		bclr	#7,(a2)
		bsr.w	SingleObjLoad
		bne.s	loc_9C0E

loc_9BBA:				; XREF: Obj25_Main
		move.b	#$25,(a1)	; load ring object
		addq.b	#2,Routine(a1)
		move.w	d2,X_pos(a1)	; set x-axis position based on d2
		move.w	X_pos(a0),Off32(a1)
		move.w	d3,Y_Pos(a1)	; set y-axis position based on d3
		move.l	#Map_obj25,Mappings_Offset(a1)
		move.w	#$27B2,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#2,Priority(a1)
		move.b	#$47,Coll(a1)
		move.b	#8,X_Visible(a1)
		move.b	Respawn(a0),Respawn(a1)
		move.b	d1,Off34(a1)

loc_9C02:
		addq.w	#1,d1
		add.w	d5,d2		; add ring spacing value to d2
		add.w	d6,d3		; add ring spacing value to d3
		swap	d1
		dbf	d1,Obj25_MakeRings ; repeat for	number of rings

loc_9C0E:
		btst	#0,(a2)
		bne.w	DeleteObject

Obj25_Animate:				; XREF: Obj25_Index
		move.b	($FFFFFEC3).w,Anim_Frame(a0) ;	set frame
		bsr.w	DisplaySprite
		bsr	CheckAttracted
		move.w	Off32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj25_Delete
		rts
; ===========================================================================

Obj25_Collect:				; XREF: Obj25_Index
		addq.b	#2,Routine(a0)
		move.b	#0,Coll(a0)
		move.b	#1,Priority(a0)
		bsr.w	CollectRing
		tst.b	Off3F(a0) ; was this ring spawned in debug mode?
		bne.s	Obj25_Sparkle ; if it was, branch away
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		move.b	Off34(a0),d1
		bset	d1,2(a2,d0.w)

Obj25_Sparkle:				; XREF: Obj25_Index
		lea	Ani_obj25.l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj25_Delete:				; XREF: Obj25_Index
		bra.w	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CollectRing:				; XREF: Obj25_Collect
		addq.w	#1,($FFFFFE20).w ; add 1 to rings
		ori.b	#1,($FFFFFE1D).w ; update the rings counter
		move.w	#$B5,d0		; play ring sound
		cmpi.w	#100,($FFFFFE20).w ; do	you have < 100 rings?
		blo.s	Obj25_PlaySnd	; if yes, branch
		bset	#1,($FFFFFE1B).w ;
		beq.s	CollectLife
		cmpi.w	#200,($FFFFFE20).w ; do	you have < 200 rings?
		blo.s	Obj25_PlaySnd	; if yes, branch
		bset	#2,($FFFFFE1B).w ;
		bne.s	Obj25_PlaySnd

CollectLife:
		cmpi.b	#99,$FFFFFE12.w
		bhs.s	.snd
		addq.b	#1,$FFFFFE12.w ; add 1 to the	number of lives	you have
		addq.b	#1,$FFFFFE1C.w ; update lives counter
.snd		moveq	#$FFFFFF8D,d0	; play extra life music
		jmp	PlaySample

Obj25_PlaySnd:
		jmp	PlaySound

; End of function CollectRing

CheckAttracted:
		cmpi.b	#16,Shield_Type
		bne	Obj37_rts
		move.w	X_Pos(a0),d0
		sub.w	Object_RAM+X_Pos,d0
		bpl	.Back
		neg.w	d0

.Back		cmpi.w	#RingAttract_X,d0
		bgt	Obj37_rts

Ring_Attract_Y:
		move.w	Y_Pos(a0),d0
		sub.w	Object_RAM+Y_Pos,d0
		bpl	.Back
		neg.w	d0

.Back		cmpi.w	#RingAttract_Y,d0
		bgt	Obj37_rts

Ring_Attract:
		move.b	#$37,(a0)		; change to object 37
		sf	Off3F(a0)		; ring timer = $FF
		sf	$FFFFFEC6.w		; general ring timer = $FF
		move.b	#2,Routine(a0)		; routine number 2
		move.w	#$808,Y_Radius(a0)	; set to correct size

                lea	DestroyTable.w,a2	; get respawn table
		moveq	#0,d0
		move.b	Respawn(a0),d0		; get respawn index
		move.b	off34(a0),d1		; get objects $34
		bset	d1,2(a2,d0.w)		; set as collected

Obj37_rts:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 37 - rings flying out of Sonic	when he's hit
; ---------------------------------------------------------------------------

Obj37:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj37_Index(pc,d0.w),d1
		jmp	Obj37_Index(pc,d1.w)
; ===========================================================================
Obj37_Index:	dc.w Obj37_CountRings-Obj37_Index
		dc.w Obj37_Bounce-Obj37_Index
		dc.w Obj37_Collect-Obj37_Index
		dc.w Obj37_Sparkle-Obj37_Index
		dc.w Obj37_Delete-Obj37_Index
; ===========================================================================

Obj37_CountRings:			; XREF: Obj37_Index
		movea.l	a0,a1
		moveq	#0,d5
		move.w	($FFFFFE20).w,d5 ; check number	of rings you have
		moveq	#32,d0
		cmp.w	d0,d5		; do you have 32 or more?
		blo.s	loc_9CDE	; if not, branch
		move.w	d0,d5		; if yes, set d5 to 32

loc_9CDE:
		subq.w	#1,d5
		move.w	#$288,d4
		bra.s	Obj37_MakeRings
; ===========================================================================

Obj37_Loop:
		bsr.w	SingleObjLoad
		bne.w	Obj37_ResetCounter

Obj37_MakeRings:			; XREF: Obj37_CountRings
		move.l	#$370427B2,(a1)	; load bouncing	ring object
		move.l	#Map_obj25,Mappings_Offset(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		addq.b	#2,Routine(a1)
		move.l	#$8080300,Y_Radius(a1)
		move.b	#$47,Coll(a1)
		addq.b	#8,X_Visible(a1)	; CRUD THIS IS $1F SO CANT DO WORD :I
		st	$FFFFFEC6.w		; <- #-1
		tst.w	d4
		bmi.s	loc_9D62
		move.w	d4,d1
		jsr	CalcSine
		move.w	d4,d2
		lsr.w	#8,d2
		tst.b   ($FFFFF64C).w           ; Does the level have water?
                beq.s   .skiphalvingvel         ; If not, branch and skip underwater checks
                move.w  ($FFFFF646).w,d6        ; Move water level to d6
                cmp.w   obY(a0),d6		; Is the ring object underneath the water level?
                bgt.s   .skiphalvingvel         ; If not, branch and skip underwater commands
                asr.w   #1,d0                  ; Half d0.  Makes the ring's x_vel bounce to the left/right slower
                asr.w   #1,d1                  ; Half d1.  Makes the ring's y_vel bounce up/down slower

.skiphalvingvel:
		asl.w	d2,d0
		asl.w	d2,d1
		move.w	d0,d2
		move.w	d1,d3
		addi.b	#$10,d4
		bhs.s	loc_9D62
		subi.w	#$80,d4
		bhs.s	loc_9D62
		move.w	#$288,d4

loc_9D62:
		move.w	d2,X_Vel(a1)
		move.w	d3,Y_Vel(a1)
		neg.w	d2
		neg.w	d4
		dbf	d5,Obj37_Loop	; repeat for number of rings (max 31)

Obj37_ResetCounter:			; XREF: Obj37_Loop
		move.w	#0,($FFFFFE20).w ; reset number	of rings to zero
		move.b	#$80,($FFFFFE1D).w ; update ring counter
		st	$FFFFFE1B.w	; <-- #0
		moveq	#$FFFFFFC6,d0
		jsr	(PlaySound).l ;	play ring loss sound

Obj37_Bounce:				; XREF: Obj37_Index
		move.b	($FFFFFEC7).w,Anim_Frame(a0)
		bsr	ObjectMove
		bsr	Attracted_Ring
		beq	DisplaySprite
		tst.b   ($FFFFF64C).w		; Does the level have water?
                beq.s   .skipbounceslow		; If not, branch and skip underwater checks
                move.w  ($FFFFF646).w,d6	; Move water level to d6
                cmp.w   obY(a0),d6		; Is the ring object underneath the water level?
                bgt.s   .skipbounceslow		; If not, branch and skip underwater commands
                subi.w  #$E,obVelY(a0)		; Reduce gravity by $E ($18-$E=$A), giving the underwater effect

.skipbounceslow	addi.w	#$18,Y_Vel(a0)
		bmi.s	Obj37_ChkDel
		move.b	($FFFFFE0F).w,d0
		add.b	d7,d0
		andi.b	#3,d0
		bne.s	Obj37_ChkDel
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	Obj37_ChkDel
		add.w	d1,Y_Pos(a0)
		move.w	Y_Vel(a0),d0
		asr.w	#2,d0
		sub.w	d0,Y_Vel(a0)
		neg.w	Y_Vel(a0)

Obj37_ChkDel:				; XREF: Obj37_Bounce
		tst.b	($FFFFFEC6).w
		beq	Obj37_Delete
		cmpi.w  #$FF00,($FFFFF72C).w            ; is vertical wrapping enabled?
		beq	DisplaySprite                   ; if so, branch
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	Y_Pos(a0),d0	; has object moved below level boundary?
		blt	Obj37_Delete	; if yes, branch
		bra	DisplaySprite
; ===========================================================================

Obj37_Collect:				; XREF: Obj37_Index
		addq.b	#2,Routine(a0)
		move.b	#0,Coll(a0)
		move.b	#1,Priority(a0)
		bsr.w	CollectRing

Obj37_Sparkle:				; XREF: Obj37_Index
		lea	(Ani_obj25).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj37_Delete:				; XREF: Obj37_Index
		bra.w	DeleteObject

; Ring attraction code from Sonic 3

Attracted_Ring:
		cmpi.b	#16,Shield_Type
		bne	.End

		move.b	#-1,Off3F(a0)		; reset ring timer
		move.b	#-1,$FFFFFEC6

	;	lea	X_Pos(a0),a1		; get X position
		lea	X_Vel(a0),a2		; get X velocity
		move.w	#RiAt_XMul,d1		; get X multiplier
		move.w	Object_RAM+X_Pos,d0	; get Sonic's X position
		sub.w	X_Pos(a0),d0
		bsr	ARing_Common

	;	lea	Y_Pos(a0),a1		; get Y position
		lea	Y_Vel(a0),a2		; get Y velocity
		move.w	#RiAt_YMul,d1		; get Y multiplier
		move.w	Object_RAM+Y_Pos,d0	; get Sonic's Y position
		sub.w	Y_Pos(a0),d0
		bsr	ARing_Common

		moveq	#0,d1
.End		rts

ARing_Common:
;		sub.w	(a1),d0		; compare with objects X position
		bpl	ARing_ChkSpeed	; if higher than d0, branch

		neg.w	d1		; negate d1
		tst.w	(a2)		; test velocity
		bmi	ARing_SetSpeed	; if negative, branch

ARing_ChkSpeed:
		tst.w	(a2)		; test velocity
		bpl	ARing_SetSpeed	; if positive, branch

Aring_MulD1:
		lsl.w	#2,d1		; multiply by 4

ARing_SetSpeed:
		add.w	d1,(a2)		; add to velocity
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4B - giant ring for entry to special stage
; ---------------------------------------------------------------------------

Obj4B:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj4B_Index(pc,d0.w),d1
		jmp	Obj4B_Index(pc,d1.w)
; ===========================================================================
Obj4B_Index:	dc.w Obj4B_Main-Obj4B_Index
		dc.w Obj4B_Animate-Obj4B_Index
		dc.w Obj4B_Collect-Obj4B_Index
		dc.w Obj4B_Delete-Obj4B_Index
; ===========================================================================

Obj4B_Main:				; XREF: Obj4B_Index
		cmp.w	#$302,$FFFFFE10.w
		beq.s	.skp
		cmpi.w	#$F00,x_pos(a0)
		bgt	DeleteObject

.skp		move.l	#Map_obj4B,Mappings_Offset(a0)
		move.w	#$2400,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$40,X_Visible(a0)
		move.b	#$52,Coll(a0)
		tst.b	Render_Flags(a0)
		bpl	Obj4B_Animate

Obj4B_LoadLocks:
		moveq	#0,d1
		moveq	#0,d2
		move.b	subtype(a0),d1		; get subtype of the object

Obj4B_NormLvl:
		cmpi.b	#4,d1			; is subtype 4?
		beq	Obj4B_Okay		; if is, branch

Obj4B_Okay:				; XREF: Obj4B_Main
		addq.b	#2,Routine(a0)
		move.b	#3,Priority(a0)
		move.w	#$C40,($FFFFF7BE).w

Obj4B_Animate:				; XREF: Obj4B_Index
		move.b	($FFFFFEC3).w,Anim_Frame(a0)
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi	.loadgfx

		cmp.b	#0,$FFFFFE10.w
		bne.w	DisplaySprite

		move.w	y_pos(a0),d0
		sub.w	$FFFFF704.w,d0
		subi.w	#240+$80,d0
		bpl.s	.loadgfx

		bra.w	DisplaySprite

.loadgfx	moveq	#$15,d0
		cmp.b	#0,$FFFFFE10.w
		beq.s	.skp
		moveq	#$21,d0

.skp		jsr	LoadPLC
		bra.w	DeleteObject
; ===========================================================================

Obj4B_Collect:				; XREF: Obj4B_Index
		subq.b	#2,Routine(a0)
		move.b	#0,Coll(a0)
		bsr.w	SingleObjLoad
		bne	Obj4B_PlaySnd
		move.b	#$7C,(a1)	; load giant ring flash	object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.l	a0,Off3C(a1)
		move.b  Subtype(a0),Subtype(a1); put the subtype of this object to the flash object
		move.w	Object_RAM+X_Pos,d0
		cmp.w	X_pos(a0),d0	; has Sonic come from the left?
		blo.s	Obj4B_PlaySnd	; if yes, branch
		bset	#0,Render_Flags(a1)	; reverse flash	object2
Obj4B_PlaySnd:
		move.w	#$C3,d0
		jsr	PlaySound ;	play giant ring	sound
		bra	Obj4B_Animate
; ===========================================================================

Obj4B_Delete:				; XREF: Obj4B_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7C - flash effect when	you collect the	giant ring
; ---------------------------------------------------------------------------

Obj7C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj7C_Index(pc,d0.w),d1
		jmp	Obj7C_Index(pc,d1.w)
; ===========================================================================
Obj7C_Index:	dc.w Obj7C_Main-Obj7C_Index
		dc.w Obj7C_ChkDel-Obj7C_Index
		dc.w Obj7C_Delete-Obj7C_Index
; ===========================================================================

Obj7C_Main:				; XREF: Obj7C_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj7C,Mappings_Offset(a0)
		move.w	#$2462,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#0,Priority(a0)
		move.b	#$20,X_Visible(a0)
		move.b	#$FF,Anim_Frame(a0)

Obj7C_ChkDel:				; XREF: Obj7C_Index
		bsr.s	Obj7C_Collect
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj7C_Collect:				; XREF: Obj7C_ChkDel
		subq.b	#1,Anim_Dur(a0)
		bpl.s	locret_9F76
		move.b	#1,Anim_Dur(a0)
		addq.b	#1,Anim_Frame(a0)
		cmpi.b	#8,Anim_Frame(a0)	; has animation	finished?
		bhs.s	Obj7C_End	; if yes, branch
		cmpi.b	#3,Anim_Frame(a0)	; is 3rd frame displayed?
		bne.s	locret_9F76	; if not, branch
		movea.l	Off3C(a0),a1
		move.b	#6,Routine(a1)	; delete giant ring object (Obj4B)
		move.b	#$1C,Object_RAM+Anim ; make Sonic invisible
		move.b	#1,($FFFFF7CD).w ; stop	Sonic getting bonuses
		sf	($FFFFFE2D).w	; remove invincibility

		;sf	Shield_Type
		;sf	Shield_RAM+Routine2
		;sf	Shield_UseType

locret_9F76:
		rts
; ===========================================================================

Obj7C_End:				; XREF: Obj7C_Collect
		addq.b	#2,Routine(a0)
		move.w	#0,Object_RAM ; remove Sonic	object
		addq.l	#4,sp
		rts
; End of function Obj7C_Collect

; ===========================================================================

Obj7C_Delete:
		cmp.b	#0,$FFFFFE10.w
		beq.s	.dos
		jmp	TrumpScreen

.dos		jmp	DOS
; ===========================================================================
Ani_obj25:
	include "_anim\obj25.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - rings
; ---------------------------------------------------------------------------
Map_obj25:
	include "_maps\obj25.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - giant ring
; ---------------------------------------------------------------------------
Map_obj4B:
	include "_maps\obj4B.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - flash effect when you collect the giant ring
; ---------------------------------------------------------------------------
Map_obj7C:
	include "_maps\obj7C.asm"

Map_Locks:
		dc.w .-Map_Locks
.		dc.b 1
		dc.b $10, 5, 0, 0, 0
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 26 - monitors
; ---------------------------------------------------------------------------

Obj26:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj26_Index(pc,d0.w),d1
		jmp	Obj26_Index(pc,d1.w)
; ===========================================================================
Obj26_Index:	dc.w Obj26_Main-Obj26_Index
		dc.w Obj26_Solid-Obj26_Index
		dc.w Obj26_BreakOpen-Obj26_Index
		dc.w Obj26_Animate-Obj26_Index
		dc.w Obj26_Display-Obj26_Index
; ===========================================================================

Obj26_Main:				; XREF: Obj26_Index
		addq.b	#2,Routine(a0)
		move.b	#$E,Y_Radius(a0)
		move.b	#$E,X_Radius(a0)
		move.l	#Map_obj26,Mappings_Offset(a0)
		move.w	#$680,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#$F,X_Visible(a0)
		tst.b	Off3F(a0) ; are we in debug mode?
		bne.s	Obj26_NotBroken ; if yes, place the monitor down
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		bclr	#7,2(a2,d0.w)
		btst	#0,2(a2,d0.w)	; has monitor been broken?
		beq.s	Obj26_NotBroken	; if not, branch
		move.b	#8,Routine(a0)	; run "Obj26_Display" routine
		move.b	#$C,Anim_Frame(a0)	; use broken monitor frame
		rts
; ===========================================================================

Obj26_NotBroken:
		buytest Bought_Shields
		bne.s	.cont		; if shields are bought, dont replace type
		cmpi.b	#8,Subtype(a0)
		beq.s	.replace
		cmpi.b	#9,Subtype(a0)
		beq.s	.replace
		cmpi.b	#4,Subtype(a0)
		bne.s	.cont

.replace	move.b	#11,Subtype(a0)

.cont		move.b	#$46,Coll(a0)
		move.b	Subtype(a0),Anim(a0)


Obj26_Solid:				; XREF: Obj26_Index
		move.b	Routine2(a0),d0	; is monitor set to fall?
		beq.s	loc_A1EC	; if not, branch
		subq.b	#2,d0
		bne.s	Obj26_Fall
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		bsr.w	ExitPlatform
		btst	#3,Status(a1)
		bne.w	loc_A1BC
		sf	Routine2(a0)
		bra.w	Obj26_Animate
; ===========================================================================

loc_A1BC:				; XREF: Obj26_Solid
		move.w	#$10,d3
		move.w	X_pos(a0),d2
		bsr.w	MvSonicOnPtfm
		bra.w	Obj26_Animate
; ===========================================================================

Obj26_Fall:				; XREF: Obj26_Solid
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	Obj26_Animate
		add.w	d1,Y_Pos(a0)
		clr.w	Y_Vel(a0)
		sf	Routine2(a0)
		bra.w	Obj26_Animate
; ===========================================================================

loc_A1EC:				; XREF: Obj26_Solid
		move.w	#$1A,d1
		move.w	#$F,d2
		bsr.w	Obj26_SolidSides
		beq.w	loc_A25C
		tst.w	Y_Vel(a1)
		bmi.s	loc_A20A
		cmpi.b	#2,Anim(a1)	; is Sonic rolling?
		beq.s	loc_A25C	; if yes, branch
                cmpi.b	#9,Anim(a1)	; is Sonic rolling?
		beq.s	loc_A25C	; if yes, branch
loc_A20A:
		tst.w	d1
		bpl.s	loc_A220
		sub.w	d3,Y_Pos(a1)
		bsr.w	loc_74AE
		move.b	#2,Routine2(a0)
		bra.w	Obj26_Animate
; ===========================================================================

loc_A220:
		tst.w	d0
		beq.w	loc_A246
		bmi.s	loc_A230
		tst.w	X_Vel(a1)
		bmi.s	loc_A246
		bra.s	loc_A236
; ===========================================================================

loc_A230:
		tst.w	X_Vel(a1)
		bpl.s	loc_A246

loc_A236:
		sub.w	d0,X_pos(a1)
		move.w	#0,Inertia(a1)
		move.w	#0,X_Vel(a1)

loc_A246:
		btst	#1,Status(a1)
		bne.s	loc_A26A
		bset	#5,Status(a1)
		bset	#5,Status(a0)
		bra.s	Obj26_Animate
; ===========================================================================

loc_A25C:
		btst	#5,Status(a0)
		beq.s	Obj26_Animate
		cmpi.b	#2,Anim(a1)	; check if in jumping/rolling animation
		beq.s	loc_A26A
		cmpi.b	#$17,Anim(a1)	; check if in drowning animation
		beq.s	loc_A26A
		cmpi.b	#$1A,Anim(a1)	; check if in hurt animation
		beq.s	loc_A26A
		cmpi.b	#9,Anim(a1)	; check if in jumping/rolling animation
		beq.s	loc_A26A
		move.w	#1,Anim(a1)

loc_A26A:
		bclr	#5,Status(a0)
		bclr	#5,Status(a1)

Obj26_Animate:				; XREF: Obj26_Index
		lea	(Ani_obj26).l,a1
		bsr.w	AnimateSprite

Obj26_Display:				; XREF: Obj26_Index
		bsr.w	DisplaySprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================

Obj26_BreakOpen:			; XREF: Obj26_Index
		addq.b	#2,Routine(a0)
		move.b	#0,Coll(a0)
		bsr.w	SingleObjLoad
		bne.s	Obj26_Explode
		move.b	#$2E,(a1)	; load monitor contents	object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	Anim(a0),Anim(a1)

Obj26_Explode:
		bsr.w	SingleObjLoad
		bne.s	Obj26_SetBroken
		move.b	#$27,(a1)	; load explosion object
		addq.b	#2,Routine(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)

Obj26_SetBroken:
		cmpi.b  #6,Anim(a0)	; is this ring monitor?
	        bne.w   Obj2E_norings	; if not, branch
		moveq   #0,d2
		moveq   #2,d1
Obj2E_loop:
		jsr	SingleObjLoad	; load object
		bne.w	Obj2E_dbf
		move.b	#$37,(a1)	; falling ring
		move.b	#1,Off33(a1)
		move.b  #-1,Off3F(a1)	; set the ring animation for the object
		move.b	#-1,($FFFFFEC6).w; set the ring animation
		move.b	#2,Routine(a1)	; skip init
		move.b	#8,Y_Radius(a1)	; set bla bla
		move.b	#8,X_Radius(a1)	;
		move.w	X_Pos(a0),X_pos(a1)	;
		move.w	Y_Pos(a0),Y_pos(a1)	;
		move.l	#Map_obj25,Mappings_offset(a1);
		move.w	#$27B2,Art_Tile(a1)	;
		move.b	#4,Render_Flags(a1)	;
		move.b	#3,Priority(a1)		;
		move.b	#$47,coll(a1)		;
		move.b	#8,X_Visible(a1)	;
		subi.w  #$A,Y_pos(a1)	; make it 10 pixels lower
		tst.b   d2		; is d2 0?
		bne.s   .d2		; if not
		move.w  #-$300,Y_Vel(a1); make it move upwards
.d2 		cmpi.b  #1,d2		; is d2 1?
                bne.s   .d22
                move.w  #-$280,Y_Vel(a1)
		move.w  #$190,X_Vel(a1)
.d22		cmpi.b  #2,d2
                bne.s   Obj2E_dbf
                move.w  #-$280,Y_Vel(a1)
		move.w  #-$190,X_Vel(a1)
Obj2E_dbf:
		addq.b  #1,d2
		dbf     d1,Obj2E_loop
Obj2E_norings:
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		bset	#0,2(a2,d0.w)
		move.b	#10,Anim(a0)	; set monitor type to broken
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2E - contents of monitors
; ---------------------------------------------------------------------------

Obj2E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj2E_Index(pc,d0.w),d1
		jsr	Obj2E_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj2E_Index:	dc.w Obj2E_Main-Obj2E_Index
		dc.w Obj2E_Move-Obj2E_Index
		dc.w Obj2E_Delete-Obj2E_Index
; ===========================================================================

Obj2E_Main:				; XREF: Obj2E_Index
		addq.b	#2,Routine(a0)
		move.w	#$680,Art_Tile(a0)
		move.b	#$24,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#8,X_Visible(a0)
		move.w	#-$300,Y_Vel(a0)
		moveq	#0,d0
		move.b	Anim(a0),d0
		addq.b	#2,d0
		move.b	d0,Anim_Frame(a0)
		movea.l	#Map_obj26,a1
		add.b	d0,d0
		adda.w	(a1,d0.w),a1
		addq.w	#1,a1
		move.l	a1,Mappings_Offset(a0)

Obj2E_Move:				; XREF: Obj2E_Index
		tst.w	Y_Vel(a0)		; is object moving?
		bpl.w	Obj2E_ChkEggman	; if not, branch
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)	; reduce object	speed
		rts
; ===========================================================================

Obj2E_ChkEggman:			; XREF: Obj2E_Move
		addq.b	#2,$24(a0)
        	move.w	#29,$1E(a0)
		move.b	$1C(a0),d0
		cmpi.b	#1,d0		; does monitor contain Eggman?
		bne	Obj2E_ChkSonic	; if not, go and check for the next monitor type (1-up icon)
		move.l	a0,a1		; move a0 to a1, because Touch_ChkHurt wants the damaging object to be in a1
		move.l	a0,-(sp)	; push a0 on the stack, and decrement stack pointer
		lea	Object_RAM,a0	; put Sonic's ram address in a0, because Touch_ChkHurt wants the damaged object to be in a0
		jsr	Touch_ChkHurt	; run the Touch_ChkHurt routine
		move.l	(sp)+,a0	; pop the previous value of a0 from the stack, and increment stack pointer
		rts			; The Eggman monitor now does something!
; ===========================================================================

Obj2E_ChkSonic:
		cmpi.b	#2,d0		; does monitor contain Sonic?
		bne.s	Obj2E_ChkShoes

ExtraLife:
		jmp	CollectLife
; ===========================================================================

Obj2E_ChkShoes:
		cmpi.b	#3,d0		; does monitor contain speed shoes?
		bne.s	Obj2E_ChkShield
		move.b	#1,($FFFFFE2E).w ; speed up the	BG music
		move.w	#$4B0,Object_RAM+Off34 ; time limit for the power-up
		jsr	Sonic_Setspeed
		moveq	#$FFFFFFE2,d0
		jmp	PlayMusic_Speed	; Speed	up the music
; ===========================================================================

Obj2E_ChkShield:
		cmpi.b	#4,d0		; does monitor contain a shield?
		bne.s	.CheckFire
		move.b	#8,Shield_Type	; give Sonic a	shield
		moveq	#$FFFFFF9B,d0
		bra	.ShieldCommon

.CheckFire	cmpi.b	#8,d0		; does monitor contain a shield?
		bne.s	.CheckElectric
		move.b	#16,Shield_Type	; give Sonic a	shield
		bra	.ShieldCommon2

.CheckElectric	cmpi.b	#9,d0		; does monitor contain a shield?
		bne.s	.CheckNormal
                move.b	#24,Shield_Type	; give Sonic a	shield
.ShieldCommon2	moveq	#$FFFFFFAF,d0

.ShieldCommon	sf	Shield_RAM+Routine2; clear secondary routine counter to load object properly
		jmp	PlaySound	; play shield sound

.CheckNormal	cmpi.b	#11,d0		; does monitor contain a shield?
		bne.s	Obj2E_ChkInvinc
		move.b	#32,Shield_Type	; give Sonic a	shield
		bra	.ShieldCommon2

; ===========================================================================

Obj2E_ChkInvinc:
		cmpi.b	#5,d0		; does monitor contain invincibility?
		bne.s	Obj2E_ChkRings
		move.b	#1,($FFFFFE2D).w ; make	Sonic invincible
		move.w	#$4B0,Object_RAM+Off32 ; time limit for the power-up
		move.b	#$38,InvinStars_RAM	; load stars object ($3801)
		move.b	#1,InvinStars_RAM+Anim
		move.b	#$38,InvinStars_RAM+Next_Obj; load stars object ($3802)
		move.b	#2,InvinStars_RAM+Next_Obj+Anim
		tst.b	($FFFFF7AA).w	; is boss mode on?
		bne.s	Obj2E_ChkEnd	; if yes, branch

		moveq	#$FFFFFF87,d0	; the music id
		buytest	Used_AltMusic
		beq.s	.c
		moveq	#Music_Invin,d0

.c		cmp.b	Music_StorePrevID,d0; Check if last music we played is this one
		beq	Obj2E_ChkEnd	; if was, go away
		jmp	PlayMusic	; play invincibility music
; ===========================================================================

Obj2E_ChkRings:
		cmpi.b	#6,d0		; does monitor contain 10 rings?
		bne.s	Obj2E_ChkEnd
		addi.w	#$A,($FFFFFE20).w ; add	10 rings to the	number of rings	you have
		ori.b	#1,($FFFFFE1D).w ; update the ring counter
		cmpi.w	#100,($FFFFFE20).w ; check if you have 100 rings
		blo.s	Obj2E_RingSound
		bset	#1,($FFFFFE1B).w
		beq.w	ExtraLife
		cmpi.w	#200,($FFFFFE20).w ; check if you have 200 rings
		blo.s	Obj2E_RingSound
		bset	#2,($FFFFFE1B).w
		beq.w	ExtraLife

Obj2E_RingSound:
		move.w	#$B5,d0
		jmp	PlaySound	; play ring sound

Obj2E_ChkEnd:
		rts			; 'S' and goggles monitors do nothing
; ===========================================================================

Obj2E_Delete:				; XREF: Obj2E_Index
		subq.w	#1,Anim_Dur(a0)
		bmi.w	DeleteObject
		rts
; ---------------------------------------------------------------------------
; Subroutine to	make the sides of a monitor solid
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj26_SolidSides:			; XREF: loc_A1EC
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d1,d0
		bmi.s	loc_A4E6
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.s	loc_A4E6
		move.b	Y_Radius(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	Y_Pos(a1),d3
		sub.w	Y_Pos(a0),d3
		add.w	d2,d3
		bmi.s	loc_A4E6
		add.w	d2,d2
		cmp.w	d2,d3
		bhs.s	loc_A4E6
		tst.b	($FFFFF7C8).w
		bmi.s	loc_A4E6
		cmpi.b	#6,Object_RAM+Routine
		bhs.s	loc_A4E6
		tst.b	$FFFFFE08.w
		bne.s	loc_A4E6
		cmp.w	d0,d1
		bhs.s	loc_A4DC
		add.w	d1,d1
		sub.w	d1,d0

loc_A4DC:
		cmpi.w	#$10,d3
		blo.s	loc_A4EA

loc_A4E2:
		moveq	#1,d1
		rts
; ===========================================================================

loc_A4E6:
		moveq	#0,d1
		rts
; ===========================================================================

loc_A4EA:
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addq.w	#4,d1
		move.w	d1,d2
		add.w	d2,d2
		add.w	X_pos(a1),d1
		sub.w	X_pos(a0),d1
		bmi.s	loc_A4E2
		cmp.w	d2,d1
		bhs.s	loc_A4E2
		moveq	#-1,d1
		rts
; End of function Obj26_SolidSides

; ===========================================================================
Ani_obj26:
	include "_anim\obj26.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - monitors
; ---------------------------------------------------------------------------
Map_obj26:
	include "_maps\obj26.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0E - Sonic on the title screen
; ---------------------------------------------------------------------------

Obj0E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj0E_Index(pc,d0.w),d1
		jmp	Obj0E_Index(pc,d1.w)
; ===========================================================================
Obj0E_Index:	dc.w Obj0E_Main-Obj0E_Index
		dc.w Obj0E_Delay-Obj0E_Index
		dc.w Obj0E_Move-Obj0E_Index
		dc.w Obj0E_Animate-Obj0E_Index
; ===========================================================================

Obj0E_Main:				; XREF: Obj0E_Index
		addq.b	#2,Routine(a0)
		move.w	#$F0,X_pos(a0)
		move.w	#$DE,X_Pos2(a0)
		move.l	#Map_obj0E,Mappings_Offset(a0)
		move.w	#$8000,Art_Tile(a0)
		move.b	#0,Priority(a0)
		move.b	#29,$1F(a0)	; set time delay to 0.5	seconds
		lea	(Ani_obj0E).l,a1
		bsr.w	AnimateSprite

Obj0E_Delay:				; XREF: Obj0E_Index
		subq.b	#1,$1F(a0)	; subtract 1 from time delay
		bpl.s	Obj0E_Wait	; if time remains, branch
		addq.b	#2,Routine(a0)	; go to	next routine
		bra.w	DisplaySprite
; ===========================================================================

Obj0E_Wait:				; XREF: Obj0E_Delay
		rts
; ===========================================================================

Obj0E_Move:				; XREF: Obj0E_Index
		subq.w	#8,X_Pos2(a0)
		cmpi.w	#$96,X_Pos2(a0)
		bne.s	Obj0E_Display
		addq.b	#2,Routine(a0)

Obj0E_Display:
		bra.w	DisplaySprite
; ===========================================================================
		rts
; ===========================================================================

Obj0E_Animate:				; XREF: Obj0E_Index
		lea	(Ani_obj0E).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0F - "PRESS START BUTTON" and "TM" from title screen
; ---------------------------------------------------------------------------

Obj0F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj0F_Index(pc,d0.w),d1
		jmp	Obj0F_Index(pc,d1.w)
; ===========================================================================
Obj0F_Index:	dc.w Obj0F_Main-Obj0F_Index
		dc.w Obj0F_PrsStart-Obj0F_Index
; ===========================================================================

Obj0F_Main:				; XREF: Obj0F_Index
		addq.b	#2,Routine(a0)
		move.w	#$60,X_pos(a0)
		move.w	#$C0,Y_pos(a0)
		move.l	#Map_obj0F,Mappings_offset(a0)
		move.w	#$2000,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)         ; set up main flags
		move.b  #3,Priority(a0)
Obj0F_PrsStart:				; XREF: Obj0F_Index
		lea	(Ani_obj0F).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj0E:
	  	include "_anim\obj0E.asm"

Ani_obj0F:
	        dc.w byte_A714-Ani_obj0F
byte_A714:	dc.b $18, 1, $FF
		even

; ---------------------------------------------------------------------------
; Subroutine to	animate	a sprite using an animation script
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AnimateSprite:
		moveq	#0,d0
		move.b	Anim(a0),d0	; move animation number	to d0
		cmp.b	Anim_Restart(a0),d0	; is animation set to restart?
		beq.s	Anim_Run	; if not, branch
		move.b	d0,Anim_Restart(a0)	; set to "no restart"
		move.b	#0,Anim_scriptNum(a0)	; reset	animation
		move.b	#0,Anim_Dur(a0)	; reset	frame duration

Anim_Run:
		subq.b	#1,Anim_Dur(a0)		; subtract 1 from frame	duration
		bpl.s	Anim_Wait		; if time remains, branch
		add.w	d0,d0
		adda.w	(a1,d0.w),a1		; jump to appropriate animation	script
		move.b	(a1),Anim_Dur(a0)	; load frame duration
		moveq	#0,d1
		move.b	Anim_scriptNum(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmpi.b	#$FA,d0		; GS: is it a flag from FA to FF?
		bhs.s	Anim_End_FF

Anim_Next:
		move.b	d0,d1
		andi.b	#$1F,d0
		move.b	d0,Anim_Frame(a0)	; load sprite number
		move.b	Status(a0),d0
		rol.b	#3,d1
		eor.b	d0,d1
		andi.b	#3,d1
		andi.b	#$FC,Render_Flags(a0)
		or.b	d1,Render_Flags(a0)
		addq.b	#1,Anim_scriptNum(a0)	; next frame number

Anim_Wait:
		rts
; ===========================================================================

Anim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	Anim_End_FE	; if not, branch
		move.b	#0,Anim_scriptNum(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	Anim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,Anim_scriptNum(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	Anim_End_FC	; if not, branch
		move.b	2(a1,d1.w),Anim(a0) ; read next byte, run that animation

Anim_End_FC:
		addq.b	#1,d0		; is the end flag = $FC	?
		bne.s	Anim_End_FB	; if not, branch
		addq.b	#2,Routine(a0)	; jump to next routine
		sf	Anim_scriptNum(a0)
		addq.b	#1,Anim_Dur(a0)
Anim_End_FB:
		addq.b	#1,d0		; is the end flag = $FB	?
		bne.s	Anim_End_FA	; if not, branch
		move.b	#0,Anim_scriptNum(a0)	; reset	animation
		sf	Routine2(a0)		; reset	2nd routine counter

Anim_End_FA:
		addq.b	#1,d0		; is the end flag = $FA	?
		bne.s	Anim_End	; if not, branch
		addq.b	#2,Routine2(a0)	; jump to next routine

Anim_End:
		rts
; End of function AnimateSprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - "PRESS START BUTTON" and "TM" from title screen
; ---------------------------------------------------------------------------
Map_obj0F:
	include "_maps\obj0F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Sonic on the title screen
; ---------------------------------------------------------------------------
Map_obj0E:
	include "_maps\obj0E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2B - Chopper enemy (GHZ)
; ---------------------------------------------------------------------------

Obj2B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj2B_Index(pc,d0.w),d1
		jsr	Obj2B_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj2B_Index:	dc.w Obj2B_Main-Obj2B_Index
		dc.w Obj2B_ChgSpeed-Obj2B_Index
; ===========================================================================

Obj2B_Main:				; XREF: Obj2B_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj2B,Mappings_Offset(a0)
		move.w	#$47B,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#9,Coll(a0)
		move.b	#$10,X_Visible(a0)
		move.w	#-$700,Y_Vel(a0)	; set vertical speed
		move.w	Y_Pos(a0),Off30(a0)

Obj2B_ChgSpeed:				; XREF: Obj2B_Index
		lea	(Ani_obj2B).l,a1
		bsr.w	AnimateSprite
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)	; reduce speed
		move.w	Off30(a0),d0
		cmp.w	Y_Pos(a0),d0
		bhs.s	Obj2B_ChgAni
		move.w	d0,Y_Pos(a0)
		move.w	#-$700,Y_Vel(a0)	; set vertical speed

Obj2B_ChgAni:
		move.b	#1,Anim(a0)	; use fast animation
		subi.w	#$C0,d0
		cmp.w	Y_Pos(a0),d0
		bhs.s	locret_ABB6
		move.b	#0,Anim(a0)	; use slow animation
		tst.w	Y_Vel(a0)		; is Chopper at	its highest point?
		bmi.s	locret_ABB6	; if not, branch
		move.b	#2,Anim(a0)	; use stationary animation

locret_ABB6:
		rts
; ===========================================================================
Ani_obj2B:
	include "_anim\obj2B.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Chopper enemy (GHZ)
; ---------------------------------------------------------------------------
Map_obj2B:
	include "_maps\obj2B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2C - Jaws enemy (LZ)
; ---------------------------------------------------------------------------

Obj2C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj2C_Index(pc,d0.w),d1
		jmp	Obj2C_Index(pc,d1.w)
; ===========================================================================
Obj2C_Index:	dc.w Obj2C_Main-Obj2C_Index
		dc.w Obj2C_Turn-Obj2C_Index
; ===========================================================================

Obj2C_Main:				; XREF: Obj2C_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj2C,Mappings_Offset(a0)
		move.w	#$2486,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$A,Coll(a0)
		move.b	#4,Priority(a0)
		move.b	#$10,X_Visible(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; load object subtype number
		lsl.w	#6,d0		; multiply d0 by 64
		subq.w	#1,d0
		move.w	d0,Off30(a0)	; set turn delay time
		move.w	d0,Off32(a0)
		move.w	#-$40,X_Vel(a0)	; move Jaws to the left
		btst	#0,Status(a0)	; is Jaws facing left?
		beq.s	Obj2C_Turn	; if yes, branch
		neg.w	X_Vel(a0)		; move Jaws to the right

Obj2C_Turn:				; XREF: Obj2C_Index
		subq.w	#1,Off30(a0)	; subtract 1 from turn delay time
		bpl.s	Obj2C_Animate	; if time remains, branch
		move.w	Off32(a0),Off30(a0)	; reset	turn delay time
		neg.w	X_Vel(a0)		; change speed direction
		bchg	#0,Status(a0)	; change Jaws facing direction
		move.b	#1,Anim_Restart(a0)	; reset	animation

Obj2C_Animate:
		lea	(Ani_obj2C).l,a1
		bsr.w	AnimateSprite
		bsr.w	ObjectMove
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj2C:
	include "_anim\obj2C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Jaws enemy (LZ)
; ---------------------------------------------------------------------------
Map_obj2C:
	include "_maps\obj2C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2D - Burrobot enemy (LZ)
; ---------------------------------------------------------------------------

Obj2D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj2D_Index(pc,d0.w),d1
		jmp	Obj2D_Index(pc,d1.w)
; ===========================================================================
Obj2D_Index:	dc.w Obj2D_Main-Obj2D_Index
		dc.w Obj2D_Action-Obj2D_Index
; ===========================================================================

Obj2D_Main:				; XREF: Obj2D_Index
		addq.b	#2,Routine(a0)
		move.b	#$13,Y_Radius(a0)
		move.b	#8,X_Radius(a0)
		move.l	#Map_obj2D,Mappings_Offset(a0)
		move.w	#$4A6,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#5,Coll(a0)
		move.b	#$C,X_Visible(a0)
		addq.b	#6,Routine2(a0)	; run "Obj2D_ChkSonic" routine
		move.b	#2,Anim(a0)

Obj2D_Action:				; XREF: Obj2D_Index
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj2D_Index2(pc,d0.w),d1
		jsr	Obj2D_Index2(pc,d1.w)
		lea	(Ani_obj2D).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj2D_Index2:	dc.w Obj2D_ChgDir-Obj2D_Index2
		dc.w Obj2D_Move-Obj2D_Index2
		dc.w Obj2D_Jump-Obj2D_Index2
		dc.w Obj2D_ChkSonic-Obj2D_Index2
; ===========================================================================

Obj2D_ChgDir:				; XREF: Obj2D_Index2
		subq.w	#1,Off30(a0)
		bpl.s	locret_AD42
		addq.b	#2,Routine2(a0)
		move.w	#$FF,Off30(a0)
		move.w	#$80,X_Vel(a0)
		move.b	#1,Anim(a0)
		bchg	#0,Status(a0)	; change direction the Burrobot	is facing
		beq.s	locret_AD42
		neg.w	X_Vel(a0)		; change direction the Burrobot	is moving

locret_AD42:
		rts
; ===========================================================================

Obj2D_Move:				; XREF: Obj2D_Index2
		subq.w	#1,Off30(a0)
		bmi.s	loc_AD84
		bsr.w	ObjectMove
		bchg	#0,Off32(a0)
		bne.s	loc_AD78
		move.w	X_pos(a0),d3
		addi.w	#$C,d3
		btst	#0,Status(a0)
		bne.s	loc_AD6A
		subi.w	#$18,d3

loc_AD6A:
		jsr	ObjHitFloor2
		cmpi.w	#$C,d1
		bge.s	loc_AD84
		rts
; ===========================================================================

loc_AD78:				; XREF: Obj2D_Move
		jsr	ObjHitFloor
		add.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

loc_AD84:				; XREF: Obj2D_Move
		btst	#2,($FFFFFE0F).w
		beq.s	loc_ADA4
		subq.b	#2,Routine2(a0)
		move.w	#$3B,Off30(a0)
		move.w	#0,X_Vel(a0)
		move.b	#0,Anim(a0)
		rts
; ===========================================================================

loc_ADA4:
		addq.b	#2,Routine2(a0)
		move.w	#-$400,Y_Vel(a0)
		move.b	#2,Anim(a0)
		rts
; ===========================================================================

Obj2D_Jump:				; XREF: Obj2D_Index2
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)
		bmi.s	locret_ADF0
		move.b	#3,Anim(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_ADF0
		add.w	d1,Y_Pos(a0)
		move.w	#0,Y_Vel(a0)
		move.b	#1,Anim(a0)
		move.w	#$FF,Off30(a0)
		subq.b	#2,Routine2(a0)
		bsr.w	Obj2D_ChkSonic2

locret_ADF0:
		rts
; ===========================================================================

Obj2D_ChkSonic:				; XREF: Obj2D_Index2
		move.w	#$60,d2
		bsr.w	Obj2D_ChkSonic2
		bhs.s	locret_AE20
		move.w	Object_RAM+Y_Pos,d0
		sub.w	Y_Pos(a0),d0
		bhs.s	locret_AE20
		cmpi.w	#-$80,d0
		blo.s	locret_AE20
		tst.b	$FFFFFE08.w
		bne.s	locret_AE20
		subq.b	#2,Routine2(a0)
		move.w	d1,X_Vel(a0)
		move.w	#-$400,Y_Vel(a0)

locret_AE20:
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj2D_ChkSonic2:			; XREF: Obj2D_ChkSonic
		move.w	#$80,d1
		bset	#0,Status(a0)
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	loc_AE40
		neg.w	d0
		neg.w	d1
		bclr	#0,Status(a0)

loc_AE40:
		cmp.w	d2,d0
		rts
; End of function Obj2D_ChkSonic2

; ===========================================================================
Ani_obj2D:
	include "_anim\obj2D.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Burrobot enemy (LZ)
; ---------------------------------------------------------------------------
Map_obj2D:
	include "_maps\obj2D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2F - large moving platforms (MZ)
; ---------------------------------------------------------------------------

Obj2F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj2F_Index(pc,d0.w),d1
		jmp	Obj2F_Index(pc,d1.w)
; ===========================================================================
Obj2F_Index:	dc.w Obj2F_Main-Obj2F_Index
		dc.w Obj2F_Action-Obj2F_Index

Obj2F_Data:	dc.w Obj2F_Data1-Obj2F_Data 	; collision angle data
		dc.b 0,	$40			; frame	number,	platform width
		dc.w Obj2F_Data3-Obj2F_Data
		dc.b 1,	$40
		dc.w Obj2F_Data2-Obj2F_Data
		dc.b 2,	$20
; ===========================================================================

Obj2F_Main:				; XREF: Obj2F_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj2F,Mappings_Offset(a0)
		move.w	#$C000,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#5,Priority(a0)
		move.w	Y_Pos(a0),Off2C(a0)
		move.w	X_pos(a0),$2A(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	Obj2F_Data(pc,d0.w),a1
		move.w	(a1)+,d0
		lea	Obj2F_Data(pc,d0.w),a2
		move.l	a2,Off30(a0)
		move.b	(a1)+,Anim_Frame(a0)
		move.b	(a1),X_Visible(a0)
		andi.b	#$F,Subtype(a0)
		move.b	#$40,Y_Radius(a0)
		bset	#4,Render_Flags(a0)

Obj2F_Action:				; XREF: Obj2F_Index
		bsr.w	Obj2F_Types
		tst.b	Routine2(a0)
		beq.s	Obj2F_Solid
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		bsr.w	ExitPlatform
		btst	#3,Status(a1)
		bne.w	Obj2F_Slope
		sf	Routine2(a0)
		bra.s	Obj2F_Display
; ===========================================================================

Obj2F_Slope:				; XREF: Obj2F_Action
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		movea.l	Off30(a0),a2
		move.w	X_pos(a0),d2
		bsr.w	SlopeObject2
		bra.s	Obj2F_Display
; ===========================================================================

Obj2F_Solid:				; XREF: Obj2F_Action
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		move.w	#$20,d2
		cmpi.b	#2,Anim_Frame(a0)
		bne.s	loc_AF8E
		move.w	#$30,d2

loc_AF8E:
		movea.l	Off30(a0),a2
		bsr.w	SolidObject2F

Obj2F_Display:				; XREF: Obj2F_Action
		bsr.w	DisplaySprite
		bra.w	Obj2F_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj2F_Types:				; XREF: Obj2F_Action
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj2F_TypeIndex(pc,d0.w),d1
		jmp	Obj2F_TypeIndex(pc,d1.w)
; End of function Obj2F_Types

; ===========================================================================
Obj2F_TypeIndex:dc.w Obj2F_Type00-Obj2F_TypeIndex
		dc.w Obj2F_Type01-Obj2F_TypeIndex
		dc.w Obj2F_Type02-Obj2F_TypeIndex
		dc.w Obj2F_Type03-Obj2F_TypeIndex
		dc.w Obj2F_Type04-Obj2F_TypeIndex
		dc.w Obj2F_Type05-Obj2F_TypeIndex
; ===========================================================================

Obj2F_Type00:				; XREF: Obj2F_TypeIndex
		rts			; type 00 platform doesn't move
; ===========================================================================

Obj2F_Type01:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE60).w,d0
		move.w	#$20,d1
		bra.s	Obj2F_Move
; ===========================================================================

Obj2F_Type02:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE64).w,d0
		move.w	#$30,d1
		bra.s	Obj2F_Move
; ===========================================================================

Obj2F_Type03:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE68).w,d0
		move.w	#$40,d1
		bra.s	Obj2F_Move
; ===========================================================================

Obj2F_Type04:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE6C).w,d0
		move.w	#$60,d1

Obj2F_Move:
		btst	#3,Subtype(a0)
		beq.s	loc_AFF2
		neg.w	d0
		add.w	d1,d0

loc_AFF2:
		move.w	Off2C(a0),d1
		sub.w	d0,d1
		move.w	d1,Y_Pos(a0)	; update position on y-axis
		rts
; ===========================================================================

Obj2F_Type05:				; XREF: Obj2F_TypeIndex
		move.b	Off34(a0),d1
		tst.b	Routine2(a0)
		bne.s	loc_B010
		subq.b	#2,d1
		bhs.s	loc_B01C
		moveq	#0,d1
		bra.s	loc_B01C
; ===========================================================================

loc_B010:
		addq.b	#4,d1
		cmpi.b	#$40,d1
		blo.s	loc_B01C
		move.b	#$40,d1

loc_B01C:
		move.b	d1,Off34(a0)
		jsr	(CalcSine).l
		lsr.w	#4,d0
		move.w	d0,d1
		add.w	Off2C(a0),d0
		move.w	d0,Y_Pos(a0)
		cmpi.b	#$20,Off34(a0)
		bne.s	loc_B07A
		tst.b	Off35(a0)
		bne.s	loc_B07A
		move.b	#1,Off35(a0)
		bsr.w	SingleObjLoad2
		bne.s	loc_B07A
		move.b	#$35,0(a1)	; load sitting flame object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Off2C(a0),Off2C(a1)
		addq.w	#8,Off2C(a1)
		subq.w	#3,Off2C(a1)
		subi.w	#$40,X_pos(a1)
		move.l	Off30(a0),Off30(a1)
		move.l	a0,Off38(a1)
		movea.l	a0,a2
		bsr.s	sub_B09C

loc_B07A:
		moveq	#0,d2
		lea	Off36(a0),a2
		move.b	(a2)+,d2
		subq.b	#1,d2
		blo.s	locret_B09A

loc_B086:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.w	#-$3000,d0
		movea.w	d0,a1
		move.w	d1,Off3C(a1)
		dbf	d2,loc_B086

locret_B09A:
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_B09C:
		lea	Off36(a2),a2
		moveq	#0,d0
		move.b	(a2),d0
		addq.b	#1,(a2)
		lea	1(a2,d0.w),a2
		move.w	a1,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,(a2)
		rts
; End of function sub_B09C

; ===========================================================================

Obj2F_ChkDel:				; XREF: Obj2F_Display
		tst.b	Off35(a0)
		beq.s	loc_B0C6
		tst.b	Render_Flags(a0)
		bpl.s	Obj2F_DelFlames

loc_B0C6:
		move.w	$2A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================

Obj2F_DelFlames:			; XREF: Obj2F_ChkDel
		moveq	#0,d2

loc_B0E8:
		lea	Off36(a0),a2
		move.b	(a2),d2
		sf	(a2)+
		subq.b	#1,d2
		blo.s	locret_B116

loc_B0F4:
		moveq	#0,d0
		move.b	(a2),d0
		sf	(a2)+
		lsl.w	#6,d0
		addi.w	#-$3000,d0
		movea.w	d0,a1
		bsr.w	DeleteObject2
		dbf	d2,loc_B0F4
		move.b	#0,Off35(a0)
		move.b	#0,Off34(a0)

locret_B116:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Collision data for large moving platforms (MZ)
; ---------------------------------------------------------------------------
Obj2F_Data1:	incbin	misc\mz_pfm1.bin
		even
Obj2F_Data2:	incbin	misc\mz_pfm2.bin
		even
Obj2F_Data3:	incbin	misc\mz_pfm3.bin
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 35 - fireball that sits on the	floor (MZ)
; (appears when	you walk on sinking platforms)
; ---------------------------------------------------------------------------

Obj35:					; XREF: Obj_Index
		sf	Coll(a0)
	        cmpi.b	#4,Shield_RAM+Inertia
	        beq	.fire
		move.b	#$8B,Coll(a0)

.fire		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj35_Index(pc,d0.w),d1
		jmp	Obj35_Index(pc,d1.w)
; ===========================================================================
Obj35_Index:	dc.w Obj35_Main-Obj35_Index
		dc.w loc_B238-Obj35_Index
		dc.w Obj35_Move-Obj35_Index
; ===========================================================================

Obj35_Main:				; XREF: Obj35_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj14,Mappings_Offset(a0)
		move.w	#$345,Art_Tile(a0)
		move.w	X_pos(a0),$2A(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#1,Priority(a0)
		move.b	#8,X_Visible(a0)
		move.w	#$C8,d0
		jsr	(PlaySound).l ;	play flame sound
		tst.b	Subtype(a0)
		beq.s	loc_B238
		addq.b	#2,Routine(a0)
		bra.w	Obj35_Move
; ===========================================================================

loc_B238:				; XREF: Obj35_Index
		movea.l	Off30(a0),a1
		move.w	X_pos(a0),d1
		sub.w	$2A(a0),d1
		addi.w	#$C,d1
		move.w	d1,d0
		lsr.w	#1,d0
		move.b	(a1,d0.w),d0
		neg.w	d0
		add.w	Off2C(a0),d0
		move.w	d0,d2
		add.w	Off3C(a0),d0
		move.w	d0,Y_Pos(a0)
		cmpi.w	#$84,d1
		bhs.s	loc_B2B0
		addi.l	#$10000,X_pos(a0)
		cmpi.w	#$80,d1
		bhs.s	loc_B2B0
		move.l	X_pos(a0),d0
		addi.l	#$80000,d0
		andi.l	#$FFFFF,d0
		bne.s	loc_B2B0
		bsr.w	SingleObjLoad2
		bne.s	loc_B2B0
		move.b	#$35,0(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.w	d2,Off2C(a1)
		move.w	Off3C(a0),Off3C(a1)
		move.b	#1,Subtype(a1)
		movea.l	Off38(a0),a2
		bsr.w	sub_B09C

loc_B2B0:
		bra.s	Obj35_Animate
; ===========================================================================

Obj35_Move:				; XREF: Obj35_Index
		move.w	Off2C(a0),d0
		add.w	Off3C(a0),d0
		move.w	d0,Y_Pos(a0)

Obj35_Animate:				; XREF: loc_B238
		lea	(Ani_obj35).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj35:
	include "_anim\obj35.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - large moving platforms (MZ)
; ---------------------------------------------------------------------------
Map_obj2F:
	include "_maps\obj2F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - lava balls (MZ, SLZ)
; ---------------------------------------------------------------------------
Map_obj14:
	include "_maps\obj14.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 30 - large green glassy blocks	(MZ)
; ---------------------------------------------------------------------------

Obj30:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj30_Index(pc,d0.w),d1
		jsr	Obj30_Index(pc,d1.w)
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj30_Delete
		bra.w	DisplaySprite
; ===========================================================================

Obj30_Delete:
		bra.w	DeleteObject
; ===========================================================================
Obj30_Index:	dc.w Obj30_Main-Obj30_Index
		dc.w Obj30_Block012-Obj30_Index
		dc.w Obj30_Reflect012-Obj30_Index
		dc.w Obj30_Block34-Obj30_Index
		dc.w Obj30_Reflect34-Obj30_Index

Obj30_Vars1:	dc.b 2,	0, 0	; routine num, y-axis dist from	origin,	frame num
		dc.b 4,	0, 1
Obj30_Vars2:	dc.b 6,	0, 2
		dc.b 8,	0, 1
; ===========================================================================

Obj30_Main:				; XREF: Obj30_Index
		lea	(Obj30_Vars1).l,a2
		moveq	#1,d1
		move.b	#$48,Y_Radius(a0)
		cmpi.b	#3,Subtype(a0)	; is object type 0/1/2 ?
		blo.s	loc_B40C	; if yes, branch
		lea	(Obj30_Vars2).l,a2
		moveq	#1,d1
		move.b	#$38,Y_Radius(a0)

loc_B40C:
		movea.l	a0,a1
		bra.s	Obj30_Load	; load main object
; ===========================================================================

Obj30_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_B480

Obj30_Load:				; XREF: Obj30_Main
		move.b	(a2)+,Routine(a1)
		move.b	#$30,0(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	Y_Pos(a0),d0
		move.w	d0,Y_Pos(a1)
		move.l	#Map_obj30,Mappings_Offset(a1)
		move.w	#$C38E,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.w	Y_Pos(a1),Off30(a1)
		move.b	Subtype(a0),Subtype(a1)
		move.b	#$20,X_Visible(a1)
		move.b	#4,Priority(a1)
		move.b	(a2)+,Anim_Frame(a1)
		move.l	a0,Off3C(a1)
		dbf	d1,Obj30_Loop	; repeat once to load "reflection object"

		move.b	#$10,X_Visible(a1)
		move.b	#3,Priority(a1)
		addq.b	#8,Subtype(a1)
		andi.b	#$F,Subtype(a1)

loc_B480:
		move.w	#$90,Off32(a0)
		bset	#4,Render_Flags(a0)

Obj30_Block012:				; XREF: Obj30_Index
		bsr.w	Obj30_Types
		move.w	#$2B,d1
		move.w	#$48,d2
		move.w	#$49,d3
		move.w	X_pos(a0),d4
		bra.w	SolidObject
; ===========================================================================

Obj30_Reflect012:			; XREF: Obj30_Index
		movea.l	Off3C(a0),a1
		move.w	Off32(a1),Off32(a0)
		bra.w	Obj30_Types
; ===========================================================================

Obj30_Block34:				; XREF: Obj30_Index
		bsr.w	Obj30_Types
		move.w	#$2B,d1
		move.w	#$38,d2
		move.w	#$39,d3
		move.w	X_pos(a0),d4
		bra.w	SolidObject
; ===========================================================================

Obj30_Reflect34:			; XREF: Obj30_Index
		movea.l	Off3C(a0),a1
		move.w	Off32(a1),Off32(a0)
		move.w	Y_Pos(a1),Off30(a0)
		bra.w	*+4

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj30_Types:				; XREF: Obj30_Block012; et al
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj30_TypeIndex(pc,d0.w),d1
		jmp	Obj30_TypeIndex(pc,d1.w)
; End of function Obj30_Types

; ===========================================================================
Obj30_TypeIndex:dc.w Obj30_Type00-Obj30_TypeIndex
		dc.w Obj30_Type01-Obj30_TypeIndex
		dc.w Obj30_Type02-Obj30_TypeIndex
		dc.w Obj30_Type03-Obj30_TypeIndex
		dc.w Obj30_Type04-Obj30_TypeIndex
; ===========================================================================

Obj30_Type00:				; XREF: Obj30_TypeIndex
		rts
; ===========================================================================

Obj30_Type01:				; XREF: Obj30_TypeIndex
		move.b	($FFFFFE70).w,d0
		move.w	#$40,d1
		bra.s	loc_B514
; ===========================================================================

Obj30_Type02:				; XREF: Obj30_TypeIndex
		move.b	($FFFFFE70).w,d0
		move.w	#$40,d1
		neg.w	d0
		add.w	d1,d0

loc_B514:				; XREF: Obj30_Type01
		btst	#3,Subtype(a0)
		beq.s	loc_B526
		neg.w	d0
		add.w	d1,d0
		lsr.b	#1,d0
		addi.w	#$20,d0

loc_B526:
		bra.w	loc_B5EE
; ===========================================================================

Obj30_Type03:				; XREF: Obj30_TypeIndex
		btst	#3,Subtype(a0)
		beq.s	loc_B53E
		move.b	($FFFFFE70).w,d0
		subi.w	#$10,d0
		bra.w	loc_B5EE
; ===========================================================================

loc_B53E:
		btst	#3,Status(a0)
		bne.s	loc_B54E
		bclr	#0,Off34(a0)
		bra.s	loc_B582
; ===========================================================================

loc_B54E:
		tst.b	Off34(a0)
		bne.s	loc_B582
		move.b	#1,Off34(a0)
		bset	#0,Off35(a0)
		beq.s	loc_B582
		bset	#7,Off34(a0)
		move.w	#$10,Off36(a0)
		move.b	#$A,Off38(a0)
		cmpi.w	#$40,Off32(a0)
		bne.s	loc_B582
		move.w	#$40,Off36(a0)

loc_B582:
		tst.b	Off34(a0)
		bpl.s	loc_B5AA
		tst.b	Off38(a0)
		beq.s	loc_B594
		subq.b	#1,Off38(a0)
		bne.s	loc_B5AA

loc_B594:
		tst.w	Off32(a0)
		beq.s	loc_B5A4
		subq.w	#1,Off32(a0)
		subq.w	#1,Off36(a0)
		bne.s	loc_B5AA

loc_B5A4:
		bclr	#7,Off34(a0)

loc_B5AA:
		move.w	Off32(a0),d0
		bra.s	loc_B5EE
; ===========================================================================

Obj30_Type04:				; XREF: Obj30_TypeIndex
		btst	#3,Subtype(a0)
		beq.s	Obj30_ChkSwitch
		move.b	($FFFFFE70).w,d0
		subi.w	#$10,d0
		bra.s	loc_B5EE
; ===========================================================================

Obj30_ChkSwitch:			; XREF: Obj30_Type04
		tst.b	Off34(a0)
		bne.s	loc_B5E0
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	Subtype(a0),d0	; load object type number
		lsr.w	#4,d0		; read only the	first nybble
		tst.b	(a2,d0.w)	; has switch number d0 been pressed?
		beq.s	loc_B5EA	; if not, branch
		move.b	#1,Off34(a0)

loc_B5E0:
		tst.w	Off32(a0)
		beq.s	loc_B5EA
		subq.w	#2,Off32(a0)

loc_B5EA:
		move.w	Off32(a0),d0

loc_B5EE:
		move.w	Off30(a0),d1
		sub.w	d0,d1
		move.w	d1,Y_Pos(a0)
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - large green	glassy blocks (MZ)
; ---------------------------------------------------------------------------
Map_obj30:
	include "_maps\obj30.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 31 - stomping metal blocks on chains (MZ)
; ---------------------------------------------------------------------------

Obj31:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj31_Index(pc,d0.w),d1
		jmp	Obj31_Index(pc,d1.w)
; ===========================================================================
Obj31_Index:	dc.w Obj31_Main-Obj31_Index
		dc.w loc_B798-Obj31_Index
		dc.w loc_B7FE-Obj31_Index
		dc.w Obj31_Display2-Obj31_Index
		dc.w loc_B7E2-Obj31_Index

Obj31_SwchNums:	dc.b 0,	0		; switch number, obj number
		dc.b 1,	0

Obj31_Var:	dc.b 2,	0, 0		; XREF: ROM:0000B6E0o
		dc.b 4,	$1C, 1		; routine number, y-position, frame number
		dc.b 8,	$CC, 3
		dc.b 6,	$F0, 2

word_B6A4:	dc.w $7000, $A000
		dc.w $5000, $7800
		dc.w $3800, $5800
		dc.w $B800
; ===========================================================================

Obj31_Main:				; XREF: Obj31_Index
		moveq	#0,d0
		move.b	Subtype(a0),d0
		bpl.s	loc_B6CE
		andi.w	#$7F,d0
		add.w	d0,d0
		lea	Obj31_SwchNums(pc,d0.w),a2
		move.b	(a2)+,Off3A(a0)
		move.b	(a2)+,d0
		move.b	d0,Subtype(a0)

loc_B6CE:
		andi.b	#$F,d0
		add.w	d0,d0
		move.w	word_B6A4(pc,d0.w),d2
		tst.w	d0
		bne.s	loc_B6E0
		move.w	d2,Off32(a0)

loc_B6E0:
		lea	(Obj31_Var).l,a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj31_MakeStomper
; ===========================================================================

Obj31_Loop:
		bsr.w	SingleObjLoad2
		bne.w	Obj31_SetSize

Obj31_MakeStomper:			; XREF: Obj31_Main
		move.b	(a2)+,Routine(a1)
		move.b	#$31,(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	Y_Pos(a0),d0
		move.w	d0,Y_Pos(a1)
		move.l	#Map_obj31,Mappings_Offset(a1)
		move.w	#$300,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.w	Y_Pos(a1),Off30(a1)
		move.b	Subtype(a0),Subtype(a1)
		move.b	#$10,X_Visible(a1)
		move.w	d2,Off34(a1)
		move.b	#4,Priority(a1)
		move.b	(a2)+,Anim_Frame(a1)
		cmpi.b	#1,Anim_Frame(a1)
		bne.s	loc_B76A
		subq.w	#1,d1
		move.b	Subtype(a0),d0
		andi.w	#$F0,d0
		cmpi.w	#$20,d0
		beq.s	Obj31_MakeStomper
		move.b	#$38,X_Visible(a1)
		move.b	#$90,Coll(a1)
		addq.w	#1,d1

loc_B76A:
		move.l	a0,Off3C(a1)
		dbf	d1,Obj31_Loop

		move.b	#3,Priority(a1)

Obj31_SetSize:
		moveq	#0,d0
		move.b	Subtype(a0),d0
		lsr.w	#3,d0
		andi.b	#$E,d0
		lea	Obj31_Var2(pc,d0.w),a2
		move.b	(a2)+,X_Visible(a0)
		move.b	(a2)+,Anim_Frame(a0)
		bra.s	loc_B798
; ===========================================================================
Obj31_Var2:	dc.b $38, 0		; width, frame number
		dc.b $30, 9
		dc.b $10, $A
; ===========================================================================

loc_B798:				; XREF: Obj31_Index
		bsr.w	Obj31_Types
		move.w	Y_Pos(a0),($FFFFF7A4).w
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		move.w	#$C,d2
		move.w	#$D,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		btst	#3,Status(a0)
		beq.s	Obj31_Display
		cmpi.b	#$10,Off32(a0)
		bhs.s	Obj31_Display
		movea.l	a0,a2
		lea	Object_RAM,a0
		jsr	KillSonic
		movea.l	a2,a0

Obj31_Display:
		bsr.w	DisplaySprite
		bra.w	Obj31_ChkDel
; ===========================================================================

loc_B7E2:				; XREF: Obj31_Index
		move.b	#$80,Y_Radius(a0)
		bset	#4,Render_Flags(a0)
		movea.l	Off3C(a0),a1
		move.b	Off32(a1),d0
		lsr.b	#5,d0
		addq.b	#3,d0
		move.b	d0,Anim_Frame(a0)

loc_B7FE:				; XREF: Obj31_Index
		movea.l	Off3C(a0),a1
		moveq	#0,d0
		move.b	Off32(a1),d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)

Obj31_Display2:				; XREF: Obj31_Index
		bsr.w	DisplaySprite

Obj31_ChkDel:				; XREF: Obj31_Display
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================

Obj31_Types:				; XREF: loc_B798
		move.b	Subtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj31_TypeIndex(pc,d0.w),d1
		jmp	Obj31_TypeIndex(pc,d1.w)
; ===========================================================================
Obj31_TypeIndex:dc.w Obj31_Type00-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
		dc.w Obj31_Type03-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
		dc.w Obj31_Type03-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
; ===========================================================================

Obj31_Type00:				; XREF: Obj31_TypeIndex
		lea	($FFFFF7E0).w,a2 ; load	switch statuses
		moveq	#0,d0
		move.b	Off3A(a0),d0	; move number 0	or 1 to	d0
		tst.b	(a2,d0.w)	; has switch (d0) been pressed?
		beq.s	loc_B8A8	; if not, branch
		tst.w	($FFFFF7A4).w
		bpl.s	loc_B872
		cmpi.b	#$10,Off32(a0)
		beq.s	loc_B8A0

loc_B872:
		tst.w	Off32(a0)
		beq.s	loc_B8A0
		move.b	($FFFFFE0F).w,d0
		andi.b	#$F,d0
		bne.s	loc_B892
		tst.b	Render_Flags(a0)
		bpl.s	loc_B892
		move.w	#$C7,d0
		jsr	(PlaySound).l ;	play rising chain sound

loc_B892:
		subi.w	#$80,Off32(a0)
		bhs.s	Obj31_Restart
		move.w	#0,Off32(a0)

loc_B8A0:
		move.w	#0,Y_Vel(a0)
		bra.s	Obj31_Restart
; ===========================================================================

loc_B8A8:				; XREF: Obj31_Type00
		move.w	Off34(a0),d1
		cmp.w	Off32(a0),d1
		beq.s	Obj31_Restart
		move.w	Y_Vel(a0),d0
		addi.w	#$70,Y_Vel(a0)	; make object fall
		add.w	d0,Off32(a0)
		cmp.w	Off32(a0),d1
		bhi.s	Obj31_Restart
		move.w	d1,Off32(a0)
		move.w	#0,Y_Vel(a0)	; stop object falling
		tst.b	Render_Flags(a0)
		bpl.s	Obj31_Restart
		move.w	#$BD,d0
		jsr	(PlaySound).l ;	play stomping sound

Obj31_Restart:
		moveq	#0,d0
		move.b	Off32(a0),d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)
		rts
; ===========================================================================

Obj31_Type01:				; XREF: Obj31_TypeIndex
		tst.w	Off36(a0)
		beq.s	loc_B938
		tst.w	Off38(a0)
		beq.s	loc_B902
		subq.w	#1,Off38(a0)
		bra.s	loc_B97C
; ===========================================================================

loc_B902:
		move.b	($FFFFFE0F).w,d0
		andi.b	#$F,d0
		bne.s	loc_B91C
		tst.b	Render_Flags(a0)
		bpl.s	loc_B91C
		move.w	#$C7,d0
		jsr	(PlaySound).l ;	play rising chain sound

loc_B91C:
		subi.w	#$80,Off32(a0)
		bhs.s	loc_B97C
		move.w	#0,Off32(a0)
		move.w	#0,Y_Vel(a0)
		move.w	#0,Off36(a0)
		bra.s	loc_B97C
; ===========================================================================

loc_B938:				; XREF: Obj31_Type01
		move.w	Off34(a0),d1
		cmp.w	Off32(a0),d1
		beq.s	loc_B97C
		move.w	Y_Vel(a0),d0
		addi.w	#$70,Y_Vel(a0)	; make object fall
		add.w	d0,Off32(a0)
		cmp.w	Off32(a0),d1
		bhi.s	loc_B97C
		move.w	d1,Off32(a0)
		move.w	#0,Y_Vel(a0)	; stop object falling
		move.w	#1,Off36(a0)
		move.w	#$3C,Off38(a0)
		tst.b	Render_Flags(a0)
		bpl.s	loc_B97C
		move.w	#$BD,d0
		jsr	(PlaySound).l ;	play stomping sound

loc_B97C:
		bra.w	Obj31_Restart
; ===========================================================================

Obj31_Type03:				; XREF: Obj31_TypeIndex
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	loc_B98C
		neg.w	d0

loc_B98C:
		cmpi.w	#$90,d0
		bhs.s	loc_B996
		addq.b	#1,Subtype(a0)

loc_B996:
		bra.w	Obj31_Restart
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 45 - spiked metal block from beta version (MZ)
; ---------------------------------------------------------------------------

Obj45:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj45_Index(pc,d0.w),d1
		jmp	Obj45_Index(pc,d1.w)
; ===========================================================================
Obj45_Index:	dc.w Obj45_Main-Obj45_Index
		dc.w Obj45_Solid-Obj45_Index
		dc.w loc_BA8E-Obj45_Index
		dc.w Obj45_Display-Obj45_Index
		dc.w loc_BA7A-Obj45_Index

Obj45_Var:	dc.b	2,   4,	  0	; routine number, x-position, frame number
		dc.b	4, $E4,	  1
		dc.b	8, $34,	  3
		dc.b	6, $28,	  2

word_B9BE:	dc.w $3800
		dc.w -$6000
		dc.w $5000
; ===========================================================================

Obj45_Main:				; XREF: Obj45_Index
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		move.w	word_B9BE(pc,d0.w),d2
		lea	(Obj45_Var).l,a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj45_Load
; ===========================================================================

Obj45_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_BA52

Obj45_Load:				; XREF: Obj45_Main
		move.b	(a2)+,Routine(a1)
		move.b	#$45,0(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	X_pos(a0),d0
		move.w	d0,X_pos(a1)
		move.l	#Map_obj45,Mappings_Offset(a1)
		move.w	#$300,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.w	X_pos(a1),Off30(a1)
		move.w	X_pos(a0),Off3A(a1)
		move.b	Subtype(a0),Subtype(a1)
		move.b	#$20,X_Visible(a1)
		move.w	d2,Off34(a1)
		move.b	#4,Priority(a1)
		cmpi.b	#1,(a2)
		bne.s	loc_BA40
		move.b	#$91,Coll(a1)

loc_BA40:
		move.b	(a2)+,Anim_Frame(a1)
		move.l	a0,Off3C(a1)
		dbf	d1,Obj45_Loop	; repeat 3 times

		move.b	#3,Priority(a1)

loc_BA52:
		move.b	#$10,X_Visible(a0)

Obj45_Solid:				; XREF: Obj45_Index
		move.w	X_pos(a0),-(sp)
		bsr.w	Obj45_Move
		move.w	#$17,d1
		move.w	#$20,d2
		move.w	#$20,d3
		move.w	(sp)+,d4
		bsr.w	SolidObject
		bsr.w	DisplaySprite
		bra.w	Obj45_ChkDel
; ===========================================================================

loc_BA7A:				; XREF: Obj45_Index
		movea.l	Off3C(a0),a1
		move.b	Off32(a1),d0
		addi.b	#$10,d0
		lsr.b	#5,d0
		addq.b	#3,d0
		move.b	d0,Anim_Frame(a0)

loc_BA8E:				; XREF: Obj45_Index
		movea.l	Off3C(a0),a1
		moveq	#0,d0
		move.b	Off32(a1),d0
		neg.w	d0
		add.w	Off30(a0),d0
		move.w	d0,X_pos(a0)

Obj45_Display:				; XREF: Obj45_Index
		bsr.w	DisplaySprite

Obj45_ChkDel:				; XREF: Obj45_Solid
		move.w	Off3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj45_Move:				; XREF: Obj45_Solid
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		move.w	off_BAD6(pc,d0.w),d1
		jmp	off_BAD6(pc,d1.w)
; End of function Obj45_Move

; ===========================================================================
off_BAD6:	dc.w loc_BADA-off_BAD6
		dc.w loc_BADA-off_BAD6
; ===========================================================================

loc_BADA:				; XREF: off_BAD6
		tst.w	Off36(a0)
		beq.s	loc_BB08
		tst.w	Off38(a0)
		beq.s	loc_BAEC
		subq.w	#1,Off38(a0)
		bra.s	loc_BB3C
; ===========================================================================

loc_BAEC:
		subi.w	#$80,Off32(a0)
		bhs.s	loc_BB3C
		move.w	#0,Off32(a0)
		move.w	#0,X_Vel(a0)
		move.w	#0,Off36(a0)
		bra.s	loc_BB3C
; ===========================================================================

loc_BB08:				; XREF: loc_BADA
		move.w	Off34(a0),d1
		cmp.w	Off32(a0),d1
		beq.s	loc_BB3C
		move.w	X_Vel(a0),d0
		addi.w	#$70,X_Vel(a0)
		add.w	d0,Off32(a0)
		cmp.w	Off32(a0),d1
		bhi.s	loc_BB3C
		move.w	d1,Off32(a0)
		move.w	#0,X_Vel(a0)
		move.w	#1,Off36(a0)
		move.w	#$3C,Off38(a0)

loc_BB3C:
		moveq	#0,d0
		move.b	Off32(a0),d0
		neg.w	d0
		add.w	Off30(a0),d0
		move.w	d0,X_pos(a0)
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - metal stomping blocks on chains (MZ)
; ---------------------------------------------------------------------------
Map_obj31:
	include "_maps\obj31.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spiked metal block from beta version (MZ)
; ---------------------------------------------------------------------------
Map_obj45:
	include "_maps\obj45.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 32 - switches (MZ, SYZ, LZ, SBZ)
; ---------------------------------------------------------------------------

Obj32:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj32_Index(pc,d0.w),d1
		jmp	Obj32_Index(pc,d1.w)
; ===========================================================================
Obj32_Index:	dc.w Obj32_Main-Obj32_Index
		dc.w Obj32_Pressed-Obj32_Index
; ===========================================================================

Obj32_Main:				; XREF: Obj32_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj32,Mappings_Offset(a0)
		move.w	#$513,Art_Tile(a0)	; SYZ, LZ and SBZ specific code
		cmpi.b	#2,($FFFFFE10).w
		bne.s	loc_BD60
		ori.b	#$40,Art_Tile(a0)	; MZ specific codee

loc_BD60:
		move.b	#4,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#4,Priority(a0)
		addq.w	#3,Y_Pos(a0)

Obj32_Pressed:				; XREF: Obj32_Index
		tst.b	Render_Flags(a0)
		bpl	Obj32_Display
		move.w	#$1B,d1
		move.w	#5,d2
		move.w	#5,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		bclr	#0,Anim_Frame(a0)	; use "unpressed" frame
		move.b	Subtype(a0),d0
		andi.w	#$F,d0
		lea	($FFFFF7E0).w,a3
		lea	(a3,d0.w),a3
		moveq	#0,d3
		btst	#6,Subtype(a0)
		beq.s	loc_BDB2
		moveq	#7,d3

loc_BDB2:
		tst.b	Subtype(a0)
		bpl	loc_BDBE
		bsr.w	Obj32_MZBlock
		bne	loc_BDC8

loc_BDBE:
		tst.b	Routine2(a0)
		bne	loc_BDC8
		bclr	d3,(a3)
		bra	loc_BDDE
; ===========================================================================
Obj32_Nostand:
		move.b  #0,Off3F(a0)		; clear pressing state
		bra	Obj32_Display		; display

SetPlayerDisplay:
		moveq	#0,d0
		move.b	Current_Character.w,d0	; get char id
		lsl.w	#1,d0
		move.l	PlayerSizeList(pc,d0.w),Player_StandHeight.w
		move.w	Player_StandHeight.w,Y_Radius(a0); set radius
		lsl.w	#3,d0			; mulptiply by 16
		lea	PlayerDataList(pc,d0.w),a2; get the table to a2

		move.l	(a2)+,Player_ArtLoc.w	; player art location
		move.l	(a2)+,Player_MapLoc.w	; get mappings
		move.l	(a2)+,Player_DPLCLoc.w	; FPLC location
		move.l	(a2)+,Player_AniDat.w	; Animation data location
		move.l	(a2)+,PAni_Roll.w	; roll ani
		move.l	(a2)+,PAni_Roll2.w	; roll ani
		move.l	(a2)+,PAni_Push.w	; push ani
                move.w	2(a2),Player_JumpHeight.w; jump height
                move.b	1(a2),Player_SpecTouAni.w; set special touch animation id

		move.l	Player_MapLoc.w,4(a0)	; set mappings
.LoadPallets	lea	Palette_Ncurr.w,a2	; normal pallet
		lea	Palette_UCurr.w,a3	; underwater pallet
		jmp	LoadPlayerPallets	; load pallets

; y-radius stand, x-radius stand, y-radius roll, x-radius roll
PlayerSizeList:
		dc.b $13, 9, $E, 7
		dc.b $F,  9, $C, 9
		dc.b $13, 9, $E, 7
		dc.b $13, 9, $E, 7

		;   art file, mappings file, DPLC file, ani file, Roll ani, Roll2 ani, Push ani, *
		; * = first byte (Overwold VRAM data), Special touch animation id, 2nd word (Jump height)
PlayerDataList:	dc.l Art_Sonic,Map_Sonic,SonicDynPLC,SonicAniData,SonAni_Roll,SonAni_Roll2,SonAni_Push,$7020400
		dc.l Art_Tails,Map_Tails,TailsDynPLC,TailsAniData,TailsAni_Roll,TailsAni_Roll2,TailsAni_Push,$67020440
		dc.l Art_Knux,Map_Knux,KnuxDynPLC,KnuxAniData,Knux_Roll,Knux_Roll2,Knux_Push,$272003C0
		dc.l Art_Sonic,Map_Sonic,SonicDynPLC,SonicAniData,SonAni_Roll,SonAni_Roll2,SonAni_Push,$7020400

; ===========================================================================
loc_BDC8:
		tst.b	(a3)
		bne.s	loc_BDD6
		move.w	#$CD,d0
		jsr	(PlaySound).l ;	play switch sound

loc_BDD6:
		bset	d3,(a3)
		bset	#0,Anim_Frame(a0)	; use "pressed"	frame

loc_BDDE:
		btst	#5,Subtype(a0)
		beq.s	Obj32_Display
		subq.b	#1,Anim_Dur(a0)
		bpl.s	Obj32_Display
		move.b	#7,Anim_Dur(a0)
		bchg	#1,Anim_Frame(a0)

Obj32_Display:
		bsr.w	DisplaySprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj32_Delete
		rts
; ===========================================================================

Obj32_Delete:
		bra	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj32_MZBlock:				; XREF: Obj32_Pressed
		move.w	d3,-(sp)
		move.w	X_pos(a0),d2
		move.w	Y_Pos(a0),d3
		subi.w	#$10,d2
		subq.w	#8,d3
		move.w	#$20,d4
		move.w	#$10,d5
		lea	Object_RAM_Free,a1 ; begin checking object RAM
		move.w	#$5F,d6

Obj32_MZLoop:
		tst.b	Render_Flags(a1)
		bpl.s	loc_BE4E
		cmpi.b	#$33,(a1)	; is the object	a green	MZ block?
		beq.s	loc_BE5E	; if yes, branch

loc_BE4E:
		lea	Next_Obj(a1),a1	; check	next object
		dbf	d6,Obj32_MZLoop	; repeat $5F times

		move.w	(sp)+,d3
		moveq	#0,d0

locret_BE5A:
		rts
; ===========================================================================
Obj32_MZData:	dc.b $10, $10
; ===========================================================================

loc_BE5E:				; XREF: Obj32_MZBlock
		moveq	#1,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		lea	Obj32_MZData-2(pc,d0.w),a2
		move.b	(a2)+,d1
		ext.w	d1
		move.w	X_pos(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bhs.s	loc_BE80
		add.w	d1,d1
		add.w	d1,d0
		blo.s	loc_BE84
		bra.s	loc_BE4E
; ===========================================================================

loc_BE80:
		cmp.w	d4,d0
		bhi.s	loc_BE4E

loc_BE84:
		move.b	(a2)+,d1
		ext.w	d1
		move.w	Y_Pos(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bhs.s	loc_BE9A
		add.w	d1,d1
		add.w	d1,d0
		blo.s	loc_BE9E
		bra.s	loc_BE4E
; ===========================================================================

loc_BE9A:
		cmp.w	d5,d0
		bhi.s	loc_BE4E

loc_BE9E:
		move.w	(sp)+,d3
		moveq	#1,d0
		rts
; End of function Obj32_MZBlock

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - switches (MZ, SYZ, LZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj32:
	include "_maps\obj32.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 33 - pushable blocks (MZ, LZ)
; ---------------------------------------------------------------------------

Obj33:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj33_Index(pc,d0.w),d1
		jmp	Obj33_Index(pc,d1.w)
; ===========================================================================
Obj33_Index:	dc.w Obj33_Main-Obj33_Index
		dc.w loc_BF6E-Obj33_Index
		dc.w loc_C02C-Obj33_Index

Obj33_Var:	dc.b $10, 0	; object width,	frame number
		dc.b $40, 1
; ===========================================================================

Obj33_Main:				; XREF: Obj33_Index
		addq.b	#2,Routine(a0)
		move.b	#$F,Y_Radius(a0)
		move.b	#$F,X_Radius(a0)
		move.l	#Map_obj33,Mappings_Offset(a0)
		move.w	#$42B8,Art_Tile(a0)	; MZ specific code
		cmpi.b	#1,($FFFFFE10).w
		bne.s	loc_BF16
		move.w	#$43DE,Art_Tile(a0)	; LZ specific code

loc_BF16:
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.w	X_pos(a0),Off34(a0)
		move.w	Y_Pos(a0),Off36(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		andi.w	#$E,d0
		lea	Obj33_Var(pc,d0.w),a2
		move.b	(a2)+,X_Visible(a0)
		move.b	(a2)+,Anim_Frame(a0)
		tst.b	Subtype(a0)
		beq.s	Obj33_ChkGone
		move.w	#$C2B8,Art_Tile(a0)

Obj33_ChkGone:
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_BF6E
		bclr	#7,2(a2,d0.w)
		bset	#0,2(a2,d0.w)
		bne.w	DeleteObject

loc_BF6E:				; XREF: Obj33_Index
		tst.b	Off32(a0)
		bne.w	loc_C046
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	X_pos(a0),d4
		bsr.w	loc_C186
		cmpi.w	#$200,($FFFFFE10).w ; is the level MZ act 1?
		bne.s	loc_BFC6	; if not, branch
		bclr	#7,Subtype(a0)
		move.w	X_pos(a0),d0
		cmpi.w	#$A20,d0
		blo.s	loc_BFC6
		cmpi.w	#$AA1,d0
		bhs.s	loc_BFC6
		move.w	($FFFFF7A4).w,d0
		subi.w	#$1C,d0
		move.w	d0,Y_Pos(a0)
		bset	#7,($FFFFF7A4).w
		bset	#7,Subtype(a0)

loc_BFC6:
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_BFE6
		bra.w	DisplaySprite
; ===========================================================================

loc_BFE6:
		move.w	Off34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_C016
		move.w	Off34(a0),X_pos(a0)
		move.w	Off36(a0),Y_Pos(a0)
		move.b	#4,Routine(a0)
		bra.s	loc_C02C
; ===========================================================================

loc_C016:
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_C028
		bclr	#0,2(a2,d0.w)

loc_C028:
		bra.w	DeleteObject
; ===========================================================================

loc_C02C:				; XREF: Obj33_Index
		bsr.w	ChkObjOnScreen2
		beq.s	locret_C044
		move.b	#2,Routine(a0)
		sf	Off32(a0)
		clr.w	X_Vel(a0)
		clr.w	Y_Vel(a0)

locret_C044:
		rts
; ===========================================================================

loc_C046:				; XREF: loc_BF6E
		move.w	X_pos(a0),-(sp)
		cmpi.b	#4,Routine2(a0)
		bhs.s	loc_C056
		bsr.w	ObjectMove

loc_C056:
		btst	#1,Status(a0)
		beq.s	loc_C0A0
		addi.w	#$18,Y_Vel(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	loc_C09E
		add.w	d1,Y_Pos(a0)
		clr.w	Y_Vel(a0)
		bclr	#1,Status(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$16A,d0
		blo.s	loc_C09E
		move.w	Off30(a0),d0
		asr.w	#3,d0
		move.w	d0,X_Vel(a0)
		move.b	#1,Off32(a0)
		clr.w	Y_Pos2(a0)

loc_C09E:
		bra.s	loc_C0E6
; ===========================================================================

loc_C0A0:
		tst.w	X_Vel(a0)
		beq.w	loc_C0D6
		bmi.s	loc_C0BC
		moveq	#0,d3
		move.b	X_Visible(a0),d3
		jsr	ObjHitWallRight
		tst.w	d1		; has block touched a wall?
		bmi.s	Obj33_StopPush	; if yes, branch
		bra.s	loc_C0E6
; ===========================================================================

loc_C0BC:
		moveq	#0,d3
		move.b	X_Visible(a0),d3
		not.w	d3
		jsr	ObjHitWallLeft
		tst.w	d1		; has block touched a wall?
		bmi.s	Obj33_StopPush	; if yes, branch
		bra.s	loc_C0E6
; ===========================================================================

Obj33_StopPush:
		clr.w	X_Vel(a0)		; stop block moving
		bra.s	loc_C0E6
; ===========================================================================

loc_C0D6:
		addi.l	#$2001,Y_Pos(a0)
		cmpi.b	#-$60,$F(a0)
		bhs.s	loc_C104

loc_C0E6:
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	(sp)+,d4
		bsr.w	loc_C186
		bsr.s	Obj33_ChkLava
		bra.w	loc_BFC6
; ===========================================================================

loc_C104:
		move.w	(sp)+,d4
		lea	Object_RAM,a1
		bclr	#3,Status(a1)
		bclr	#3,Status(a0)
		bra.w	loc_BFE6
; ===========================================================================

Obj33_ChkLava:
		cmpi.w	#$201,($FFFFFE10).w ; is the level MZ act 2?
		bne.s	Obj33_ChkLava2	; if not, branch
		move.w	#-$20,d2
		cmpi.w	#$DD0,X_pos(a0)
		beq.s	Obj33_LoadLava
		cmpi.w	#$CC0,X_pos(a0)
		beq.s	Obj33_LoadLava
		cmpi.w	#$BA0,X_pos(a0)
		beq.s	Obj33_LoadLava
		rts
; ===========================================================================

Obj33_ChkLava2:
		cmpi.w	#$202,($FFFFFE10).w ; is the level MZ act 3?
		bne.s	Obj33_NoLava	; if not, branch
		move.w	#$20,d2
		cmpi.w	#$560,X_pos(a0)
		beq.s	Obj33_LoadLava
		cmpi.w	#$5C0,X_pos(a0)
		beq.s	Obj33_LoadLava

Obj33_NoLava:
		rts
; ===========================================================================

Obj33_LoadLava:
		bsr.w	SingleObjLoad
		bne.s	locret_C184
		move.b	#$4C,0(a1)	; load lava geyser object
		move.w	X_pos(a0),X_pos(a1)
		add.w	d2,X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		addi.w	#$10,Y_Pos(a1)
		move.l	a0,Off3C(a1)

locret_C184:
		rts
; ===========================================================================

loc_C186:				; XREF: loc_BF6E
		move.b	Routine2(a0),d0
		beq.w	loc_C218
		subq.b	#2,d0
		bne.s	loc_C1AA
		bsr.w	ExitPlatform
		btst	#3,Status(a1)
		bne.s	loc_C1A4
		sf	Routine2(a0)
		rts
; ===========================================================================

loc_C1A4:
		move.w	d4,d2
		bra.w	MvSonicOnPtfm
; ===========================================================================

loc_C1AA:
		subq.b	#2,d0
		bne.s	loc_C1F2
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	locret_C1F0
		add.w	d1,Y_Pos(a0)
		clr.w	Y_Vel(a0)
		sf	Routine2(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$16A,d0
		blo.s	locret_C1F0
		move.w	Off30(a0),d0
		asr.w	#3,d0
		move.w	d0,X_Vel(a0)
		move.b	#1,Off32(a0)
		clr.w	Y_Pos2(a0)

locret_C1F0:
		rts
; ===========================================================================

loc_C1F2:
		bsr.w	ObjectMove
		move.w	X_pos(a0),d0
		andi.w	#$C,d0
		bne.w	locret_C2E4
		andi.w	#-$10,X_pos(a0)
		move.w	X_Vel(a0),Off30(a0)
		clr.w	X_Vel(a0)
		subq.b	#2,Routine2(a0)
		rts
; ===========================================================================

loc_C218:
		bsr.w	loc_FAC8
		tst.w	d4
		beq.w	locret_C2E4
		bmi.w	locret_C2E4
		tst.b	Off32(a0)
		beq.s	loc_C230
		bra.w	locret_C2E4
; ===========================================================================

loc_C230:
		tst.w	d0
		beq.w	locret_C2E4
		bmi.s	loc_C268
		btst	#0,Status(a1)
		bne.w	locret_C2E4
		move.w	d0,-(sp)
		moveq	#0,d3
		move.b	X_Visible(a0),d3
		jsr	ObjHitWallRight
		move.w	(sp)+,d0
		tst.w	d1
		bmi.w	locret_C2E4
		addi.l	#$10000,X_pos(a0)
		moveq	#1,d0
		move.w	#$40,d1
		bra.s	loc_C294
; ===========================================================================

loc_C268:
		btst	#0,Status(a1)
		beq.s	locret_C2E4
		move.w	d0,-(sp)
		moveq	#0,d3
		move.b	X_Visible(a0),d3
		not.w	d3
		jsr	ObjHitWallLeft
		move.w	(sp)+,d0
		tst.w	d1
		bmi.s	locret_C2E4
		subi.l	#$10000,X_pos(a0)
		moveq	#-1,d0
		move.w	#-$40,d1

loc_C294:
		lea	Object_RAM,a1
		add.w	d0,X_pos(a1)
		move.w	d1,Inertia(a1)
		move.w	#0,X_Vel(a1)
		move.w	d0,-(sp)
		move.w	#$A7,d0
		jsr	(PlaySound).l ;	play pushing sound
		move.w	(sp)+,d0
		tst.b	Subtype(a0)
		bmi.s	locret_C2E4
		move.w	d0,-(sp)
		jsr	ObjHitFloor
		move.w	(sp)+,d0
		cmpi.w	#4,d1
		ble.s	loc_C2E0
		move.w	#$400,X_Vel(a0)
		tst.w	d0
		bpl.s	loc_C2D8
		neg.w	X_Vel(a0)

loc_C2D8:
		move.b	#6,Routine2(a0)
		bra.s	locret_C2E4
; ===========================================================================

loc_C2E0:
		add.w	d1,Y_Pos(a0)

locret_C2E4:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - pushable blocks (MZ, LZ)
; ---------------------------------------------------------------------------
Map_obj33:
	include "_maps\obj33.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 34 - zone title cards
; ---------------------------------------------------------------------------

Obj34:                                  ; XREF: Obj_Index
                moveq   #0,d0
                move.b  Routine(a0),d0
                move.w  Obj34_Index(pc,d0.w),d1
                jmp     Obj34_Index(pc,d1.w)
; ===========================================================================
Obj34_Index:    dc.w .0-Obj34_Index
                dc.w Obj34_ChkPos-Obj34_Index
                dc.w Obj34_Wait-Obj34_Index
                dc.w Obj34_Wait-Obj34_Index
; ===========================================================================
.0              bsr     Obj34_LoadDPLC  ; load first set of DPLC
                movea.l a0,a1           ; move a0 to a1
                moveq   #0,d0
Obj34_LoadConfig:
                lea     Obj34_ConData,a3; configuration for object positions
                lea     Obj34_ItemData,a2; configuration for item data
                moveq   #3,d1

Obj34_Loop:
                lea	Obj34_Xpos,a4
                move.b  #$34,(a1)       ; obj34
                move.w  (a3),X_pos(a1)      ; load start x-position
                move.w  (a3)+,Off32(a1)   ; load finish x-position (same as start)
                move.w  (a3)+,Off30(a1)   ; load main x-position
                bpl.s	.cont

		moveq	#0,d0
                move.b	$FFFFFE10.w,d0
                lsl.w	#2,d0
                add.w	d0,a4

                cmpi.w	#$700,$FFFFFE10.w
		bne.s	.notFinalZ
		lea	Obj34_XposFin,a4

.notFinalZ	move.w	(a4)+,Off30(a1)
                move.w	(a4),Off32(a1)
                move.w	(a4),X_pos(a1)

.cont		move.w  (a3)+,Off34(a1)   ; load main x-position
		move.w  (a2)+,X_Pos2(a1)    ; Y-pos
                move.w  (a2)+,Art_Tile(a1)     ; art tile value
                move.w  (a2)+,Anim_Frame(a1)   ; mappings frame
                bpl.s	Obj34_MakeSprite	; not zone cards

                move.b	#0,Anim_Frame(a1)	; set anim according to zone id
		cmpi.w	#$700,$FFFFFE10.w
		beq.s	Obj34_MakeSprite

		moveq	#0,d0
                move.b	$FFFFFE10.w,d0
                add.b	#9,d0
                move.b	d0,Anim_Frame(a1)	; set anim according to zone id

Obj34_MakeSprite:
                move.l  #Map_obj34,4(a1)
                move.b  #$78,X_Visible(a1)
                move.b  #0,Render_Flags(a1)
                move.b  #0,Priority(a1)
                move.b  #2,Routine(a1)      ; routine 4
                move.w  #60,Anim_Dur(a1)     ; set time delay to 1 second
                lea     $40(a1),a1      ; next object
                dbf     d1,Obj34_Loop   ; repeat sequence another 3 times

Obj34_ChkPos:				; XREF: Obj34_Index
		addq.w	#8,X_pos(a0)	; change item's position

		move.w	Off30(a0),d0
		cmp.w	X_pos(a0),d0	; has item reached the target position?
		bge.s	loc_C3C8	; if yes, branch
	;	ble.s	Obj34_Move
	;	moveq	#0,d1
		move.w	Off30(a0),X_pos(a0)

Obj34_Move:

loc_C3C8:
		move.w	X_pos(a0),d0
		bmi.s	locret_C3D8
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bhs.s	locret_C3D8	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

locret_C3D8:
		rts
; ===========================================================================

Obj34_Wait:				; XREF: Obj34_Index
		tst.w	Anim_Dur(a0)		; is time remaining zero?
		beq.s	Obj34_ChkPos2	; if yes, branch
		subq.w	#1,Anim_Dur(a0)	; subtract 1 from time
		bra.w	DisplaySprite
; ===========================================================================

Obj34_ChkPos2:				; XREF: Obj34_Wait
		subq.w	#1,Off34(a0)	; delay
		bpl.s	Obj34_Move2
		subq.w	#8,X_pos(a0)	; change item's position

		move.w	Off32(a0),d0
		cmp.w	X_pos(a0),d0	; has item reached the target position?
		ble.s	Obj34_Move2	; if yes, branch
	;	ble.s	Obj34_Move
	;	moveq	#0,d1
		move.w	Off32(a0),X_pos(a0)
		bra	Obj34_ChangeArt

Obj34_Move2:
		move.w	X_pos(a0),d0
		bmi.s	locret_C412
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bhs.s	locret_C412	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

locret_C412:
		rts
; ===========================================================================

Obj34_ChangeArt:			; XREF: Obj34_ChkPos2
		cmpi.b	#4,Routine(a0)
		bne.s	Obj34_Delete

		moveq	#2,d0
		jsr	LoadPLC	; load explosion patterns
		moveq	#0,d0
		move.b	$FFFFFE10,d0
		lsl.w	#2,d0
		addi.w	#Misc_PLC+2,d0
		jsr	LoadPLC	; load animal patterns (level no.*3 + 23)

Obj34_Delete:
		bra.w	DeleteObject

; ===========================================================================
; ---------------------------------------------------------------------------
; Title card configuration data
;
; Only first row is used now due to the tutorial, rest can be deleted
;
;
; Format:
; 6 bytes per item (YYYY XXXX ZZZZ)
; 4 items per level (GREEN HILL, ZONE, ACT X, oval)
; ---------------------------------------------------------------------------
Obj34_ConData:  dc.w -$F0, $D0, 0
		dc.w -$100, $13C, 0
		dc.w 0, -1, 0
		dc.w -$10, $88, 40

Obj34_ItemData:	; y-axis position, VRAM setting, frame number, 0
                dc.w $D0,$8560,$FF00
                dc.w $E4,$85DF+24,$200
                dc.w $10A,$85CF,$100
                dc.w $E4,$85E9-$0070,$300

Obj34_Xpos:	dc.w $EC+$2C, -$A8
		dc.w $EC+$2C, -$A8
		dc.w $10C+$2C,-$84
		dc.w $E4+$2C, -$A8
		dc.w $10C+$2C,-$84
		dc.w $10C+$2C,-$84
Obj34_XposFin:	dc.w -$20, -$80
; ===========================================================================
; Mappings
Map_obj34:
                dc.w Obj34_Final-Map_obj34, Map_obj34_ActId-Map_obj34
                dc.w Map_obj34_ZACT-Map_obj34, Map_obj34_Ov-Map_obj34
                dc.w Map_obj34_SGT-Map_obj34, Map_obj34_OACT-Map_obj34
                dc.w byte34_CC32-Map_obj34, byte34_CC51-Map_obj34, byte34_CC75-Map_obj34
                dc.w obj34_GHZ-Map_obj34, obj34_LZ-Map_obj34, obj34_MZ-Map_obj34, obj34_SLZ-Map_obj34, obj34_SYZ-Map_obj34, obj34_SBZ-Map_obj34, obj34_GHZ-Map_obj34, obj34_GHZ-Map_obj34

Obj34_Final:	dc.b 2+3
		dc.b 0, $E, 0, (12*0)+27, 0-$20
                dc.b 0, $E, 0, (12*1)+27, $20-$20
		ttlzone	-32

obj34_SLZ:
obj34_LZ:
obj34_GHZ:	dc.b 4+3
		dc.b 0, $E, 0, (12*0)+27, 0-$20
                dc.b 0, $E, 0, (12*1)+27, $20-$20
		dc.b 0, $E, 0, (12*2)+27, $40-$20
		dc.b 0, $E, 0, (12*3)+27, $60-$20
		ttlzone	24

obj34_MZ:
obj34_SBZ:
obj34_SYZ:	dc.b 5+3
		dc.b 0, $E, 0, (12*0)+27, 0-$20
                dc.b 0, $E, 0, (12*1)+27, $20-$20
		dc.b 0, $E, 0, (12*2)+27, $40-$20
		dc.b 0, $E, 0, (12*3)+27, $60-$20
		dc.b 0, $E, 0, (12*4)+27, $80-$20
		ttlzone	56

Map_obj34_ActId:dc.b 2                  ; act id
                dc.b $F4, $F, 0, 0,   $D
                dc.b $F4,  7, 0, $10, $D+$20
Map_obj34_ZACT: dc.b 0
                dc.b $F4, $D, 0, 0, $E2 ; ZO
                dc.b $F4, $D, 0, 8, 2   ; NE
                dc.b 8, 8, 0, $10, $A   ; ACT
Map_obj34_Ov:   dc.b 14                  ; oval
                dc.b $A0-4, $F, 0, $6F, $F8
		dc.b $A0-4, 7,  0, $7F, $18
		dc.b $C0-4, $F, 0, $6F, $F8
		dc.b $C0-4, 7,  0, $7F, $18
		dc.b $E0-4, $F, 0, $6F, $F8
		dc.b $E0-4, 7,  0, $7F, $18
		dc.b -4,    $F, 0, $6F, $F8
		dc.b -4,    7,  0, $7F, $18
		dc.b $20-4, $F, 0, $6F, $F8
		dc.b $20-4, 7,  0, $7F, $18
		dc.b $40-4, $F, 0, $6F, $F8
		dc.b $40-4, 7,  0, $7F, $18
		dc.b $60-4, $F, 0, $6F, $F8
		dc.b $60-4, 7,  0, $7F, $18
Map_obj34_SGT:  dc.b 8
		dc.b 0, $E, 0, (12*0)+8, 0-$60
                dc.b 0, $E, 0, (12*1)+8, $20-$60
		dc.b 0, $E, 0, (12*2)+8, $40-$60
		dc.b 0,  6, 0, (12*3)+8, $60-$60
		dc.b 32,$E, 0, (12*4)-4, 0-$60
		dc.b 32,$E, 0, (12*5)-4, $20-$60
		dc.b 32,$E, 0, (12*6)-4, $40-$60
		dc.b 32,6, 0, (12*7)-4, $60-$60
Map_obj34_OACT: dc.b 0                  ; only act
                dc.b 5, 8, 0, $10, $1A
byte34_CC32:    dc.b 4                  ; SCORE
                dc.b $F8, $D, 1, $4A, $B0
                dc.b $F8, 1, 1, $62, $D0
                dc.b $F8, 9, 1, $64, $18
                dc.b $F8, $D, 1, $6A, $30
byte34_CC51:    dc.b 5                  ; TIME BONUS
                dc.b $F8, $D, 1, $5A, $B0
                dc.b $F8, $D, 0, $70, $D9
                dc.b $F8, 1, 1, $4A, $F9
                dc.b $F8, $D, $FF, $F0, $28
                dc.b $F8, 1, 1, $70, $48
byte34_CC75:    dc.b 5                  ; RING BONUS
                dc.b $F8, $D, 1, $52, $B0
                dc.b $F8, $D, 0, $70, $D9
                dc.b $F8, 1, 1, $4A, $F9
                dc.b $F8, $D, $FF, $F8, $28
                dc.b $F8, 1, 1, $70, $48
                even
; ===========================================================================
; Dynamic pattern load cues
;
; How it works: First byte is how many requests to give for the DPLC, or how many words it has
; then each words give the art info. In this format: YXXX. Y = How many tiles-1. X = the starting tile

DPLC_Obj34:
DPLC_Obj34_2:   dc.w ACT1-DPLC_Obj34_2    ; ACT x
                dc.w ACT2-DPLC_Obj34_2    ;
                dc.w ACT3-DPLC_Obj34_2    ;
                dc.w ACTNO-DPLC_Obj34_2   ;
                dc.w ACT1-DPLC_Obj34_2    ;
                dc.w ACT2-DPLC_Obj34_2    ;
                dc.w ACT3-DPLC_Obj34_2    ;
                dc.w ACTNO-DPLC_Obj34_2   ;
                dc.w ZONE34-DPLC_Obj34_2  ; empty
                dc.w ACTOval-DPLC_Obj34_2 ; ACT, ZONE and oval
                dc.w Oval-DPLC_Obj34_2    ; ZONE and oval
                dc.w BONU-DPLC_Obj34_2    ; BONU, ACT and oval
                dc.w SGT-DPLC_Obj34_2     ; SONIC GOT THROUH text
                dc.w FZ-DPLC_Obj34_2      ; FINAL text
                dc.w GHZ-DPLC_Obj34_2     ; Zone texts
                dc.w LZ-DPLC_Obj34_2      ;
                dc.w MZ-DPLC_Obj34_2      ;
                dc.w SLZ-DPLC_Obj34_2     ;
                dc.w SYZ-DPLC_Obj34_2     ;
                dc.w SBZ-DPLC_Obj34_2     ;
                dc.w FZ-DPLC_Obj34_2	;
                dc.w FZ-DPLC_Obj34_2	;
                dc.b 0  ; pad to next odd address (next line we will get an even address)
; ------------------------------------------------------------------------------------------------------------
; Act number DPLC's. 6 tiles, from $40 to $46 from the objects normal VRAM space
; ------------------------------------------------------------------------------------------------------------
ACTNO:          dc.b 1; (space)
                dc.w $50FC
                dc.b 0  ; pad to next odd address
ACT1:           dc.b 2; 1  (space)
                dc.w $F0B4, $70C4
                dc.b 0  ; pad to next odd address
ACT2:           dc.b 2; 2
                dc.w $F0CC, $70DC
                dc.b 0  ; pad to next odd address
ACT3:           dc.b 2; 3
                dc.w $F0E4, $70F4
                dc.b 0  ; pad to next odd address
; ------------------------------------------------------------------------------------------------------------
; Misc DPLC's. $2E tiles, from $47 to $75 from the objects normal VRAM space
; ------------------------------------------------------------------------------------------------------------
ACTOval:
Oval:           dc.b 2;   oval
                dc.w $F09B, $80AB
                dc.b 0  ; pad to next odd address
BONU:           dc.b 1; -   BONU      oval
                dc.w $70FF
                dc.b 0  ; pad to next odd address
; ------------------------------------------------------------------------------------------------------------
; Zone texts:   Max of 32 "half" characters (You could fit 32 I's or 16 normal letters),
;               and must always be 64 tiles ($3F tiles) used to be in correct VRAM position for next transfers
;               Always give 1 more request for unknown reason
;               from 0 to $3F from the objects normal VRAM space
; ------------------------------------------------------------------------------------------------------------
GHZ:            ttlcard 'G','R','E','E','N',' ','H','I','L','L'
LZ:             ttlcard	'L','A','B','Y','R','I','N','T','H'
MZ:             ttlcard	' ',' ','M','A','R','B','L','E',' ','H','I','L','L'
SLZ:            ttlcard	'S','T','A','R',' ','L','I','G','H','T'
SYZ:            ttlcard 'S','P','R','I','N','G',' ','Y','A','R','D'
SBZ:            ttlcard	'S','C','R','A','P',' ','B','R','A','I','N'
OW:		ttlcard	'E','M','E','R','A','L','D',' ',' '
FZ:             ttlcard	'F','I','N','A','L'
SGT:            ttlcard	'Y','O','U',' ','G','O','T','H','R','O','U','G','H'
ZONE34:		ttlcard	'Z','O','N','E'
	even
; ===========================================================================
; load DPLC's
; ---------------------------------------------------------------------------
; Obj34 - Zone name, act id
; ---------------------------------------------------------------------------
Obj34_LoadDPLC:
		lea	DPLC_Obj34_2,a3

.next		move.l	a3,a2			; get the DPLC
                move.l  #Nem_Titlecard,d6       ; art
                move.w  #$AC00,d4               ; VRAM address
                move.w  #Act_Count,d0          ; DPLC: FZ
                jsr     Load_DPLC2              ; load the DPLC

		move.l	a3,a2			; get the DPLC
                move.l  #Nem_Titlecard,d6       ; art
                moveq   #0,d0
                move.b  ($FFFFFE10).w,d0        ; DPLC: ZONE x
                addi.b  #GHZ_DPLC,d0            ; DPLC: Get proper zone id
.notFZ		jsr     Load_DPLC2              ; load the DPLC

		move.l	a3,a2			; get the DPLC
                move.l  #Nem_Titlecard,d6       ; art
                move.w  #$B9E0,d4               ; VRAM address
                move.b  ($FFFFFE11).w,d0        ; DPLC: ACT x
                andi.w	#3,d0
.notFZ_2        jsr     Load_DPLC2               ; load the DPLC

		move.l	a3,a2			; get the DPLC
                move.l  #Nem_Titlecard,d6       ; art
                moveq   #Act_Count+1,d0         ; DPLC: ACTOVAL
.Dplc		jmp     Load_DPLC2               ; load the DPLC
; ---------------------------------------------------------------------------
; Obj3A - SONIC GOT THROUGH
; ---------------------------------------------------------------------------
Obj3A_LoadDPLC2:
		lea	DPLC_Obj34_2,a3

.next		move.l	a3,a2			; get the DPLC
                move.l  #Nem_Titlecard,d6       ; art
                move.w  #$B100,d4               ; the VRAM address
                moveq   #GHZ_DPLC-2,d0          ; DPLC: SGT
                jsr     Load_DPLC2               ; load the DPLC

		move.l	a3,a2			; get the DPLC
                move.l  #Nem_Titlecard,d6       ; art
                move.w  #$BB00,d4
                move.b  ($FFFFFE11).w,d0        ; load frame number
                andi.w	#3,d0
		jsr     Load_DPLC2               ; load the DPLC

		move.l	a3,a2			; get the DPLC
                move.l  #Nem_Titlecard,d6       ; art
                moveq   #GHZ_DPLC-3,d0          ; DPLC: BONU
		jmp	Load_DPLC2
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 39 - "GAME OVER" and "TIME OVER"
; ---------------------------------------------------------------------------

Obj39:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj39_Index(pc,d0.w),d1
		jmp	Obj39_Index(pc,d1.w)
; ===========================================================================
Obj39_Index:	dc.w Obj39_ChkPLC-Obj39_Index
		dc.w loc_C50C-Obj39_Index
		dc.w Obj39_Wait-Obj39_Index
; ===========================================================================

Obj39_ChkPLC:		; XREF: Obj39_Index
		tst.l   ($FFFFF680).w   ; are the pattern load cues empty?
		beq.s   Obj39_Main      ; if yes, branch
		rts
; ===========================================================================
Obj39_Main:

		lea 	Ttlcard_RAM+$40,a1
		move.b  #$39,(a1) ; load OVER object
		move.w  #$855E,Art_Tile(a1)
		move.l  #Map_obj39,Mappings_Offset(a1)
		move.b  #1,Anim_Frame(a1) ; set OVER object to correct frame
		move.b	#2,Routine(a1)
		move.w  #$F0,X_Pos2(a1)
		move.w  #$1F0,X_Pos(a1)
		move.b  #0,Render_Flags(a1)
		move.b  #0,Priority(a1)
		addq.b  #2,Routine(a0)
		move.l  #Map_obj39,Mappings_Offset(a0)
		move.w  #$855E,Art_Tile(a0)
		move.b  #0,Render_Flags(a0)
		move.b  #0,Priority(a0)
		move.w  #$F0,X_Pos2(a0)
		move.w  #$50,X_Pos(a0)      ; set x-position

loc_C50C:				; XREF: Obj39_Index
		moveq	#$10,d1		; set horizontal speed
		cmpi.w	#$120,X_pos(a0)	; has item reached its target position?
		beq.s	Obj39_SetWait	; if yes, branch
		blo.s	Obj39_Move
		neg.w	d1

Obj39_Move:
		add.w	d1,X_pos(a0)	; change item's position
		bra.w	DisplaySprite
; ===========================================================================

Obj39_SetWait:				; XREF: Obj39_Main
		move.w	#720,Anim_Dur(a0)	; set time delay to 12 seconds
		addq.b	#2,Routine(a0)
		rts
; ===========================================================================

Obj39_Wait:				; XREF: Obj39_Index
		move.b	($FFFFF605).w,d0
		andi.b	#$70,d0		; is button A, B or C pressed?
		bne.s	Obj39_ChgMode	; if yes, branch
		btst	#0,Anim_Frame(a0)
		bne.s	Obj39_Display
		tst.w	Anim_Dur(a0)		; has time delay reached zero?
		beq.s	Obj39_ChgMode	; if yes, branch
		subq.w	#1,Anim_Dur(a0)	; subtract 1 from time delay
		bra.w	DisplaySprite
; ===========================================================================

Obj39_ChgMode:				; XREF: Obj39_Wait
		tst.b	($FFFFFE1A).w	; is time over flag set?
		bne.s	Obj39_ResetLvl	; if yes, branch
		move.b	#4,$FFFFF600.w
		move.b	#0,$FFFFFE30	; clear lamppost count
		rts

Obj39_ResetLvl:				; XREF: Obj39_ChgMode
		move.w	#1,($FFFFFE02).w ; restart level
		move.l	#0,($FFFFFE38).w ; clear time

		cmp.b	#7,$FFFFFE10.w
		bne.s	Obj39_Display
		move.l	#$12D00,($FFFFFE38).w ; clear time

Obj39_Display:				; XREF: Obj39_ChgMode
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3A - "SONIC GOT THROUGH" title	card
; ---------------------------------------------------------------------------

Obj3A:                                  ; XREF: Obj_Index
                moveq   #0,d0
                move.b  $24(a0),d0
                move.w  Obj3A_Index(pc,d0.w),d1
                jmp     Obj3A_Index(pc,d1.w)
; ===========================================================================
Obj3A_Index:    dc.w .hyp-Obj3A_Index
                dc.w Obj3A_ChkPLC-Obj3A_Index
                dc.w Obj3A_ChkPos-Obj3A_Index
                dc.w Obj3A_Wait-Obj3A_Index
                dc.w Obj3A_TimeBonus-Obj3A_Index
                dc.w Obj3A_Wait-Obj3A_Index
                dc.w Obj3A_NextLevel-Obj3A_Index
                dc.w Obj3A_Wait-Obj3A_Index
                dc.w Obj3A_ChkPos2-Obj3A_Index
                dc.w loc_C766-Obj3A_Index
; ===========================================================================.
.hyp
                addq.b  #2,Routine(a0)
                bra     Obj3A_LoadDPLC2 ; load first set of DPLC
Obj3A_ChkPLC:                           ; XREF: Obj3A_Index
                tst.l   ($FFFFF680).w   ; are the pattern load cues empty?
                beq.s   Obj3A_Main      ; if yes, branch
                rts
; ===========================================================================

Obj3A_Main:
                movea.l a0,a1
                lea     (Obj3A_Config).l,a2
                moveq   #4,d1

Obj3A_Loop:
                move.b  #$3A,(a1)
                move.w  (a2),X_Pos(a1)      ; load start x-position
                move.w  (a2)+,Off32(a1)   ; load finish x-position (same as start)
                move.w  (a2)+,Off30(a1)   ; load main x-position
                move.w  (a2)+,X_Pos2(a1)    ; load y-position
                move.w  (a2)+,Art_Tile(a1)     ; VRAM settings
                move.w  (a2)+,Anim_Frame(a1)   ; mappings frame
                move.b  #4,Routine(a1)      ; routine 4
                move.l  #Map_obj34,4(a1)
                move.b  #0,Render_Flags(a1)
                lea     Next_Obj(a1),a1      ; next obj
                dbf     d1,Obj3A_Loop   ; repeat 6 times

Obj3A_ChkPos:				; XREF: Obj3A_Index
                move.b	#$13,Object_RAM+Anim
                move.b	#1,$FFFFF7C8.w
		addq.w	#8,X_pos(a0)	; change item's position

		move.w	Off30(a0),d0
		cmp.w	X_pos(a0),d0	; has item reached the target position?
		bge.s	loc_C5FE	; if yes, branch
	;	ble.s	Obj34_Move
	;	moveq	#0,d1
		move.w	Off30(a0),X_pos(a0)
		bra	loc_C61A

loc_C5FE:				; XREF: loc_C61A
		move.w	X_pos(a0),d0
		bmi.s	locret_C60E
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bhs.s	locret_C60E	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

locret_C60E:
		rts
; ===========================================================================

loc_C610:				; XREF: loc_C61A
		move.b	#$10,Routine(a0)
		bra.w	Obj3A_ChkPos2
; ===========================================================================

loc_C61A:				; XREF: Obj3A_ChkPos
		cmpi.b	#$10,($FFFFD5C0+Routine).w
		beq.s	loc_C610
		cmpi.b	#4,Anim_Frame(a0)
		bne.s	loc_C5FE
		addq.b	#2,Routine(a0)
		move.w	#180,Anim_Dur(a0)	; set time delay to 3 seconds

Obj3A_Wait:				; XREF: Obj3A_Index
		subq.w	#1,Anim_Dur(a0)	; subtract 1 from time delay
		bne.s	Obj3A_Display
		addq.b	#2,Routine(a0)

Obj3A_Display:
		bra.w	DisplaySprite
; ===========================================================================

Obj3A_TimeBonus:			; XREF: Obj3A_Index
		bsr.w	DisplaySprite
		move.b	#1,($FFFFF7D6).w ; set time/ring bonus update flag
		moveq	#0,d0
		tst.w	($FFFFF7D2).w	; is time bonus	= zero?
		beq.s	Obj3A_RingBonus	; if yes, branch
		addi.w	#10,d0		; add 10 to score
		subi.w	#10,($FFFFF7D2).w ; subtract 10	from time bonus

Obj3A_RingBonus:
		tst.w	($FFFFF7D4).w	; is ring bonus	= zero?
		beq.s	Obj3A_ChkBonus	; if yes, branch
		addi.w	#10,d0		; add 10 to score
		subi.w	#10,($FFFFF7D4).w ; subtract 10	from ring bonus

Obj3A_ChkBonus:
		tst.w	d0		; is there any bonus?
		bne.s	Obj3A_AddBonus	; if yes, branch
		move.w	#$C5,d0
		jsr	(PlaySound).l ;	play "ker-ching" sound
		addq.b	#2,Routine(a0)
		cmpi.w	#$501,($FFFFFE10).w
		bne.s	Obj3A_SetDelay
		addq.b	#4,Routine(a0)

Obj3A_SetDelay:
		move.w	#180,Anim_Dur(a0)	; set time delay to 3 seconds

locret_C692:
		rts
; ===========================================================================

Obj3A_AddBonus:				; XREF: Obj3A_ChkBonus
		jsr	AddPoints
		move.b	($FFFFFE0F).w,d0
		andi.b	#3,d0
		bne.s	locret_C692
		move.w	#$CD,d0
		jmp	(PlaySound).l ;	play "blip" sound
; ===========================================================================

Obj3A_NextLevel:			; XREF: Obj3A_Index
		tst.b	v_snddriver_ram+v_fm1_track.w
		bmi.s	Obj3A_Display2		; wait until music stopped

		move.b	($FFFFFE10).w,d0
		andi.w	#7,d0
		lsl.w	#3,d0
		move.b	($FFFFFE11).w,d1
		andi.w	#3,d1
		add.w	d1,d1
		add.w	d1,d0
		move.w	LevelOrder(pc,d0.w),d0 ; load level from level order array
		move.w	d0,($FFFFFE10).w ; set level number

Obj3A_ChkSS:	sf	($FFFFFE30).w	; clear	lamppost counter
loc_C6EA:	move.w	#1,($FFFFFE02).w ; restart level
Obj3A_Display2:	bra.w	DisplaySprite

; ===========================================================================
LevelOrder:	dc.w $0001, $0002, $0200, $0000
		dc.w $0101, $0102, $0300, $0502
		dc.w $0201, $0202, $0400, $0000
		dc.w $0301, $0302, $0500, $0000
		dc.w $0401, $0402, $0100, $0000
		dc.w $0501, $0103, $0000, $0000
; ===========================================================================

Obj3A_ChkPos2:				; XREF: Obj3A_Index
		subi.w	#$10,X_pos(a0)	; change item's position

		move.w	Off32(a0),d0
		cmp.w	X_pos(a0),d0	; has item reached the target position?
		ble.s	Obj3A_Move2	; if yes, branch
	;	ble.s	Obj34_Move
	;	moveq	#0,d1
		move.w	Off32(a0),X_pos(a0)
		bra.s	Obj3A_SBZ2

Obj3A_Move2:
		move.w	X_pos(a0),d0
		bmi.s	locret_C748
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bhs.s	locret_C748	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

locret_C748:
		rts
; ===========================================================================

Obj3A_SBZ2:				; XREF: Obj3A_ChkPos2
		cmpi.b	#4,Anim_Frame(a0)
		bne.w	DeleteObject
		addq.b	#2,Routine(a0)
		sf	$FFFFF7CC.w	; unlock controls
		sf	$FFFFF7C8.w	; lock controls
		rts
; ===========================================================================

loc_C766:				; XREF: Obj3A_Index
		addq.w	#2,($FFFFF72A).w
		cmpi.w	#$2100,($FFFFF72A).w
		beq.w	DeleteObject
		rts
; ===========================================================================
Obj3A_Config:   dc.w $10, $14C, $94, $8580, $400         ; SONIC GOT THROUGH
                dc.w $10, $144, $C8, $85D8, $100      ; ACT
                dc.w $520, $120, $EC, $8580, $600       ; SCORE
                dc.w $540, $120, $FC, $8580, $700       ; TIME BONUS
                dc.w $560, $120, $10C, $8580, $800      ; RING BONUS
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 36 - spikes
; ---------------------------------------------------------------------------

Obj36:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj36_Index(pc,d0.w),d1
		jmp	Obj36_Index(pc,d1.w)
; ===========================================================================
Obj36_Index:	dc.w Obj36_Main-Obj36_Index
		dc.w Obj36_Solid-Obj36_Index

Obj36_Var:	dc.b 0,	$14		; frame	number,	object width
		dc.b 1,	$10
		dc.b 2,	4
		dc.b 3,	$1C
		dc.b 4,	$40
		dc.b 5,	$10
; ===========================================================================

Obj36_Main:				; XREF: Obj36_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj36,Mappings_Offset(a0)
		move.w	#$51B,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	Subtype(a0),d0
		andi.b	#$F,Subtype(a0)
		andi.w	#$F0,d0
		lea	(Obj36_Var).l,a1
		lsr.w	#3,d0
		adda.w	d0,a1
		move.b	(a1)+,Anim_Frame(a0)
		move.b	(a1)+,X_Visible(a0)
		move.w	X_pos(a0),Off30(a0)
		move.w	Y_Pos(a0),Off32(a0)

Obj36_Solid:				; XREF: Obj36_Index
		bsr.w	Obj36_Type0x	; make the object move
		move.w	#4,d2
		cmpi.b	#5,Anim_Frame(a0)	; is object type $5x ?
		beq.s	Obj36_SideWays	; if yes, branch
		cmpi.b	#1,Anim_Frame(a0)	; is object type $1x ?
		bne.s	Obj36_Upright	; if not, branch
		move.w	#$14,d2

; Spikes types $1x and $5x face	sideways

Obj36_SideWays:				; XREF: Obj36_Solid
		move.w	#$1B,d1
		move.w	d2,d3
		addq.w	#1,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		btst	#3,Status(a0)
		bne.s	Obj36_Display
		cmpi.w	#1,d4
		beq.s	Obj36_Hurt
		bra.s	Obj36_Display
; ===========================================================================

; Spikes types $0x, $2x, $3x and $4x face up or	down

Obj36_Upright:				; XREF: Obj36_Solid
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		btst	#3,Status(a0)
		bne.s	Obj36_Hurt
		tst.w	d4
		bpl.s	Obj36_Display

Obj36_Hurt:				; XREF: Obj36_SideWays; Obj36_Upright
		tst.b	($FFFFFE2D).w	; is Sonic invincible?
		bne.s	Obj36_Display	; if yes, branch
		tst.w	Object_RAM+Off30	; +++ is Sonic invulnerable?
		bne.s	Obj36_Display	; +++ if yes, branch
		move.l	a0,-(sp)
		movea.l	a0,a2
		lea	Object_RAM,a0
		cmpi.b	#4,Routine(a0)
		bhs.s	loc_CF20
		move.l	Y_Pos(a0),d3
		move.w	Y_Vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,Y_Pos(a0)
		jsr	HurtSonic

loc_CF20:
		movea.l	(sp)+,a0

Obj36_Display:
		bsr.w	DisplaySprite
		move.w	Off30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================

Obj36_Type0x:				; XREF: Obj36_Solid
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		move.w	Obj36_TypeIndex(pc,d0.w),d1
		jmp	Obj36_TypeIndex(pc,d1.w)
; ===========================================================================
Obj36_TypeIndex:dc.w Obj36_Type00-Obj36_TypeIndex
		dc.w Obj36_Type01-Obj36_TypeIndex
		dc.w Obj36_Type02-Obj36_TypeIndex
; ===========================================================================

Obj36_Type00:				; XREF: Obj36_TypeIndex
		rts			; don't move the object
; ===========================================================================

Obj36_Type01:				; XREF: Obj36_TypeIndex
		bsr.w	Obj36_Wait
		moveq	#0,d0
		move.b	Off34(a0),d0
		add.w	Off32(a0),d0
		move.w	d0,Y_Pos(a0)	; move the object vertically
		rts
; ===========================================================================

Obj36_Type02:				; XREF: Obj36_TypeIndex
		bsr.w	Obj36_Wait
		moveq	#0,d0
		move.b	Off34(a0),d0
		add.w	Off30(a0),d0
		move.w	d0,X_pos(a0)	; move the object horizontally
		rts
; ===========================================================================

Obj36_Wait:
		tst.w	Off38(a0)		; is time delay	= zero?
		beq.s	loc_CFA4	; if yes, branch
		subq.w	#1,Off38(a0)	; subtract 1 from time delay
		bne.s	locret_CFE6
		tst.b	Render_Flags(a0)
		bpl.s	locret_CFE6
		move.w	#$B6,d0
		jsr	(PlaySound).l ;	play "spikes moving" sound
		bra.s	locret_CFE6
; ===========================================================================

loc_CFA4:
		tst.w	Off36(a0)
		beq.s	loc_CFC6
		subi.w	#$800,Off34(a0)
		bhs.s	locret_CFE6
		move.w	#0,Off34(a0)
		move.w	#0,Off36(a0)
		move.w	#60,Off38(a0)	; set time delay to 1 second
		bra.s	locret_CFE6
; ===========================================================================

loc_CFC6:
		addi.w	#$800,Off34(a0)
		cmpi.w	#$2000,Off34(a0)
		blo.s	locret_CFE6
		move.w	#$2000,Off34(a0)
		move.w	#1,Off36(a0)
		move.w	#60,Off38(a0)	; set time delay to 1 second

locret_CFE6:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - spikes
; ---------------------------------------------------------------------------
Map_obj36:
	include "_maps\obj36.asm"
Map_obj39:
	include "_maps\obj39.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3B - purple rock (GHZ)
; ---------------------------------------------------------------------------

Obj3B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj3B_Index(pc,d0.w),d1
		jmp	Obj3B_Index(pc,d1.w)
; ===========================================================================
Obj3B_Index:	dc.w Obj3B_Main-Obj3B_Index
		dc.w Obj3B_Solid-Obj3B_Index
; ===========================================================================

Obj3B_Main:				; XREF: Obj3B_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj3B,Mappings_Offset(a0)
		move.w	#$63D0,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#$13,X_Visible(a0)
		move.b	#4,Priority(a0)

Obj3B_Solid:				; XREF: Obj3B_Index
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$10,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		bsr.w	DisplaySprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 49 - waterfall	sound effect (GHZ)
; ---------------------------------------------------------------------------

Obj49:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj49_Index(pc,d0.w),d1
		jmp	Obj49_Index(pc,d1.w)
; ===========================================================================
Obj49_Index:	dc.w Obj49_Main-Obj49_Index
		dc.w Obj49_PlaySnd-Obj49_Index
; ===========================================================================

Obj49_Main:				; XREF: Obj49_Index
		addq.b	#2,Routine(a0)
		move.b	#4,Render_Flags(a0)

Obj49_PlaySnd:				; XREF: Obj49_Index
		move.b	($FFFFFE0F).w,d0
		andi.b	#$3F,d0
		bne.s	Obj49_ChkDel
		move.w	#$D0,d0
		jsr	(PlaySound).l ;	play waterfall sound

Obj49_ChkDel:
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - purple rock	(GHZ)
; ---------------------------------------------------------------------------
Map_obj3B:
	include "_maps\obj3B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3C - smashable	wall (GHZ, SLZ)
; ---------------------------------------------------------------------------

Obj3C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj3C_Index(pc,d0.w),d1
		jsr	Obj3C_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj3C_Index:	dc.w Obj3C_Main-Obj3C_Index
		dc.w Obj3C_Solid-Obj3C_Index
		dc.w Obj3C_FragMove-Obj3C_Index
; ===========================================================================

Obj3C_Main:				; XREF: Obj3C_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj3C,Mappings_Offset(a0)
		move.w	#$450F,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#4,Priority(a0)
		move.b	Subtype(a0),Anim_Frame(a0)

Obj3C_Solid:				; XREF: Obj3C_Index
		move.w	Object_RAM+X_Vel,Off30(a0) ;	load Sonic's horizontal speed
		move.w	#$1B,d1
		move.w	#$20,d2
		move.w	#$20,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		beq.s	locret_D180

		cmpi.b	#4,Current_Character.w
		beq.s	Obj3C_destroy
		btst	#5,Status(a0)
		bne.s	Obj3C_ChkRoll

locret_D180:
		rts
; ===========================================================================

Obj3C_ChkRoll:				; XREF: Obj3C_Solid
		cmpi.b	#2,Anim(a1)	; is Sonic rolling?
		bne.s	locret_D180	; if not, branch
		move.w	Off30(a0),d0
		bpl.s	Obj3C_ChkSpeed
		neg.w	d0

Obj3C_ChkSpeed:
		cmpi.w	#$480,d0	; is Sonic's speed $480 or higher?
		blo.s	locret_D180	; if not, branch

Obj3C_destroy:
		move.w	Off30(a0),X_Vel(a1)
		addq.w	#4,X_pos(a1)
		lea	(Obj3C_FragSpd1).l,a4 ;	use fragments that move	right
		move.w	X_pos(a0),d0
		cmp.w	X_pos(a1),d0	; is Sonic to the right	of the block?
		blo.s	Obj3C_Smash	; if yes, branch
		subq.w	#8,X_pos(a1)
		lea	(Obj3C_FragSpd2).l,a4 ;	use fragments that move	left

Obj3C_Smash:
		move.w	X_Vel(a1),Inertia(a1)
		bclr	#5,Status(a0)
		bclr	#5,Status(a1)
		move.b	#4,d0
		moveq	#7,d1		; load 8 fragments
		move.w	#$70,d2
		bsr.s	SmashObject

Obj3C_FragMove:				; XREF: Obj3C_Index
		bsr.w	ObjectMove
		addi.w	#$70,Y_Vel(a0)	; make fragment	fall faster
		bsr.w	DisplaySprite
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		rts

; ---------------------------------------------------------------------------
; Subroutine to	smash a	block (GHZ walls and MZ	blocks)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SmashObject:				; XREF: Obj3C_Smash
		move.w	d0,-(sp)
		moveq	#0,d0
		move.b	Anim_Frame(a0),d0
		add.w	d0,d0
		movea.l	Mappings_Offset(a0),a3
		adda.w	(a3,d0.w),a3
		addq.w	#1,a3
		bset	#5,Render_Flags(a0)
		movea.l	a0,a1
		bra.s	Smash_LoadFrag
; ===========================================================================

Smash_Loop:
		bsr.w	SingleObjLoad
		bne.s	Smash_PlaySnd
		addq.w	#5,a3

Smash_LoadFrag:				; XREF: SmashObject
		move.w	(sp),d0
		move.b	d0,Routine(a1)
		move.b	(a0),(a1)
		move.l	a3,Mappings_Offset(a1)
		move.b	Render_Flags(a0),Render_Flags(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.w	Art_Tile(a0),Art_Tile(a1)
		move.b	Priority(a0),Priority(a1)
		move.b	X_Visible(a0),X_Visible(a1)
		move.w	(a4)+,X_Vel(a1)
		move.w	(a4)+,Y_Vel(a1)
		cmpa.l	a0,a1
		bhs.s	loc_D268
		move.l	a0,-(sp)
		movea.l	a1,a0
		bsr.w	ObjectMove
		add.w	d2,Y_Vel(a0)
		movea.l	(sp)+,a0
		bsr.w	DisplaySprite2

loc_D268:
		dbf	d1,Smash_Loop

Smash_PlaySnd:
		move.w	(sp)+,d0
		moveq	#$FFFFFFCB,d0
		jmp	(PlaySound).l ;	play smashing sound
; End of function SmashObject

; ===========================================================================
; Smashed block	fragment speeds
;
Obj3C_FragSpd1:	dc.w $400, $FB00	; x-move speed,	y-move speed
		dc.w $600, $FF00
		dc.w $600, $100
		dc.w $400, $500
		dc.w $600, $FA00
		dc.w $800, $FE00
		dc.w $800, $200
		dc.w $600, $600

Obj3C_FragSpd2:	dc.w $FA00, $FA00
		dc.w $F800, $FE00
		dc.w $F800, $200
		dc.w $FA00, $600
		dc.w $FC00, $FB00
		dc.w $FA00, $FF00
		dc.w $FA00, $100
		dc.w $FC00, $500
; ---------------------------------------------------------------------------
; Sprite mappings - smashable walls (GHZ, SLZ)
; ---------------------------------------------------------------------------
Map_obj3C:
	include "_maps\obj3C.asm"

; ---------------------------------------------------------------------------
; Object code loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

ObjectsLoad2:
		lea	Object_RAM.w,a0 ; set address for object RAM
		moveq	#$1B,d7
		moveq	#0,d0
		bsr.s	OL_Load2
		moveq	#$63,d7
		bra.s	OL_Load

ObjectsLoad:
		lea	Object_RAM.w,a0 ; set address for object RAM
		moveq	#$7F,d7
		moveq	#0,d0
		cmpi.b	#6,Object_RAM+Routine.w
		bhs.s	OL_SonicDead

OL_Load:
		move.b	(a0),d0		; load object number from RAM
		beq.s	.Next
		add.w	d0,d0
		add.w	d0,d0
		movea.l	Obj_Index-4(pc,d0.w),a1
		jsr	(a1)		; run the object's code
		moveq	#0,d0

.Next		lea	Next_Obj(a0),a0	; next object
		dbf	d7,OL_Load

		cmpi.b	#$C,$FFFFF600.w
		bne.s	.skip
		cmpi.w	#7,$FFFFFE10.w
		beq.s	.skip
		move.w	Object_RAM+X_Pos.w,Tails_Tail_RAM+X_Pos.w
		move.w	Object_RAM+Y_Pos.w,Tails_Tail_RAM+Y_Pos.w
		move.w	Object_RAM+X_Pos.w,Shield_RAM+X_Pos.w
		move.w	Object_RAM+Y_Pos.w,Shield_RAM+Y_Pos.w
.skip		rts
; ===========================================================================

OL_SonicDead:
		moveq	#$1F,d7
		bsr.s	OL_Load
		moveq	#$5F,d7

OL_Load2:
		moveq	#0,d0
		move.b	(a0),d0
		beq.s	.Next2
		cmpi.b	#$8F,d0		; is Tails' tail?
		beq.s	.Next2		; if is, branch
		tst.b	Render_Flags(a0)
		bpl.s	.Next2
		bsr.w	DisplaySprite

.Next2		lea	Next_Obj(a0),a0
		dbf	d7,OL_Load2
		rts
; End of function ObjectsLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Object pointers
; ---------------------------------------------------------------------------
Obj_Index:
	include "_inc\Object pointers.asm"

; ---------------------------------------------------------------------------
; Subroutine to	make an	object fall downwards, increasingly fast
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjectFall:
		bsr.s	ObjectMove
		addi.w  #$38,y_vel(a0) ; apply gravity
		rts
; End of function ObjectFall
; continues to ObjectMove

; ---------------------------------------------------------------------------
; Subroutine translating object	speed to update	object position
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

SpeedToPos:
ObjectMove:
		move.w  x_vel(a0),d0
		ext.l   d0
		lsl.l   #8,d0
		add.l   d0,x_pos(a0)
		move.w  y_vel(a0),d0
		ext.l   d0
		lsl.l   #8,d0
		add.l   d0,y_pos(a0)
		rts

; End of function ObjectMove

; ---------------------------------------------------------------------------
; Subroutine to	display	a sprite/object, when a0 is the	object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

DisplaySprite3:
		lea	$FFFFAC00.w,a1
		bra.s	DisplaySprite_

DisplaySprite:
		lea	$FFFFAC00.w,a1
		move.w	Priority(a0),d0
		lsr.w	#1,d0
		andi.w	#$380,d0

DisplaySprite_:
		adda.w	d0,a1
		cmpi.w	#$7E,(a1)
		bhs.s	locret_D620
		addq.w	#2,(a1)
		adda.w	(a1),a1
		move.w	a0,(a1)

locret_D620:
		rts
; End of function DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	display	a 2nd sprite/object, when a1 is	the object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

DisplaySprite4:
		lea	$FFFFAC00,a2
		bra	DisplaySprite2_

DisplaySprite2:
		lea	$FFFFAC00,a2
		move.w	Priority(a1),d0
		lsr.w	#1,d0
		andi.w	#$380,d0

DisplaySprite2_:
		adda.w	d0,a2
		cmpi.w	#$7E,(a2)
		bhs.s	locret_D63E
		addq.w	#2,(a2)
		adda.w	(a2),a2
		move.w	a1,(a2)

locret_D63E:
		rts
; End of function DisplaySprite2

; ---------------------------------------------------------------------------
; Subroutine to	delete an object
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DeleteObject:
		movea.l	a0,a1

DeleteObject2:
		moveq	#0,d1
		moveq	#$F,d0

loc_D646:
		move.l	d1,(a1)+	; clear	the object RAM
		dbf	d0,loc_D646	; repeat $F times (length of object RAM)
		rts
; End of function DeleteObject

; ===========================================================================
BldSpr_ScrPos:	dc.l 0			; blank
		dc.l $FFF700		; main screen x-position
		dc.l $FFF708		; background x-position	1
		dc.l $FFF718		; background x-position	2
; ---------------------------------------------------------------------------
; Subroutine to	convert	mappings (etc) to proper Megadrive sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BuildSprites:				; XREF: TitleScreen; et al
		lea	Hud_RAM+Off3A,a6
		lea	$FFFFF800.w,a2	; set address for sprite table
		moveq	#0,d5
		lea	$FFFFAC00.w,a4
		moveq	#7,d7

loc_D66A:
		tst.w	(a4)
		beq.w	loc_D72E
		moveq	#2,d6

loc_D672:
		movea.w	(a4,d6.w),a0
		tst.b	(a0)
		beq	loc_D726
		bclr	#7,Render_Flags(a0)
		move.b	Render_Flags(a0),d0
		move.b	d0,d4
		andi.w	#$C,d0
		beq	loc_D6DE
		movea.l	BldSpr_ScrPos(pc,d0.w),a1
		moveq	#0,d0
		move.b	X_Visible(a0),d0
		move.w	X_pos(a0),d3
		sub.w	(a1),d3
		move.w	d3,d1
		add.w	d0,d1
		bmi.w	loc_D726
		move.w	d3,d1
		sub.w	d0,d1
		cmpi.w	#$140,d1
		bge.s	loc_D726
		addi.w	#$80,d3
		btst	#4,d4
		beq.s	loc_D6E8
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		move.w	Y_Pos(a0),d2
		sub.w	4(a1),d2
		move.w	d2,d1
		add.w	d0,d1
		bmi.s	loc_D726
		move.w	d2,d1
		sub.w	d0,d1
		cmpi.w	#$E0,d1
		bge.s	loc_D726
		addi.w	#$80,d2
		bra.s	loc_D700
; ===========================================================================

loc_D6DE:
		move.w	X_Pos2(a0),d2
		move.w	X_pos(a0),d3
		bra.s	loc_D700
; ===========================================================================

loc_D6E8:
		move.w	Y_Pos(a0),d2
		sub.w	4(a1),d2
		addi.w	#$80,d2
		cmpi.w	#$60,d2
		blo.s	loc_D726
		cmpi.w	#$180,d2
		bhs.s	loc_D726

loc_D700:
		movea.l	Mappings_Offset(a0),a1
		moveq	#0,d1
		btst	#5,d4
		bne.s	loc_D71C
		move.b	Anim_Frame(a0),d1
		add.w	d1,d1				; MJ: changed from byte to word (we want more than 7F sprites)
		adda.w	(a1,d1.w),a1
		moveq	#0,d1				; MJ: clear d1 (because of our byte to word change)
		move.b	(a1)+,d1
		subq.b	#1,d1
		bmi.s	loc_D720

loc_D71C:
		bsr.w	sub_D750

loc_D720:
		bset	#7,Render_Flags(a0)

loc_D726:
		addq.w	#2,d6
		subq.w	#2,(a4)
		bne.w	loc_D672

loc_D72E:
		lea	$80(a4),a4
		dbf	d7,loc_D66A
		move.b	d5,($FFFFF62B).w
		cmpi.b	#$50,d5
		beq.s	loc_D748
		move.l	#0,(a2)
		rts
; ===========================================================================

loc_D748:
		move.b	#0,-5(a2)
		rts
; End of function BuildSprites


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_D750:				; XREF: BuildSprites
		movea.w	Art_Tile(a0),a3
		btst	#0,d4
		bne.s	loc_D796
		btst	#1,d4
		bne.w	loc_D7E4
; End of function sub_D750


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_D762:				; XREF: sub_D762; SS_ShowLayout
		cmpi.b	#$50,d5
		beq.s	locret_D794
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+

		move.b	(a1)+,(a6)		; 12
		move.w	(a6),d0			; 8
		move.b	(a1)+,d0		; 8

		add.w	a3,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D78E
		addq.w	#1,d0

loc_D78E:
		move.w	d0,(a2)+
		dbf	d1,sub_D762

locret_D794:
		rts
; End of function sub_D762

; ===========================================================================

loc_D796:
		btst	#1,d4
		bne.w	loc_D82A

loc_D79E:
		cmpi.b	#$50,d5
		beq.s	locret_D7E2
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d4
		move.b	d4,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+

		move.b	(a1)+,(a6)		; 12
		move.w	(a6),d0			; 8
		move.b	(a1)+,d0		; 8

		add.w	a3,d0
		eori.w	#$800,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		neg.w	d0
		add.b	d4,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D7DC
		addq.w	#1,d0

loc_D7DC:
		move.w	d0,(a2)+
		dbf	d1,loc_D79E

locret_D7E2:
		rts
; ===========================================================================

loc_D7E4:				; XREF: sub_D750
		cmpi.b	#$50,d5
		beq.s	locret_D828
		move.b	(a1)+,d0
		move.b	(a1),d4
		ext.w	d0
		neg.w	d0
		lsl.b	#3,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+

		move.b	(a1)+,(a6)		; 12
		move.w	(a6),d0			; 8
		move.b	(a1)+,d0		; 8

		add.w	a3,d0
		eori.w	#$1000,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D822
		addq.w	#1,d0

loc_D822:
		move.w	d0,(a2)+
		dbf	d1,loc_D7E4

locret_D828:
		rts
; ===========================================================================

loc_D82A:
		cmpi.b	#$50,d5
		beq.s	locret_D87C
		move.b	(a1)+,d0
		move.b	(a1),d4
		ext.w	d0
		neg.w	d0
		lsl.b	#3,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d4
		move.b	d4,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+

		move.b	(a1)+,(a6)		; 12
		move.w	(a6),d0			; 8
		move.b	(a1)+,d0		; 8

		add.w	a3,d0
		eori.w	#$1800,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		neg.w	d0
		add.b	d4,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D876
		addq.w	#1,d0

loc_D876:
		move.w	d0,(a2)+
		dbf	d1,loc_D82A

locret_D87C:
		rts
; ---------------------------------------------------------------------------
; Subroutine to	check if an object is on the screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChkObjOnScreen:
		move.w	X_pos(a0),d0	; get object x-position
		sub.w	($FFFFF700).w,d0 ; subtract screen x-position
		bmi.s	NotOnScreen
		cmpi.w	#320,d0		; is object on the screen?
		bge.s	NotOnScreen	; if not, branch

		move.w	Y_Pos(a0),d1	; get object y-position
		sub.w	($FFFFF704).w,d1 ; subtract screen y-position
		bmi.s	NotOnScreen
		cmpi.w	#224,d1		; is object on the screen?
		bge.s	NotOnScreen	; if not, branch

		moveq	#0,d0		; set flag to 0
		rts
; ===========================================================================

NotOnScreen:				; XREF: ChkObjOnScreen
		moveq	#1,d0		; set flag to 1
		rts
; End of function ChkObjOnScreen


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChkObjOnScreen2:
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		move.w	X_pos(a0),d0
		sub.w	($FFFFF700).w,d0
		add.w	d1,d0
		bmi.s	NotOnScreen2
		add.w	d1,d1
		sub.w	d1,d0
		cmpi.w	#320,d0
		bge.s	NotOnScreen2

		move.w	Y_Pos(a0),d1
		sub.w	($FFFFF704).w,d1
		bmi.s	NotOnScreen2
		cmpi.w	#224,d1
		bge.s	NotOnScreen2

		moveq	#0,d0
		rts
; ===========================================================================

NotOnScreen2:				; XREF: ChkObjOnScreen2
		moveq	#1,d0
		rts
; End of function ChkObjOnScreen2

; ---------------------------------------------------------------------------
; Subroutine to	load a level's objects
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjPosLoad:				; XREF: Level; et al
		moveq	#0,d0
		move.b	($FFFFF76C).w,d0
		move.w	OPL_Index(pc,d0.w),d0
		jmp	OPL_Index(pc,d0.w)
; End of function ObjPosLoad

; ===========================================================================
OPL_Index:	dc.w OPL_Main-OPL_Index
		dc.w OPL_Next-OPL_Index
; ===========================================================================

OPL_Main:				; XREF: OPL_Index
		addq.b	#2,($FFFFF76C).w
		move.b	$FFFFFE10,d0	; get zone id
		lsl.w	#3,d0		; multiply with 8 (replace 3 with 2 for 4 acts, or with 4 for 16 acts)
		add.b	$FFFFFE11,d0	; add act id
		lsl.w	#2,d0		; multiply with 4
		lea	ObjPos_Index,a0
		movea.l	a0,a1
		adda.w	(a0,d0.w),a0
		move.l	a0,($FFFFF770).w
		move.l	a0,($FFFFF774).w
		adda.w	2(a1,d0.w),a1
		move.l	a1,($FFFFF778).w
		move.l	a1,($FFFFF77C).w
		lea	DestroyTable.w,a2
		move.w	#$101,(a2)+
		move.w	#$5E,d0

OPL_ClrList:
		clr.l	(a2)+
		dbf	d0,OPL_ClrList	; clear	pre-destroyed object list

		lea	DestroyTable.w,a2
		moveq	#0,d2
		move.w	($FFFFF700).w,d6
		subi.w	#$80,d6
		bhs.s	loc_D93C
		moveq	#0,d6

loc_D93C:
		andi.w	#$FF80,d6
		movea.l	($FFFFF770).w,a0

loc_D944:
		cmp.w	(a0),d6
		bls.s	loc_D956
		tst.b	4(a0)
		bpl.s	loc_D952
		move.b	(a2),d2
		addq.b	#1,(a2)

loc_D952:
		addq.w	#6,a0
		bra.s	loc_D944
; ===========================================================================

loc_D956:
		move.l	a0,($FFFFF770).w
		movea.l	($FFFFF774).w,a0
		subi.w	#$80,d6
		blo.s	loc_D976

loc_D964:
		cmp.w	(a0),d6
		bls.s	loc_D976
		tst.b	4(a0)
		bpl.s	loc_D972
		addq.b	#1,1(a2)

loc_D972:
		addq.w	#6,a0
		bra.s	loc_D964
; ===========================================================================

loc_D976:
		move.l	a0,($FFFFF774).w
		move.w	#-1,($FFFFF76E).w

OPL_Next:				; XREF: OPL_Index
		lea	DestroyTable.w,a2
		moveq	#0,d2
		move.w	($FFFFF700).w,d6
		andi.w	#$FF80,d6
		cmp.w	($FFFFF76E).w,d6
		beq.w	locret_DA3A
		bge.s	loc_D9F6
		move.w	d6,($FFFFF76E).w
		movea.l	($FFFFF774).w,a0
		subi.w	#$80,d6
		blo.s	loc_D9D2

loc_D9A6:
		cmp.w	-6(a0),d6
		bge.s	loc_D9D2
		subq.w	#6,a0
		tst.b	4(a0)
		bpl.s	loc_D9BC
		subq.b	#1,1(a2)
		move.b	1(a2),d2

loc_D9BC:
		bsr.w	loc_DA3C
		bne.s	loc_D9C6
		subq.w	#6,a0
		bra.s	loc_D9A6
; ===========================================================================

loc_D9C6:
		tst.b	4(a0)
		bpl.s	loc_D9D0
		addq.b	#1,1(a2)

loc_D9D0:
		addq.w	#6,a0

loc_D9D2:
		move.l	a0,($FFFFF774).w
		movea.l	($FFFFF770).w,a0
		addi.w	#$300,d6

loc_D9DE:
		cmp.w	-6(a0),d6
		bgt.s	loc_D9F0
		tst.b	-2(a0)
		bpl.s	loc_D9EC
		subq.b	#1,(a2)

loc_D9EC:
		subq.w	#6,a0
		bra.s	loc_D9DE
; ===========================================================================

loc_D9F0:
		move.l	a0,($FFFFF770).w
		rts
; ===========================================================================

loc_D9F6:
		move.w	d6,($FFFFF76E).w
		movea.l	($FFFFF770).w,a0
		addi.w	#$280,d6

loc_DA02:
		cmp.w	(a0),d6
		bls.s	loc_DA16
		tst.b	4(a0)
		bpl.s	loc_DA10
		move.b	(a2),d2
		addq.b	#1,(a2)

loc_DA10:
		bsr.w	loc_DA3C
		beq.s	loc_DA02

loc_DA16:
		move.l	a0,($FFFFF770).w
		movea.l	($FFFFF774).w,a0
		subi.w	#$300,d6
		blo.s	loc_DA36

loc_DA24:
		cmp.w	(a0),d6
		bls.s	loc_DA36
		tst.b	4(a0)
		bpl.s	loc_DA32
		addq.b	#1,1(a2)

loc_DA32:
		addq.w	#6,a0
		bra.s	loc_DA24
; ===========================================================================

loc_DA36:
		move.l	a0,($FFFFF774).w

locret_DA3A:
		rts
; ===========================================================================

loc_DA3C:
		tst.b	4(a0)
		bpl.s	OPL_MakeItem
		bset	#7,2(a2,d2.w)
		beq.s	OPL_MakeItem
		addq.w	#6,a0
		moveq	#0,d0
		rts
; ===========================================================================

OPL_MakeItem:
		bsr.w	SingleObjLoad
		bne.s	locret_DA8A
		move.w	(a0)+,X_pos(a1)
		move.w	(a0)+,d0
		move.w	d0,d1
		andi.w	#$FFF,d0
		move.w	d0,Y_Pos(a1)
		rol.w	#2,d1
		andi.b	#3,d1
		move.b	d1,Render_Flags(a1)
		move.b	d1,Status(a1)
		move.b	(a0)+,d0
		bpl.s	loc_DA80
		andi.b	#$7F,d0
		move.b	d2,Respawn(a1)

loc_DA80:
		move.b	d0,(a1)
		move.b	(a0)+,Subtype(a1)
		moveq	#0,d0

locret_DA8A:
		rts
; ---------------------------------------------------------------------------
; Single object	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SingleObjLoad:
		lea	Object_RAM_Free-$40,a1 ; start address for object RAM
		move.w	#$5E,d0

loc_DA94:
		lea	Next_Obj(a1),a1	; goto next object RAM slot
		tst.b	(a1)		; is object RAM	slot empty?
		dbeq	d0,loc_DA94	; if the slot is not empty, repeat $5F times

locret_DAA0:
		rts
; End of function SingleObjLoad


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SingleObjLoad2:
		movea.l	a0,a1
		move.w	#Object_RAM_End-Next_Obj,d0
		sub.w	a0,d0
		lsr.w	#6,d0
		subq.w	#1,d0
		bhs	loc_DA94
		rts
; End of function SingleObjLoad2

; ---------------------------------------------------------------------------
; Subroutine to	detect if object is hitting another objects hitbox
; Input = a0 - first object, a1 - second object, d3 - hitbox 1, d4 - hitbox 2
; Output = d2 - horizontal hit = 0 - no, 1 yes
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

ObjHitHitboxHor:                        ; check Horizontal radius
                move.w	X_Pos(a0),d0
		move.w	X_Pos(a0),d2
		move.w	X_Pos(a1),d1
		bra	HitHitBoxRight

ObjHitHitboxVer:                        ; check Vertical radius
                move.w	Y_Pos(a0),d0
		move.w	Y_Pos(a0),d2
		move.w	Y_Pos(a1),d1

HitHitBoxRight:
		sub.w	d1,d2		; X(a0) - X(a1)
		bmi	HitHitBoxLeft	; if a1 in front
		moveq	#0,d2
		sub.w	d3,d0		; X(a0) + X_Rad(a0)
                add.w	d4,d1		; X(a1) - X_Rad(a1)
                sub.w	d1,d0		; X_res(a0) - X_res(a1)
		bpl	.NotCollide	; is too far away
		moveq	#1,d2
.NotCollide	rts

HitHitBoxLeft:
	      	moveq	#0,d2
		add.w	d3,d0		; X(a0) + X_Rad(a0)
                sub.w	d4,d1 		; X(a1) - X_Rad(a1)
                sub.w	d1,d0		; X_res(a0) - X_res(a1)
		bmi	.NotCollide2	; is too far
		moveq	#1,d2
.NotCollide2	rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 41 - springs
; ---------------------------------------------------------------------------

Obj41:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj41_Index(pc,d0.w),d1
		jsr	Obj41_Index(pc,d1.w)
		bsr.w	DisplaySprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
Obj41_Index:	dc.w Obj41_Main-Obj41_Index
		dc.w Obj41_Up-Obj41_Index
		dc.w Obj41_AniUp-Obj41_Index
		dc.w Obj41_ResetUp-Obj41_Index
		dc.w Obj41_LR-Obj41_Index
		dc.w Obj41_AniLR-Obj41_Index
		dc.w Obj41_ResetLR-Obj41_Index
		dc.w Obj41_Dwn-Obj41_Index
		dc.w Obj41_AniDwn-Obj41_Index
		dc.w Obj41_ResetDwn-Obj41_Index

Obj41_Powers:	dc.w -$1000		; power	of red spring
		dc.w -$A00		; power	of yellow spring
; ===========================================================================

Obj41_Main:				; XREF: Obj41_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj41,Mappings_Offset(a0)
		move.w	#$523,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#4,Priority(a0)
		move.b	Subtype(a0),d0
		btst	#4,d0		; does the spring face left/right?
		beq.s	loc_DB54	; if not, branch
		move.b	#8,Routine(a0)	; use "Obj41_LR" routine
		move.b	#1,Anim(a0)
		move.b	#3,Anim_Frame(a0)
		move.w	#$533,Art_Tile(a0)
		move.b	#8,X_Visible(a0)

loc_DB54:
		btst	#5,d0		; does the spring face downwards?
		beq.s	loc_DB66	; if not, branch
		move.b	#$E,Routine(a0)	; use "Obj41_Dwn" routine
		bset	#1,Status(a0)

loc_DB66:
		btst	#1,d0
		beq.s	loc_DB72
		bset	#5,Art_Tile(a0)

loc_DB72:
		andi.w	#$F,d0
		move.w	Obj41_Powers(pc,d0.w),Off30(a0)
		rts
; ===========================================================================

Obj41_Up:				; XREF: Obj41_Index
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		tst.b	Routine2(a0)		; is Sonic on top of the spring?
		bne.s	Obj41_BounceUp	; if yes, branch
		rts
; ===========================================================================

Obj41_BounceUp:				; XREF: Obj41_Up
		addq.b	#2,Routine(a0)
		bsr	ClearSonicDJ

		addq.w	#8,Y_Pos(a1)
		move.w	Off30(a0),Y_Vel(a1)	; move Sonic upwards
		bset	#1,Status(a1)
		bclr	#3,Status(a1)
		move.b	#2,Routine(a1)
		bclr	#3,Status(a0)
		sf	Routine2(a0)
		move.w	#$CC,d0
		jsr	(PlaySound).l ;	play spring sound

Obj41_AniUp:				; XREF: Obj41_Index
		lea	(Ani_obj41).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_ResetUp:				; XREF: Obj41_Index
		move.b	#1,Anim_Restart(a0)	; reset	animation
		subq.b	#4,Routine(a0)	; goto "Obj41_Up" routine
		rts
; ===========================================================================

Obj41_LR:				; XREF: Obj41_Index
		lea	Object_RAM,a1
		moveq	#0,d4
		move.b	X_Radius(a1),d4
		moveq	#8,d3
		bsr	ObjHitHitboxhor
		cmpi.b	#1,d2
		bne	loc_DC0C

		move.b	Y_Radius(a1),d4
		moveq	#14,d3
		bsr	ObjHitHitboxVer
		cmpi.b	#1,d2
		beq	Obj41_BounceLR

;		move.w	#$13,d1
;		move.w	#$E,d2
;		move.w	#$F,d3
;		move.w	X_pos(a0),d4
;		bsr.w	SolidObject
	;	cmpi.b	#2,Routine(a0)
	;	bne.s	loc_DC0C
	;	move.b	#8,Routine(a0)

loc_DC0C:
	;	btst	#5,Status(a0)
	;	bne.s	Obj41_BounceLR
		rts
; ===========================================================================

Obj41_BounceLR:				; XREF: Obj41_LR
		move.b	#0,$3F(a0)
		bsr	ClearSonicDJ
		addq.b	#2,Routine(a0)
		move.w	Off30(a0),X_Vel(a1)	; move Sonic to	the left
		addq.w	#8,X_pos(a1)
		btst	#0,Status(a0)	; is object flipped?
		bne.s	.NoFlip		; if yes, branch
		subi.w	#$10,X_pos(a1)
		neg.w	X_Vel(a1)		; move Sonic to	the right

.NoFlip		move.w	#$800F,Off3E(a1)
		move.w	X_Vel(a1),Inertia(a1)
		bchg	#0,Status(a1)
		btst	#2,Status(a1)
		bne.s	loc_DC56
		move.b	#0,Anim(a1)	; use running animation

loc_DC56:
		bclr	#5,Status(a0)
		bclr	#5,Status(a1)
		move.w	#$CC,d0
		jsr	(PlaySound).l ;	play spring sound

Obj41_AniLR:				; XREF: Obj41_Index
		lea	(Ani_obj41).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_ResetLR:				; XREF: Obj41_Index
		move.b	#2,Anim_Restart(a0)	; reset	animation
		subq.b	#4,Routine(a0)	; goto "Obj41_LR" routine
		rts
; ===========================================================================

Obj41_Dwn:				; XREF: Obj41_Index
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		cmpi.b	#2,Routine(a0)
		bne.s	loc_DCA4
		move.b	#$E,Routine(a0)

loc_DCA4:
		tst.b	Routine2(a0)
		bne.s	locret_DCAE
		tst.w	d4
		bmi.s	Obj41_BounceDwn

locret_DCAE:
		rts
; ===========================================================================

Obj41_BounceDwn:			; XREF: Obj41_Dwn
		addq.b	#2,Routine(a0)
                bsr	ClearSonicDJ
		subq.w	#8,Y_Pos(a1)
		move.w	Off30(a0),Y_Vel(a1)
		neg.w	Y_Vel(a1)		; move Sonic downwards
		bset	#1,Status(a1)
		bclr	#3,Status(a1)
		move.b	#2,Routine(a1)
		bclr	#3,Status(a0)
		sf	Routine2(a0)
		move.w	#$CC,d0
		jsr	(PlaySound).l ;	play spring sound

Obj41_AniDwn:				; XREF: Obj41_Index
		lea	(Ani_obj41).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_ResetDwn:				; XREF: Obj41_Index
		move.b	#1,Anim_Restart(a0)	; reset	animation
		subq.b	#4,Routine(a0)	; goto "Obj41_Dwn" routine
		rts

ClearSonicDJ:
		moveq	#0,d0
		move.l	d0,If_Spindash
		move.b	d0,PeelOut_Flag
		move.b	d0,Off3C(a1)		; clear jumping
		move.b	d0,SpinDust_RAM+Anim	; clear Spin Dash dust animation
                move.w	d0,Spindash_HorizDelay	; clear screen delay counter

		move.b	Current_Character,d0	; get character id
		move.w	.Index(pc,d0.w),d1	; get index
		jmp	.Index(pc,d1.w)		; jump to correct routine handler

.Index:		dc.w .S-.Index
		dc.w .T-.Index
		dc.w .K-.Index

.S		btst	#4,subtype(a0)	; does the spring face left/right?
		bne	.rts1		; if does, branch
		move.b	#1,Player_DoubleJump	; make sure we can't abuse double jump moves
		bset	#7,Shield_UseType
.RTS		move.b	#$10,Anim(a1)	; use "bouncing" animation
.rts1		rts

.T		btst	#4,subtype(a0)	; does the spring face left/right?
		bne	.rts1		; if does, branch
		clr.l	Player_DJ_Data	; stop flying
		move.b	#$10,Anim(a1)	; use "bouncing" animation
		rts

.K		btst	#4,subtype(a0)	; does the spring face left/right?
		beq	.K_Bump		; if does not, branch
		clr.l	Player_DJ_Data	; stop gliding
		rts

.K_Bump		moveq	#$10,d0
		jmp	K_Glide_HitObj
; ===========================================================================
Ani_obj41:
	include "_anim\obj41.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - springs
; ---------------------------------------------------------------------------
Map_obj41:
	include "_maps\obj41.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 42 - Newtron enemy (GHZ)
; ---------------------------------------------------------------------------

Obj42:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj42_Index(pc,d0.w),d1
		jmp	Obj42_Index(pc,d1.w)
; ===========================================================================
Obj42_Index:	dc.w Obj42_Main-Obj42_Index
		dc.w Obj42_Action-Obj42_Index
		dc.w Obj42_Delete-Obj42_Index
; ===========================================================================

Obj42_Main:				; XREF: Obj42_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj42,Mappings_Offset(a0)
		move.w	#$49B,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$14,X_Visible(a0)
		move.b	#$10,Y_Radius(a0)
		move.b	#8,X_Radius(a0)

Obj42_Action:				; XREF: Obj42_Index
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj42_Index2(pc,d0.w),d1
		jsr	Obj42_Index2(pc,d1.w)
		lea	(Ani_obj42).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj42_Index2:	dc.w Obj42_ChkDist-Obj42_Index2
		dc.w Obj42_Type00-Obj42_Index2
		dc.w Obj42_MatchFloor-Obj42_Index2
		dc.w Obj42_Speed-Obj42_Index2
		dc.w Obj42_Type01-Obj42_Index2
; ===========================================================================

Obj42_ChkDist:				; XREF: Obj42_Index2
		bset	#0,Status(a0)
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	loc_DDEA
		neg.w	d0
		bclr	#0,Status(a0)

loc_DDEA:
		cmpi.w	#$80,d0		; is Sonic within $80 pixels of	the newtron?
		bhs.s	locret_DE12	; if not, branch
		addq.b	#2,Routine2(a0)
		move.b	#1,Anim(a0)
		tst.b	Subtype(a0)		; check	object type
		beq.s	locret_DE12	; if type is 00, branch
		move.w	#$249B,Art_Tile(a0)
		move.b	#8,Routine2(a0)	; run type 01 newtron subroutine
		move.b	#4,Anim(a0)	; use different	animation

locret_DE12:
		rts
; ===========================================================================

Obj42_Type00:				; XREF: Obj42_Index2
		cmpi.b	#4,Anim_Frame(a0)	; has "appearing" animation finished?
		bhs.s	Obj42_Fall	; is yes, branch
		bset	#0,Status(a0)
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	locret_DE32
		bclr	#0,Status(a0)

locret_DE32:
		rts
; ===========================================================================

Obj42_Fall:				; XREF: Obj42_Type00
		cmpi.b	#1,Anim_Frame(a0)
		bne.s	loc_DE42
		move.b	#$C,Coll(a0)

loc_DE42:
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1		; has newtron hit the floor?
		bpl.s	locret_DE86	; if not, branch
		add.w	d1,Y_Pos(a0)
		move.w	#0,Y_Vel(a0)	; stop newtron falling
		addq.b	#2,Routine2(a0)
		move.b	#2,Anim(a0)
		btst	#5,Art_Tile(a0)
		beq.s	Obj42_Move
		addq.b	#1,Anim(a0)

Obj42_Move:
		move.b	#$D,Coll(a0)
		move.w	#$200,X_Vel(a0)	; move newtron horizontally
		btst	#0,Status(a0)
		bne.s	locret_DE86
		neg.w	X_Vel(a0)

locret_DE86:
		rts
; ===========================================================================

Obj42_MatchFloor:			; XREF: Obj42_Index2
		bsr.w	ObjectMove
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	loc_DEA2
		cmpi.w	#$C,d1
		bge.s	loc_DEA2
		add.w	d1,Y_Pos(a0)	; match	newtron's position with floor
		rts
; ===========================================================================

loc_DEA2:
		addq.b	#2,Routine2(a0)
		rts
; ===========================================================================

Obj42_Speed:				; XREF: Obj42_Index2
		bsr.w	ObjectMove
		rts
; ===========================================================================

Obj42_Type01:				; XREF: Obj42_Index2
		cmpi.b	#1,Anim_Frame(a0)
		bne.s	Obj42_FireMissile
		move.b	#$C,Coll(a0)

Obj42_FireMissile:
		cmpi.b	#2,Anim_Frame(a0)
		bne.s	locret_DF14
		tst.b	Off32(a0)
		bne.s	locret_DF14
		move.b	#1,Off32(a0)
		bsr.w	SingleObjLoad
		bne.s	locret_DF14
		move.b	#$23,0(a1)	; load missile object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		subq.w	#8,Y_Pos(a1)
		move.w	#$200,X_Vel(a1)
		move.w	#$14,d0
		btst	#0,Status(a0)
		bne.s	loc_DF04
		neg.w	d0
		neg.w	X_Vel(a1)

loc_DF04:
		add.w	d0,X_pos(a1)
		move.b	Status(a0),Status(a1)
		move.b	#1,Subtype(a1)

locret_DF14:
		rts
; ===========================================================================

Obj42_Delete:				; XREF: Obj42_Index
		bra.w	DeleteObject
; ===========================================================================
Ani_obj42:
	include "_anim\obj42.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Newtron enemy (GHZ)
; ---------------------------------------------------------------------------
Map_obj42:
	include "_maps\obj42.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 43 - Roller enemy (SYZ)
; ---------------------------------------------------------------------------

Obj43:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj43_Index(pc,d0.w),d1
		jmp	Obj43_Index(pc,d1.w)
; ===========================================================================
Obj43_Index:	dc.w Obj43_Main-Obj43_Index
		dc.w Obj43_Action-Obj43_Index
; ===========================================================================

Obj43_Main:				; XREF: Obj43_Index
		move.b	#$E,Y_Radius(a0)
		move.b	#8,X_Radius(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_E052
		add.w	d1,Y_Pos(a0)	; match	roller's position with the floor
		move.w	#0,Y_Vel(a0)
		addq.b	#2,Routine(a0)
		move.l	#Map_obj43,Mappings_Offset(a0)
		move.w	#$4B8,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$10,X_Visible(a0)

locret_E052:
		rts
; ===========================================================================

Obj43_Action:				; XREF: Obj43_Index
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj43_Index2(pc,d0.w),d1
		jsr	Obj43_Index2(pc,d1.w)
		lea	(Ani_obj43).l,a1
		bsr.w	AnimateSprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bgt.w	Obj43_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Obj43_ChkGone:				; XREF: Obj43_Action
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	Obj43_Delete
		bclr	#7,2(a2,d0.w)

Obj43_Delete:
		bra.w	DeleteObject
; ===========================================================================
Obj43_Index2:	dc.w Obj43_RollChk-Obj43_Index2
		dc.w Obj43_RollNoChk-Obj43_Index2
		dc.w Obj43_ChkJump-Obj43_Index2
		dc.w Obj43_MatchFloor-Obj43_Index2
; ===========================================================================

Obj43_RollChk:				; XREF: Obj43_Index2
		move.w	Object_RAM+X_Pos,d0
		subi.w	#$100,d0
		blo.s	loc_E0D2
		sub.w	X_pos(a0),d0	; check	distance between Roller	and Sonic
		blo.s	loc_E0D2
		addq.b	#4,Routine2(a0)
		move.b	#2,Anim(a0)
		move.w	#$700,X_Vel(a0)	; move Roller horizontally
		move.b	#$8E,Coll(a0)	; make Roller invincible

loc_E0D2:
		addq.l	#4,sp
		rts
; ===========================================================================

Obj43_RollNoChk:			; XREF: Obj43_Index2
		cmpi.b	#2,Anim(a0)
		beq.s	loc_E0F8
		subq.w	#1,Off30(a0)
		bpl.s	locret_E0F6
		move.b	#1,Anim(a0)
		move.w	#$700,X_Vel(a0)
		move.b	#$8E,Coll(a0)

locret_E0F6:
		rts
; ===========================================================================

loc_E0F8:
		addq.b	#2,Routine2(a0)
		rts
; ===========================================================================

Obj43_ChkJump:				; XREF: Obj43_Index2
		bsr.w	Obj43_Stop
		bsr.w	ObjectMove
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	Obj43_Jump
		cmpi.w	#$C,d1
		bge.s	Obj43_Jump
		add.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

Obj43_Jump:
		addq.b	#2,Routine2(a0)
		bset	#0,Off32(a0)
		beq.s	locret_E12E
		move.w	#-$600,Y_Vel(a0)	; move Roller vertically

locret_E12E:
		rts
; ===========================================================================

Obj43_MatchFloor:			; XREF: Obj43_Index2
		bsr.w	ObjectFall
		tst.w	Y_Vel(a0)
		bmi.s	locret_E150
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_E150
		add.w	d1,Y_Pos(a0)	; match	Roller's position with the floor
		subq.b	#2,Routine2(a0)
		move.w	#0,Y_Vel(a0)

locret_E150:
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj43_Stop:				; XREF: Obj43_ChkJump
		tst.b	Off32(a0)
		bmi.s	locret_E188
		move.w	Object_RAM+X_Pos,d0
		subi.w	#$30,d0
		sub.w	X_pos(a0),d0
		bhs.s	locret_E188
		move.b	#0,Anim(a0)
		move.b	#$E,Coll(a0)
		clr.w	X_Vel(a0)
		move.w	#120,Off30(a0)	; set waiting time to 2	seconds
		move.b	#2,Routine2(a0)
		bset	#7,Off32(a0)

locret_E188:
		rts
; End of function Obj43_Stop

; ===========================================================================
Ani_obj43:
	include "_anim\obj43.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Roller enemy (SYZ)
; ---------------------------------------------------------------------------
Map_obj43:
	include "_maps\obj43.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 44 - walls (GHZ)
; ---------------------------------------------------------------------------

Obj44:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj44_Index(pc,d0.w),d1
		jmp	Obj44_Index(pc,d1.w)
; ===========================================================================
Obj44_Index:	dc.w Obj44_Main-Obj44_Index
		dc.w Obj44_Solid-Obj44_Index
		dc.w Obj44_Display-Obj44_Index
; ===========================================================================

Obj44_Main:				; XREF: Obj44_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj44,Mappings_Offset(a0)
		move.w	#$434C,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#8,X_Visible(a0)
		move.b	#6,Priority(a0)
		move.b	Subtype(a0),Anim_Frame(a0)	; copy object type number to frame number
		bclr	#4,Anim_Frame(a0)	; clear	4th bit	(deduct	$10)
		beq.s	Obj44_Solid	; make object solid if 4th bit = 0
		addq.b	#2,Routine(a0)
		bra.s	Obj44_Display	; don't make it solid if 4th bit = 1
; ===========================================================================

Obj44_Solid:				; XREF: Obj44_Index
		move.w	#$13,d1
		move.w	#$28,d2
		bsr.w	Obj44_SolidWall

Obj44_Display:				; XREF: Obj44_Index
		bsr.w	DisplaySprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - walls (GHZ)
; ---------------------------------------------------------------------------
Map_obj44:
	include "_maps\obj44.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 13 - lava ball	producer (MZ, SLZ)
; ---------------------------------------------------------------------------

Obj13:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj13_Index(pc,d0.w),d1
		jsr	Obj13_Index(pc,d1.w)
		bra.w	Obj14_ChkDel
; ===========================================================================
Obj13_Index:	dc.w Obj13_Main-Obj13_Index
		dc.w Obj13_MakeLava-Obj13_Index
; ---------------------------------------------------------------------------
;
; Lava ball production rates
;
Obj13_Rates:	dc.b 30, 60, 90, 120, 150, 180
; ===========================================================================

Obj13_Main:				; XREF: Obj13_Index
		addq.b	#2,Routine(a0)
		move.b	Subtype(a0),d0
		lsr.w	#4,d0
		andi.w	#$F,d0
		move.b	Obj13_Rates(pc,d0.w),$1F(a0)
		move.b	$1F(a0),Anim_Dur(a0)	; set time delay for lava balls
		andi.b	#$F,Subtype(a0)

Obj13_MakeLava:				; XREF: Obj13_Index
		subq.b	#1,Anim_Dur(a0)	; subtract 1 from time delay
		bne.s	locret_E302	; if time still	remains, branch
		move.b	$1F(a0),Anim_Dur(a0)	; reset	time delay
		bsr.w	ChkObjOnScreen
		bne.s	locret_E302
		bsr.w	SingleObjLoad
		bne.s	locret_E302
		move.b	#$14,0(a1)	; load lava ball object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	Subtype(a0),Subtype(a1)

locret_E302:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 14 - lava balls (MZ, SLZ)
; ---------------------------------------------------------------------------

Obj14:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj14_Index(pc,d0.w),d1
		jsr	Obj14_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj14_Index:	dc.w Obj14_Main-Obj14_Index
		dc.w Obj14_Action-Obj14_Index
		dc.w Obj14_Delete-Obj14_Index

Obj14_Speeds:	dc.w $FC00, $FB00, $FA00, $F900, $FE00
		dc.w $200, $FE00, $200,	0
; ===========================================================================

Obj14_Main:				; XREF: Obj14_Index
		addq.b	#2,Routine(a0)
		move.b	#8,Y_Radius(a0)
		move.b	#8,X_Radius(a0)
		move.l	#Map_obj14,Mappings_Offset(a0)
		move.w	#$345,Art_Tile(a0)
		cmpi.b	#3,($FFFFFE10).w ; check if level is SLZ
		bne.s	loc_E35A
		move.w	#$480,Art_Tile(a0)	; SLZ specific code

loc_E35A:
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#$8B,Coll(a0)
		move.w	Y_Pos(a0),Off30(a0)
		tst.b	$29(a0)
		beq.s	Obj14_SetSpeed
		addq.b	#2,Priority(a0)

Obj14_SetSpeed:
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		move.w	Obj14_Speeds(pc,d0.w),Y_Vel(a0) ;	load object speed (vertical)
		move.b	#8,X_Visible(a0)
		cmpi.b	#6,Subtype(a0)	; is object type below $6 ?
		blo.s	Obj14_PlaySnd	; if yes, branch
		move.b	#$10,X_Visible(a0)
		move.b	#2,Anim(a0)	; use horizontal animation
		move.w	Y_Vel(a0),X_Vel(a0)	; set horizontal speed
		move.w	#0,Y_Vel(a0)	; delete vertical speed

Obj14_PlaySnd:
		move.w	#$AE,d0
		jsr	(PlaySound).l ;	play lava ball sound

Obj14_Action:				; XREF: Obj14_Index
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		move.w	Obj14_TypeIndex(pc,d0.w),d1
		jsr	Obj14_TypeIndex(pc,d1.w)
		bsr.w	ObjectMove
		lea	(Ani_obj14).l,a1
		bsr.w	AnimateSprite

Obj14_ChkDel:				; XREF: Obj13
		sf	Coll(a0)
	        cmpi.b	#4,Shield_RAM+Inertia
	        beq	.fire
                move.b	#$8B,Coll(a0)

.fire		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
Obj14_TypeIndex:dc.w Obj14_Type00-Obj14_TypeIndex, Obj14_Type00-Obj14_TypeIndex
		dc.w Obj14_Type00-Obj14_TypeIndex, Obj14_Type00-Obj14_TypeIndex
		dc.w Obj14_Type04-Obj14_TypeIndex, Obj14_Type05-Obj14_TypeIndex
		dc.w Obj14_Type06-Obj14_TypeIndex, Obj14_Type07-Obj14_TypeIndex
		dc.w Obj14_Type08-Obj14_TypeIndex
; ===========================================================================
; lavaball types 00-03 fly up and fall back down

Obj14_Type00:				; XREF: Obj14_TypeIndex
		addi.w	#$18,Y_Vel(a0)	; increase object's downward speed
		move.w	Off30(a0),d0
		cmp.w	Y_Pos(a0),d0	; has object fallen back to its	original position?
		bhs.s	loc_E41E	; if not, branch
		addq.b	#2,Routine(a0)	; goto "Obj14_Delete" routine

loc_E41E:
		bclr	#1,Status(a0)
		tst.w	Y_Vel(a0)
		bpl.s	locret_E430
		bset	#1,Status(a0)

locret_E430:
		rts
; ===========================================================================
; lavaball type	04 flies up until it hits the ceiling

Obj14_Type04:				; XREF: Obj14_TypeIndex
		bset	#1,Status(a0)
		jsr	ObjHitCeiling
		tst.w	d1
		bpl.s	locret_E452
		move.b	#8,Subtype(a0)
		move.b	#1,Anim(a0)
		move.w	#0,Y_Vel(a0)	; stop the object when it touches the ceiling

locret_E452:
		rts
; ===========================================================================
; lavaball type	05 falls down until it hits the	floor

Obj14_Type05:				; XREF: Obj14_TypeIndex
		bclr	#1,Status(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_E474
		move.b	#8,Subtype(a0)
		move.b	#1,Anim(a0)
		move.w	#0,Y_Vel(a0)	; stop the object when it touches the floor

locret_E474:
		rts
; ===========================================================================
; lavaball types 06-07 move sideways

Obj14_Type06:				; XREF: Obj14_TypeIndex
		bset	#0,Status(a0)
		moveq	#-8,d3
		jsr	ObjHitWallLeft
		tst.w	d1
		bpl.s	locret_E498
		move.b	#8,Subtype(a0)
		move.b	#3,Anim(a0)
		move.w	#0,X_Vel(a0)	; stop object when it touches a	wall

locret_E498:
		rts
; ===========================================================================

Obj14_Type07:				; XREF: Obj14_TypeIndex
		bclr	#0,Status(a0)
		moveq	#8,d3
		jsr	ObjHitWallRight
		tst.w	d1
		bpl.s	locret_E4BC
		move.b	#8,Subtype(a0)
		move.b	#3,Anim(a0)
		move.w	#0,X_Vel(a0)	; stop object when it touches a	wall

locret_E4BC:
		rts
; ===========================================================================

Obj14_Type08:				; XREF: Obj14_TypeIndex
		rts
; ===========================================================================

Obj14_Delete:				; XREF: Obj14_Index
		bra.w	DeleteObject
; ===========================================================================
Ani_obj14:
	include "_anim\obj14.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6D - flame thrower (SBZ)
; ---------------------------------------------------------------------------

Obj6D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj6D_Index(pc,d0.w),d1
		jmp	Obj6D_Index(pc,d1.w)
; ===========================================================================
Obj6D_Index:	dc.w Obj6D_Main-Obj6D_Index
		dc.w Obj6D_Action-Obj6D_Index
; ===========================================================================

Obj6D_Main:				; XREF: Obj6D_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj6D,Mappings_Offset(a0)
		move.w	#$83D9,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#1,Priority(a0)
		move.w	Y_Pos(a0),Off30(a0)
		move.b	#$C,X_Visible(a0)
		move.b	Subtype(a0),d0
		andi.w	#$F0,d0		; read 1st digit of object type
		add.w	d0,d0		; multiply by 2
		move.w	d0,Off30(a0)
		move.w	d0,Off32(a0)	; set flaming time
		move.b	Subtype(a0),d0
		andi.w	#$F,d0		; read 2nd digit of object type
		lsl.w	#5,d0		; multiply by $20
		move.w	d0,Off34(a0)	; set pause time
		move.b	#$A,Off36(a0)
		btst	#1,Status(a0)
		beq.s	Obj6D_Action
		move.b	#2,Anim(a0)
		move.b	#$15,Off36(a0)

Obj6D_Action:				; XREF: Obj6D_Index
		subq.w	#1,Off30(a0)	; subtract 1 from time
		bpl.s	loc_E57A	; if time remains, branch
		move.w	Off34(a0),Off30(a0)	; begin	pause time
		bchg	#0,Anim(a0)
		beq.s	loc_E57A
		move.w	Off32(a0),Off30(a0)	; begin	flaming	time
		move.w	#$B3,d0
		jsr	(PlaySound).l ;	play flame sound

loc_E57A:
		lea	(Ani_obj6D).l,a1
		bsr.w	AnimateSprite
		move.b	#0,Coll(a0)
		cmpi.b	#4,Shield_RAM+Inertia
	        beq	Obj6D_ChkDel
		move.b	Off36(a0),d0
		cmp.b	Anim_Frame(a0),d0
		bne.s	Obj6D_ChkDel
		move.b	#$A3,Coll(a0)

Obj6D_ChkDel:
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj6D:
	include "_anim\obj6D.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - flame thrower (SBZ)
; ---------------------------------------------------------------------------
Map_obj6D:
	include "_maps\obj6D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 46 - solid blocks and blocks that fall	from the ceiling (MZ)
; ---------------------------------------------------------------------------

Obj46:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj46_Index(pc,d0.w),d1
		jmp	Obj46_Index(pc,d1.w)
; ===========================================================================
Obj46_Index:	dc.w Obj46_Main-Obj46_Index
		dc.w Obj46_Action-Obj46_Index
; ===========================================================================

Obj46_Main:				; XREF: Obj46_Index
		addq.b	#2,Routine(a0)
		move.b	#$F,Y_Radius(a0)
		move.b	#$F,X_Radius(a0)
		move.l	#Map_obj46,Mappings_Offset(a0)
		move.w	#$4000,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#$10,X_Visible(a0)
		move.w	Y_Pos(a0),Off30(a0)
		move.w	#$5C0,Off32(a0)

Obj46_Action:				; XREF: Obj46_Index
		tst.b	Render_Flags(a0)
		bpl.s	Obj46_ChkDel
		moveq	#0,d0
		move.b	Subtype(a0),d0	; get object type

		cmpi.b	#-1,d0
		bne.s	.norm
		bsr	Obj46_FF
		bra.s	.common

.norm		andi.w	#7,d0		; read only the	1st digit
		add.w	d0,d0
		move.w	Obj46_TypeIndex(pc,d0.w),d1
		jsr	Obj46_TypeIndex(pc,d1.w)
.common		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject

Obj46_ChkDel:
		bsr.w	DisplaySprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
Obj46_TypeIndex:dc.w Obj46_Type00-Obj46_TypeIndex
		dc.w Obj46_Type01-Obj46_TypeIndex
		dc.w Obj46_Type02-Obj46_TypeIndex
		dc.w Obj46_Type03-Obj46_TypeIndex
		dc.w Obj46_Type04-Obj46_TypeIndex
		dc.w MZ2_Boss_Block-Obj46_TypeIndex
; ===========================================================================
Obj46_FF:
		move.w	Object_RAM+Y_Pos.w,d0
		sub.w	#$30,d0
		sub.w	Y_pos(a0),d0
		bmi.s	.rts

		addq.w	#4,x_Pos(a0)
		cmpi.w	#$2B0+$20,x_Pos(a0)
		blt.s	.rts
		move.w	#$2B0+$20,x_Pos(a0)

.rts		rts


Obj46_Type02:				; XREF: Obj46_TypeIndex
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	loc_E888
		neg.w	d0

loc_E888:
		cmpi.w	#$90,d0		; is Sonic within $90 pixels of	the block?
		bhs.s	Obj46_Type01	; if not, resume wobbling
		move.b	#3,Subtype(a0)	; if yes, make the block fall

Obj46_Type01:				; XREF: Obj46_TypeIndex
		moveq	#0,d0
		move.b	($FFFFFE74).w,d0
		btst	#3,Subtype(a0)
		beq.s	loc_E8A8
		neg.w	d0
		addi.w	#$10,d0

loc_E8A8:
		move.w	Off30(a0),d1
		sub.w	d0,d1
		move.w	d1,Y_Pos(a0)	; update the block's position to make it wobble

Obj46_Type00:				; XREF: Obj46_TypeIndex
		rts
; ===========================================================================

Obj46_Type03:				; XREF: Obj46_TypeIndex
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)	; increase falling speed
		jsr	ObjHitFloor
		tst.w	d1		; has the block	hit the	floor?
		bpl.w	locret_E8EE	; if not, branch
		add.w	d1,Y_Pos(a0)
		clr.w	Y_Vel(a0)		; stop the block falling
		move.w	Y_Pos(a0),Off30(a0)
		move.b	#4,Subtype(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$2E8,d0
		bhs.s	locret_E8EE
		move.b	#0,Subtype(a0)

locret_E8EE:
		rts
; ===========================================================================

Obj46_Type04:				; XREF: Obj46_TypeIndex
		moveq	#0,d0
		move.b	($FFFFFE70).w,d0
		lsr.w	#3,d0
		move.w	Off30(a0),d1
		sub.w	d0,d1
		move.w	d1,Y_Pos(a0)	; make the block wobble
		rts

MZ2_Boss_Block_FallSpd	equ $3000
MZ2_Boss_Block_MaxY	equ $45C+$30
MZ2_Boss_Block:
	;	ori.w	#$8000,Art_Tile(a0)
		tst.b	$FFFFF7CC.w
		bne.s	.rts

		addi.l	#MZ2_Boss_Block_FallSpd,Y_Pos(a0)
		btst	#3,Status(a0)
		bne.s	.ck
		subi.l	#MZ2_Boss_Block_FallSpd*3,Y_Pos(a0)

		move.w	Off30(a0),d0
		cmp.w	Y_Pos(a0),d0
		blt.s	.rts
		move.w	d0,Y_Pos(a0)
		rts

.ck		cmpi.w	#MZ2_Boss_Block_MaxY,Y_Pos(a0)
		ble.s	.rts
		move.w	#MZ2_Boss_Block_MaxY,Y_Pos(a0)
.rts		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - solid blocks and blocks that fall from the ceiling (MZ)
; ---------------------------------------------------------------------------
Map_obj46:
	include "_maps\obj46.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 12 - lamp (SYZ)
; ---------------------------------------------------------------------------

Obj12:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj12_Index(pc,d0.w),d1
		jmp	Obj12_Index(pc,d1.w)
; ===========================================================================
Obj12_Index:	dc.w Obj12_Main-Obj12_Index
		dc.w Obj12_Animate-Obj12_Index
; ===========================================================================

Obj12_Main:				; XREF: Obj12_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj12,Mappings_Offset(a0)
		move.w	#0,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#6,Priority(a0)

Obj12_Animate:				; XREF: Obj12_Index
		subq.b	#1,Anim_Dur(a0)
		bpl.s	Obj12_ChkDel
		move.b	#7,Anim_Dur(a0)
		addq.b	#1,Anim_Frame(a0)
		cmpi.b	#6,Anim_Frame(a0)
		blo.s	Obj12_ChkDel
		move.b	#0,Anim_Frame(a0)

Obj12_ChkDel:
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - lamp (SYZ)
; ---------------------------------------------------------------------------
Map_obj12:
	include "_maps\obj12.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 47 - pinball bumper (SYZ)
; ---------------------------------------------------------------------------

Obj47:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj47_Index(pc,d0.w),d1
		jmp	Obj47_Index(pc,d1.w)
; ===========================================================================
Obj47_Index:	dc.w Obj47_Main-Obj47_Index
		dc.w Obj47_Hit-Obj47_Index
; ===========================================================================

Obj47_Main:				; XREF: Obj47_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj47,Mappings_Offset(a0)
		move.w	#$380,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#1,Priority(a0)
		move.b	#$D7,Coll(a0)

Obj47_Hit:				; XREF: Obj47_Index
		tst.b	Coll2(a0)		; has Sonic touched the	bumper?
		beq.w	Obj47_Display	; if not, branch
		sf	Coll2(a0)
		lea	Object_RAM,a1
		move.w	X_pos(a0),d1
		move.w	Y_Pos(a0),d2
		sub.w	X_pos(a1),d1
		sub.w	Y_Pos(a1),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		muls.w	#-$700,d1
		asr.l	#8,d1
		move.w	d1,X_Vel(a1)	; bounce Sonic away
		muls.w	#-$700,d0
		asr.l	#8,d0
		move.w	d0,Y_Vel(a1)	; bounce Sonic away
		bset	#1,Status(a1)
		bclr	#4,Status(a1)
		bclr	#5,Status(a1)
		sf	Off3C(a1)
		move.b	#1,Anim(a0)
		move.w	#$B4,d0
		jsr	(PlaySound).l ;	play bumper sound

                tst.b	Player_DoubleJump
		beq	.a
		moveq	#2,d0
		bsr	K_Glide_HitObj

.a		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	Obj47_Score
		cmpi.b	#$8A,2(a2,d0.w)	; has bumper been hit $8A times?
		bhs.s	Obj47_Display	; if yes, Sonic	gets no	points
		addq.b	#1,2(a2,d0.w)

Obj47_Score:
		moveq	#1,d0
		jsr	AddPoints	; add 10 to score

Obj47_Display:
		lea	(Ani_obj47).l,a1
		bsr.w	AnimateSprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj47_ChkHit
		bra.w	DisplaySprite
; ===========================================================================

Obj47_ChkHit:				; XREF: Obj47_Display
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	Obj47_Delete
		bclr	#7,2(a2,d0.w)

Obj47_Delete:
		bra.w	DeleteObject
; ===========================================================================
Ani_obj47:
	include "_anim\obj47.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - pinball bumper (SYZ)
; ---------------------------------------------------------------------------
Map_obj47:
	include "_maps\obj47.asm"

K_Glide_HitObj:
		moveq	#0,d1
		cmpi.b	#4,Current_Character
		bne	.Noanim
		lea	Object_RAM,a1	; get Sonic's RAM to a1
		tst.b	Player_DoubleJump
		beq	.NoAnim
		bclr	#7,$FFFFF7C8.w
		cmpi.b	#$CB,Anim_Frame(a1); are we falling?
		beq	.StopGlide	; if we are, stop gliding
		cmpi.b	#3,Gliding_Main
		beq	.Noanim
                move.b	#2,Gliding_Main
		move.b	#$21,Anim(a1)
		move.b	#$13,Y_Radius(a1)
		move.b	#9,X_Radius(a1)
		rts

.StopGlide	clr.l	Player_DJ_Data	; stop gliding completely
		moveq	#1,d1
.Noanim		move.b	d0,Anim(a1)	; use "bouncing" animation
                cmpi.b	#2,d0		; was the animation 2?
                bne	.rts		; if not, branch
                bset	#2,Status(a1)	; start rolling
.rts		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 04 - Portal turrets
; ---------------------------------------------------------------------------
PortalTurret_minpos = 5
PortalTurret_delayclose = 8
PortalTurret_delayopen  = 2
PortalTurret_width  = 6
PortalTurret_height = 14
PortalTurret_rangex = $80
PortalTurret_rangey = $68
PortalTurret_delayattack = 30

TurretEye_tgtx = Off30
TurretEye_tgty = Off32

; ===========================================================================
Turret_Deleteall:
		lea	Off34(a0),a2
		moveq	#3-1,d6

.loop		move.l	(a2)+,a1
		cmp.b	#4,(a1)
		bne.s	.next
		bsr	DeleteObject2

.next		dbf	d6,.loop
		move.w	x_pos(a0),d6
		move.w	y_pos(a0),d5

		bsr	DeleteObject
		move.b	#$3F,(a0)	; change object	to points
		move.w	d6,x_pos(a0)
		move.w	d5,y_pos(a0)
		bset	#15,Art_Tile(a0)
		lea	.dielist(pc),a1
		bra	PlayTurretSample

.dielist	dc.b 4,$BC,$BD,$BE,$BF, 0
; ===========================================================================
PortalEye:
		ori.w	#$6000,Art_Tile(a0)
		moveq	#0,d0
		movea.l	Off3C(a0),a1
		move.b	Anim_Frame(a1),d0
		add.w	d0,d0
		move.w	.Index(pc,d0.w),d1
		jsr	.Index(pc,d1.w)
		bsr	SpeedToPos

		tst.b	Subtype(a1)
		bpl.w	DisplaySprite
		move.w	x_pos(a1),x_pos(a0)
		move.w	y_pos(a1),y_pos(a0)
		sub.w	#4,y_pos(a0)
		bra.w	DisplaySprite

; ===========================================================================
.Index		dc.w .toturret-.Index, .sonicright-.index, .sonicleft-.index
; ===========================================================================

.sonicright
.sonicleft	lea	Object_RAM+X_Pos.w,a2
		move.w	(a2),TurretEye_tgtx(a0)
		move.w	Y_Pos-X_pos(a2),TurretEye_tgty(a0)

		sf	Coll(a0)
		move.b	$FFFFFE04+1.w,d0
		andi.b	#3,d0
		bne.s	.rts2
		move.b	#$17|$80,Coll(a0)

.rts2		moveq	#2,d4
		moveq	#4,d5
		moveq	#4*2,d6
		bra	.home

; ===========================================================================
.toturret	move.w	X_pos(a1),TurretEye_tgtx(a0)
		move.w	Y_Pos(a1),TurretEye_tgty(a0)
		sub.w	#4,TurretEye_tgty(a0)

		moveq	#4,d4
		moveq	#8,d5
		moveq	#8*2,d6
		bra	.home

; ===========================================================================
.home		move.w	TurretEye_tgtx(a0),d1
		move.w	TurretEye_tgty(a0),d2
		sub.w	x_pos(a0),d1
		sub.w	y_pos(a0),d2
		jsr	CalcAngle
		jsr	CalcSine
		muls.w	d4,d1
		move.w	d1,X_Vel(a0)	; bounce Sonic away
		muls.w	d4,d0
		move.w	d0,Y_Vel(a0)	; bounce Sonic away

		move.w	TurretEye_tgtx(a0),d0
		sub.w	x_pos(a0),d0
		add.w	d5,d0
		cmp.w	d6,d0
		bhi.s	.rts

		move.w	y_pos(a0),d0
		sub.w	TurretEye_tgty(a0),d0
		add.w	d5,d0
		cmp.w	d6,d0
		bhi.s	.rts

		move.w	TurretEye_tgtx(a0),x_pos(a0)
		move.w	TurretEye_tgty(a0),y_pos(a0)
		clr.l	x_vel(a0)

.rts		rts
; ===========================================================================
PortalTurret_Follow:
		movea.l	Off3C(a0),a1
		move.w	x_pos(a1),x_pos(a0)
		move.w	y_pos(a1),y_pos(a0)
		move.b	Anim_Frame(a1),Anim_Frame(a0)

		move.w	Routine(a0),d0
		add.w	d0,x_pos(a0)
		bra.w	DisplaySprite

; ===========================================================================
PortalTurret:
		move.w	Inertia(a0),d0
		jsr	.Index(pc,d0.w)
		sf	Respawn(a0)
		rts
.Index
; ===========================================================================
.init		move.w	#(PortalTurret_height<<8)|PortalTurret_width,Y_Radius(a0)
		sf	Anim_Frame(a0)

		move.w	#-PortalTurret_minpos,d2
		move.b	d2,Routine(a0)
		move.b	Render_Flags(a0),d1
		move.b	#$25|$C0,Coll(a0)

		moveq	#4-1,d6
		movea.l	a0,a1
		lea	Off34(a0),a2
		lea	.data(pc),a3
		bra.s	.loadthis

; ===========================================================================
.data		dc.w 0,				      (4<<8)|3, .waitSonic-.index
		dc.w Map_TurretArmR-Map_PortalTurret, (4<<8)|3, PortalTurret_Follow-.index
		dc.w Map_TurretArmL-Map_PortalTurret, (4<<8)|3, PortalTurret_Follow-.index
		dc.w Map_TurretEye-Map_PortalTurret,  ($24<<8)|0, PortalEye-.index
; ===========================================================================
.loadob		bsr.w	SingleObjLoad2
		bne	Turret_Deleteall
		move.b	#4,(a1)
		move.l	a1,(a2)+
		move.l	a0,Off3C(a1)

		move.b	d1,Render_Flags(a1)
		move.w	d2,Routine(a1)
		neg.w	d2

.loadthis	move.w	#($D560/$20),Art_Tile(a1)
		move.b	#$C,X_Visible(a1)

		move.l	#Map_PortalTurret,d0
		add.w	(a3)+,d0
		move.l	d0,Mappings_Offset(a1)
		move.b	(a3)+,d0
		or.b	d0,Render_Flags(a1)

		move.b	(a3)+,Priority(a1)
		move.w	(a3)+,Inertia(a1)
		move.b	#-1,Coll2(a1)
		dbf	d6,.loadob

		move.w	x_pos(a0),x_pos(a1)
		move.w	y_pos(a0),y_pos(a1)	; fix turret eyes pos

; ===========================================================================
.updateoff	movea.l	Off34(a0),a1
		movea.l	Off38(a0),a2
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	d0,Routine(a2)
		neg.w	d0
		move.w	d0,Routine(a1)
		rts

; ===========================================================================
.waitSonic	cmpi.b	#PortalTurret_minpos,Routine(a0)
		beq.s	.1
		subq.b	#1,Routine2(a0)
		bpl.s	.1

		move.b	#PortalTurret_delayclose,Routine2(a0)
		addq.b	#1,Routine(a0)
		bsr	.updateoff

.1		bsr	.isSonicClose
		bmi.s	.main
		move.w	#.initattack-.index,Inertia(a0)
		move.b	d0,Anim_Frame(a0)
		move.b	#PortalTurret_delayattack,Anim_scriptNum(a0)
		lea	.foundlist(pc),a1
		bsr	PlayTurretSample

.main		jsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	.noland
.land		add.w	d1,Y_Pos(a0)
		clr.w	y_vel(a0)

.noland		bra.w	DisplaySprite

; ===========================================================================
.foundlist	dc.b 4,$AA,$B9,$BA,$BB
.lostlist	dc.b 4,$8C,$8E,$8F,$9C

.initattack	tst.b	Coll2(a0)
		bpl	Turret_Deleteall

		tst.b	Routine(a0)
		beq.s	.2
		subq.b	#1,Routine2(a0)
		bpl.s	.2

		move.b	#PortalTurret_delayopen,Routine2(a0)
		subq.b	#1,Routine(a0)
		bsr	.updateoff

.2		bsr	.isSonicClose
		move.b	d0,Anim_Frame(a0)
		bpl.s	.3
		move.w	#.waitSonic-.index,Inertia(a0)
		sf	Anim_Frame(a0)
		lea	.lostlist(pc),a1
		bsr	PlayTurretSample

.3		jsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bmi.s	.land
		bra.w	DisplaySprite
; ===========================================================================
.isSonicClose	lea	Object_RAM+x_pos,a1	; get Sonic to a1
		move.w	X_pos(a0),d0		; get x position of this
		sub.w	(a1),d0			; sub x position of sonic
		spl	d1
		add.w	#PortalTurret_rangex,d0
		cmp.w	#PortalTurret_rangex*2,d0
		bhi.s	.fail

		move.w	Y_Pos(a0),d0		; get y position of this
		sub.w	Y_Pos-X_pos(a1),d0	; sub y position of sonic
		add.w	#PortalTurret_rangey,d0
		cmp.w	#PortalTurret_rangey*2,d0
		bhi.s	.fail

		moveq	#1,d0
		tst.b	d1
		bpl.s	turret_rts
		moveq	#2,d0
		rts

.fail		moveq	#-1,d0
turret_rts:
		rts

PlayTurretSample:
		tst.b	Respawn(a0)
		bmi.s	turret_rts
		tst.w	$FFFFF614.w
		bne.s	turret_rts
		move.w	#10,$FFFFF614.w
		jsr	RandomNumber		; randomized entry
		moveq	#0,d1
		move.b	(a1)+,d1
		andi.l	#$FFFF,d0		; make sure div wont have issue
		divu.w	d1,d0			; divide by x (lenght of the list
		swap	d0			; swap to remainder being in front
		move.b	(a1,d0.w),d0		; get randomized id
		jmp	PlaySample2
; ===========================================================================
		include "_maps/portalturret.asm"
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0D - signpost at the end of a level
; ---------------------------------------------------------------------------

Obj0D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj0D_Index(pc,d0.w),d1
		jsr	Obj0D_Index(pc,d1.w)

		cmpi.b	#4,Routine(a0)
		blt.s	.chkdel

		lea	DPLC_EndSigns,a2
		move.w	#$680*$20,d4
		move.l	#ArtUnc_EndSigns,d6
		jsr	load_DPLC

		bsr.w	DisplaySprite
.chkdel		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
Obj0D_Index:	dc.w Obj0D_Main-Obj0D_Index
		dc.w Obj0D_Touch-Obj0D_Index
		dc.w Obj0D_Spin-Obj0D_Index
		dc.w Obj0D_SonicRun-Obj0D_Index
		dc.w locret_EC42-Obj0D_Index
; ===========================================================================

Obj0D_Main:				; XREF: Obj0D_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_EndSigns,Mappings_Offset(a0)
		move.w	#$680,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#$18,X_Visible(a0)
		move.b	#$1E,Y_Radius(a0)
		move.b	#4,Priority(a0)
		move.w	Y_Pos(a0),Off3E(a0)
		move.w	#-$40,Y_Pos(a0)
		move.b	#3,Anim_Frame(a0)

Obj0D_Touch:				; XREF: Obj0D_Index
		move.w	$FFFFF704.w,d0
		subi.w	#$40,d0
		move.w	d0,Y_Pos(a0)

		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		blo.s	locret_EBBA
		cmpi.w	#$20,d0		; is Sonic within $20 pixels of	the signpost?
		bhs.s	locret_EBBA	; if not, branch

		moveq	#$FFFFFFCF,d0
		jsr	PlaySound	; play signpost	sound
		moveq	#$FFFFFFE0,d0
		jsr	PlayMusic

		sf	($FFFFFE1E).w	; stop time counter
		move.w	($FFFFF72A).w,($FFFFF728).w ; lock screen position
		addq.b	#2,Routine(a0)
		move.w	#$7FFF,Off30(a0)

		moveq	#0,d0
		move.b	Current_Character.w,d0
		lsr.w	#1,d0
		move.b	d0,Anim(a0)

locret_EBBA:
		rts
; ===========================================================================

Obj0D_Spin:
		lea	Ani_EndSign,a1
		bsr.w	AnimateSprite			; XREF: Obj0D_Index
		jsr 	ObjectFall

		jsr	ObjHitFloor
		tst.b	d1
		bpl.s	.skip
		add.w	d1,Y_Pos(a0)
		move.w	#0,Y_Vel(a0)
		cmpi.w	#$40,Off30(a0)	; if already set timer, dont reset it
		ble.s	.skip
		move.w	#$40,Off30(a0)	; set spin cycle time

.skip		subq.w	#1,Off30(a0)	; subtract 1 from spin time
		bpl.s	Obj0D_Sparkle	; if time remains, branch
		addq.b	#2,Routine(a0)

Obj0D_Sparkle:
		subq.w	#1,Off32(a0)	; subtract 1 from time delay
		bpl.s	locret_EC42	; if time remains, branch
		move.w	#$B,Off32(a0)	; set time between sparkles to $B frames
		moveq	#0,d0
		move.b	Off34(a0),d0
		addq.b	#2,Off34(a0)
		andi.b	#$E,Off34(a0)
		lea	Obj0D_SparkPos(pc,d0.w),a2 ; load sparkle position data
		bsr.w	SingleObjLoad
		bne.s	locret_EC42
		move.b	#$25,(a1)	; load rings object
		move.b	#6,Routine(a1)	; jump to ring sparkle subroutine
		move.b	(a2)+,d0
		ext.w	d0
		add.w	X_pos(a0),d0
		move.w	d0,X_pos(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	Y_Pos(a0),d0
		move.w	d0,Y_Pos(a1)
		move.l	#Map_obj25,Mappings_Offset(a1)
		move.w	#$27B2,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#2,Priority(a1)
		move.b	#8,X_Visible(a1)
		move.b	#4,Anim_Frame(a1)

locret_EC42:
		rts
; ===========================================================================
Obj0D_SparkPos:	dc.b -$18,-$10		; x-position, y-position
		dc.b	8,   8
		dc.b -$10,   0
		dc.b  $18,  -8
		dc.b	0,  -8
		dc.b  $10,   0
		dc.b -$18,   8
		dc.b  $18, $10
; ===========================================================================

Obj0D_SonicRun:				; XREF: Obj0D_Index
		lea	Ani_EndSign,a1
		bsr.w	AnimateSprite			; XREF: Obj0D_Index
		lea	Object_RAM.w,a1

		tst.b	$FFFFFE08.w	; is debug mode	on?
		bne.w	locret_EC42	; if yes, branch
		btst	#1,Status(a1)
		bne.s	locret_EC42
		move.b	#1,($FFFFF7CC).w ; lock	controls
		clr.w	$FFFFF602.w ; make Sonic run to	the right
		sf	if_spindash
		move.l	#0,X_Vel(a1)

		btst	#2,Status(a1)
		beq.s	loc_EC86
		bclr	#2,Status(a1)
		move.w	Player_StandHeight.w,Y_Radius(a1)	; set radius
		subq.w	#5,Y_Pos(a1)

loc_EC70:

loc_EC86:
		addq.b	#2,Routine(a0)

		moveq	#0,d0
		move.b	Current_Character.w,d0
		lsr.w	#1,d0
		move.b	d0,Anim_Frame(a0)

; ---------------------------------------------------------------------------
; Subroutine to	set up bonuses at the end of an	act
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


GotThroughAct:				; XREF: Obj3E_EndAct
		tst.b	($FFFFD5C0).w
		bne.s	locret_EC42
		move.w	($FFFFF72A).w,($FFFFF728).w
		sf	($FFFFFE2D).w	; disable invincibility
		sf	($FFFFFE1E).w	; stop time counter
		move.b	#$3A,($FFFFD5C0).w
		move.b	#1,($FFFFF7D6).w
		moveq	#0,d0
		move.b	($FFFFFE23).w,d0
		mulu.w	#60,d0		; convert minutes to seconds
		moveq	#0,d1
		move.b	($FFFFFE24).w,d1
		add.w	d1,d0		; add up your time
		divu.w	#15,d0		; divide by 15
		moveq	#$14,d1
		cmp.w	d1,d0		; is time 5 minutes or higher?
		blo.s	loc_ECD0	; if not, branch
		move.w	d1,d0		; use minimum time bonus (0)

loc_ECD0:
		add.w	d0,d0
		move.w	TimeBonuses(pc,d0.w),($FFFFF7D2).w ; set time bonus
		move.w	TimeMulti(pc,d0.w),d1
		move.w	($FFFFFE20).w,d0 ; load	number of rings
		mulu.w	#10,d0		; multiply by 10
		move.w	d0,($FFFFF7D4).w ; set ring bonus

		moveq	#0,d0
		move.w	$FFFFFE20.w,d0	; load number of rings
		mulu.w	d1,d0
		add.l	d0,DCL_Rings.w	; add to DLC ring counter

		moveq	#$FFFFFFE4+$13,d0
		buytest	Used_AltMusic
		bne.s	.play
		moveq	#$FFFFFF8E,d0

.play		jsr	PlaySound	; play "Sonic got through" music
		bra	SaveComplete
; End of function GotThroughAct

; ===========================================================================
TimeBonuses:	dc.w 5000, 5000, 1000, 500, 400, 400, 300, 300,	200, 200
		dc.w 200, 200, 100, 100, 100, 100, 50, 50, 50, 50, 0

TimeMulti:	dc.w 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 1
; ===========================================================================
DPLC_EndSigns:	include "_inc/DPLC - End Signs.asm"

Map_EndSigns:	include "_maps/End Signs.asm"

Ani_EndSign:
		dc.w	AniRaw_EndSignsS-Ani_EndSign
		dc.w	AniRaw_EndSignsT-Ani_EndSign
		dc.w	AniRaw_EndSignsK-Ani_EndSign

AniRaw_EndSignsS:
		dc.b	1, 0, 4, 5, 6
		dc.b	3, 4, 5, 6, $FF
AniRaw_EndSignsT:
		dc.b	1, 1, 4, 5, 6
		dc.b	3, 4, 5, 6, $FF
AniRaw_EndSignsK:
		dc.b	1, 2, 4, 5, 6
		dc.b	3, 4, 5, 6, $FF

SaveComplete:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4C - lava geyser / lavafall producer (MZ)
; ---------------------------------------------------------------------------

Obj4C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj4C_Index(pc,d0.w),d1
		jsr	Obj4C_Index(pc,d1.w)
		bra.w	Obj4D_ChkDel
; ===========================================================================
Obj4C_Index:	dc.w Obj4C_Main-Obj4C_Index
		dc.w loc_EDCC-Obj4C_Index
		dc.w loc_EE3E-Obj4C_Index
		dc.w Obj4C_MakeLava-Obj4C_Index
		dc.w Obj4C_Display-Obj4C_Index
		dc.w Obj4C_Delete-Obj4C_Index
; ===========================================================================

Obj4C_Main:				; XREF: Obj4C_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj4C,Mappings_Offset(a0)
		move.w	#$E3A8,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#1,Priority(a0)
		move.b	#$38,X_Visible(a0)
		move.w	#120,Off34(a0)	; set time delay to 2 seconds

loc_EDCC:				; XREF: Obj4C_Index
		subq.w	#1,Off32(a0)
		bpl.s	locret_EDF0
		move.w	Off34(a0),Off32(a0)
		move.w	Object_RAM+Y_Pos,d0
		move.w	Y_Pos(a0),d1
		cmp.w	d1,d0
		bhs.s	locret_EDF0
		subi.w	#$170,d1
		cmp.w	d1,d0
		blo.s	locret_EDF0
		addq.b	#2,Routine(a0)

locret_EDF0:
		rts
; ===========================================================================

Obj4C_MakeLava:				; XREF: Obj4C_Index
		addq.b	#2,Routine(a0)
		bsr.w	SingleObjLoad2
		bne.s	loc_EE18
		move.b	#$4D,(a1)	; load lavafall	object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	Subtype(a0),Subtype(a1)
		move.l	a0,Off3C(a1)

loc_EE18:
		move.b	#1,Anim(a0)
		tst.b	Subtype(a0)		; is object type 00 (geyser) ?
		beq.s	Obj4C_Type00	; if yes, branch
		move.b	#4,Anim(a0)
		bra.s	Obj4C_Display
; ===========================================================================

Obj4C_Type00:				; XREF: Obj4C_MakeLava
		movea.l	Off3C(a0),a1	; load geyser object
		bset	#1,Status(a1)
		move.w	#-$580,Y_Vel(a1)
		bra.s	Obj4C_Display
; ===========================================================================

loc_EE3E:				; XREF: Obj4C_Index
		tst.b	Subtype(a0)		; is object type 00 (geyser) ?
		beq.s	Obj4C_Display	; if yes, branch
		addq.b	#2,Routine(a0)
		rts
; ===========================================================================

Obj4C_Display:				; XREF: Obj4C_Index
		lea	(Ani_obj4C).l,a1
		bsr.w	AnimateSprite
		bsr.w	DisplaySprite
		rts
; ===========================================================================

Obj4C_Delete:				; XREF: Obj4C_Index
		move.b	#0,Anim(a0)
		move.b	#2,Routine(a0)
		tst.b	Subtype(a0)
		beq.w	DeleteObject
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4D - lava geyser / lavafall (MZ)
; ---------------------------------------------------------------------------

Obj4D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj4D_Index(pc,d0.w),d1
		jsr	Obj4D_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj4D_Index:	dc.w Obj4D_Main-Obj4D_Index
		dc.w Obj4D_Action-Obj4D_Index
		dc.w loc_EFFC-Obj4D_Index
		dc.w Obj4D_Delete-Obj4D_Index

Obj4D_Speeds:	dc.w $FB00, 0
; ===========================================================================

Obj4D_Main:				; XREF: Obj4D_Index
		addq.b	#2,Routine(a0)
		move.w	Y_Pos(a0),Off30(a0)
		tst.b	Subtype(a0)
		beq.s	loc_EEA4
		subi.w	#$250,Y_Pos(a0)

loc_EEA4:
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		move.w	Obj4D_Speeds(pc,d0.w),Y_Vel(a0)
		movea.l	a0,a1
		moveq	#1,d1
		bsr.s	Obj4D_MakeLava
		bra.s	loc_EF10
; ===========================================================================

Obj4D_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_EF0A

Obj4D_MakeLava:				; XREF: Obj4D_Main
		move.b	#$4D,(a1)
		move.l	#Map_obj4C,Mappings_Offset(a1)
		move.w	#$63A8,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#$20,X_Visible(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	Subtype(a0),Subtype(a1)
		move.b	#1,Priority(a1)
		move.b	#5,Anim(a1)
		tst.b	Subtype(a0)
		beq.s	loc_EF0A
		move.b	#2,Anim(a1)

loc_EF0A:
		dbf	d1,Obj4D_Loop
		rts
; ===========================================================================

loc_EF10:				; XREF: Obj4D_Main
		addi.w	#$60,Y_Pos(a1)
		move.w	Off30(a0),Off30(a1)
		addi.w	#$60,Off30(a1)
		move.b	#$93,Coll(a1)
		move.b	#$80,Y_Radius(a1)
		bset	#4,Render_Flags(a1)
		addq.b	#4,Routine(a1)
		move.l	a0,Off3C(a1)
		tst.b	Subtype(a0)
		beq.s	Obj4D_PlaySnd
		moveq	#0,d1
		bsr.w	Obj4D_Loop
		addq.b	#2,Routine(a1)
		bset	#4,Art_Tile(a1)
		addi.w	#$100,Y_Pos(a1)
		move.b	#0,Priority(a1)
		move.w	Off30(a0),Off30(a1)
		move.l	Off3C(a0),Off3C(a1)
		move.b	#0,Subtype(a0)

Obj4D_PlaySnd:
		move.w	#$C8,d0
		jsr	(PlaySound).l ;	play flame sound

Obj4D_Action:				; XREF: Obj4D_Index
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		move.w	Obj4D_TypeIndex(pc,d0.w),d1
		jsr	Obj4D_TypeIndex(pc,d1.w)
		bsr.w	ObjectMove
		lea	Ani_obj4C,a1
		bsr	AnimateSprite

Obj4D_ChkDel:				; XREF: Obj4C
	        cmpi.b	#4,Shield_RAM+Inertia
	        bne	.fire
	        sf	Coll(a0)

.fire		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
Obj4D_TypeIndex:dc.w Obj4D_Type00-Obj4D_TypeIndex
		dc.w Obj4D_Type01-Obj4D_TypeIndex
; ===========================================================================

Obj4D_Type00:				; XREF: Obj4D_TypeIndex
		addi.w	#$18,Y_Vel(a0)	; increase object's falling speed
		move.w	Off30(a0),d0
		cmp.w	Y_Pos(a0),d0
		bhs.s	locret_EFDA
		addq.b	#4,Routine(a0)
		movea.l	Off3C(a0),a1
		move.b	#3,Anim(a1)

locret_EFDA:
		rts
; ===========================================================================

Obj4D_Type01:				; XREF: Obj4D_TypeIndex
		addi.w	#$18,Y_Vel(a0)	; increase object's falling speed
		move.w	Off30(a0),d0
		cmp.w	Y_Pos(a0),d0
		bhs.s	locret_EFFA
		addq.b	#4,Routine(a0)
		movea.l	Off3C(a0),a1
		move.b	#1,Anim(a1)

locret_EFFA:
		rts
; ===========================================================================

loc_EFFC:				; XREF: Obj4D_Index
		movea.l	Off3C(a0),a1
		cmpi.b	#6,Routine(a1)
		beq.w	Obj4D_Delete
		move.w	Y_Pos(a1),d0
		addi.w	#$60,d0
		move.w	d0,Y_Pos(a0)
		sub.w	Off30(a0),d0
		neg.w	d0
		moveq	#8,d1
		cmpi.w	#$40,d0
		bge.s	loc_F026
		moveq	#$B,d1

loc_F026:
		cmpi.w	#$80,d0
		ble.s	loc_F02E
		moveq	#$E,d1

loc_F02E:
		subq.b	#1,Anim_Dur(a0)
		bpl.s	loc_F04C
		move.b	#7,Anim_Dur(a0)
		addq.b	#1,Anim_scriptNum(a0)
		cmpi.b	#2,Anim_scriptNum(a0)
		blo.s	loc_F04C
		move.b	#0,Anim_scriptNum(a0)

loc_F04C:
		move.b	Anim_scriptNum(a0),d0
		add.b	d1,d0
		move.b	d0,Anim_Frame(a0)
		bra.w	Obj4D_ChkDel
; ===========================================================================

Obj4D_Delete:				; XREF: Obj4D_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4E - advancing	wall of	lava (MZ)
; ---------------------------------------------------------------------------

Obj4E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj4E_Index(pc,d0.w),d1
		jmp	Obj4E_Index(pc,d1.w)
; ===========================================================================
Obj4E_Index:	dc.w Obj4E_Main-Obj4E_Index
		dc.w Obj4E_Solid-Obj4E_Index
		dc.w Obj4E_Action-Obj4E_Index
		dc.w Obj4E_Move2-Obj4E_Index
		dc.w Obj4E_Delete-Obj4E_Index
; ===========================================================================

Obj4E_Main:				; XREF: Obj4E_Index
		addq.b	#4,Routine(a0)
		movea.l	a0,a1
		moveq	#1,d1
		bra.s	Obj4E_Main2
; ===========================================================================

Obj4E_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_F0C8

Obj4E_Main2:				; XREF: Obj4E_Main
		move.b	#$4E,(a1)	; load object
		move.l	#Map_obj4E,Mappings_Offset(a1)
		move.w	#$63A8,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#$50,X_Visible(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	#1,Priority(a1)
		move.b	#0,Anim(a1)
		move.b	#$94,Coll(a1)
		move.l	a0,Off3C(a1)

loc_F0C8:
		dbf	d1,Obj4E_Loop	; repeat sequence once

		addq.b	#6,Routine(a1)
		move.b	#4,Anim_Frame(a1)

Obj4E_Action:				; XREF: Obj4E_Index
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	Obj4E_ChkSonic
		neg.w	d0

Obj4E_ChkSonic:
		cmpi.w	#$C0,d0		; is Sonic within $C0 pixels (x-axis)?
		bhs.s	Obj4E_Move	; if not, branch
		move.w	Object_RAM+Y_Pos,d0
		sub.w	Y_Pos(a0),d0
		bhs.s	loc_F0F4
		neg.w	d0

loc_F0F4:
		cmpi.w	#$60,d0		; is Sonic within $60 pixels (y-axis)?
		bhs.s	Obj4E_Move	; if not, branch
		move.b	#1,Off36(a0)	; set object to	move
		bra.s	Obj4E_Solid
; ===========================================================================

Obj4E_Move:				; XREF: Obj4E_ChkSonic
		tst.b	Off36(a0)		; is object set	to move?
		beq.s	Obj4E_Solid	; if not, branch
		move.w	#$180,X_Vel(a0)	; set object speed
		subq.b	#2,Routine(a0)

Obj4E_Solid:				; XREF: Obj4E_Index
		move.w	#$2B,d1
		move.w	#$18,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	X_pos(a0),d4
		move.b	Routine(a0),d0
		move.w	d0,-(sp)
		bsr.w	SolidObject
		move.w	(sp)+,d0
		move.b	d0,Routine(a0)
		cmpi.w	#$6A0,X_pos(a0)	; has object reached $6A0 on the x-axis?
		bne.s	Obj4E_Animate	; if not, branch
		clr.w	X_Vel(a0)		; stop object moving
		sf	Off36(a0)

Obj4E_Animate:
		lea	(Ani_obj4E).l,a1
		bsr.w	AnimateSprite
		cmpi.b	#4,Object_RAM+Routine
		bhs.s	Obj4E_ChkDel
		bsr.w	ObjectMove

Obj4E_ChkDel:
		bsr.w	DisplaySprite
		sf	Coll(a0)
	        cmpi.b	#4,Shield_RAM+Inertia
	        beq	.fire
		move.b	#$94,Coll(a0)

.fire		tst.b	Off36(a0)
		bne.s	locret_F17E
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj4E_ChkGone

locret_F17E:
		rts
; ===========================================================================

Obj4E_ChkGone:				; XREF: Obj4E_ChkDel
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		bclr	#7,2(a2,d0.w)
		move.b	#8,Routine(a0)
		rts
; ===========================================================================

Obj4E_Move2:				; XREF: Obj4E_Index
		movea.l	Off3C(a0),a1
		cmpi.b	#8,Routine(a1)
		beq.s	Obj4E_Delete
		move.w	X_pos(a1),X_pos(a0)	; move rest of lava wall
		subi.w	#$80,X_pos(a0)
		bra.w	DisplaySprite
; ===========================================================================

Obj4E_Delete:				; XREF: Obj4E_Index
		bra.w	DeleteObject

; ===========================================================================
; ---------------------------------------------------------------------------
; Dummy object useful to only show art!
; ---------------------------------------------------------------------------

Obj_Dummy:
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	$FFFFF700,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi	DeleteObject
		bra	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 54 - invisible	lava tag (MZ)
; ---------------------------------------------------------------------------

Obj54:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj54_Index(pc,d0.w),d1
		jmp	Obj54_Index(pc,d1.w)
; ===========================================================================
Obj54_Index:	dc.w Obj54_Main-Obj54_Index
		dc.w Obj54_ChkDel-Obj54_Index

Obj54_Sizes:	dc.b $96, $94, $95, 0
; ===========================================================================

Obj54_Main:				; XREF: Obj54_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj54,Mappings_Offset(a0)
		move.b	#$84,Render_Flags(a0)

Obj54_ChkDel:				; XREF: Obj54_Index
	        sf	Coll(a0)
	        cmpi.b	#4,Shield_RAM+Inertia
	        beq	.Fire
		moveq	#0,d0
		move.b	Subtype(a0),d0
		move.b	Obj54_Sizes(pc,d0.w),Coll(a0)

.fire		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		bmi.w	DeleteObject
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - invisible lava tag (MZ)
; ---------------------------------------------------------------------------
Map_obj54:
	include "_maps\obj54.asm"

Ani_obj4C:
	include "_anim\obj4C.asm"

Ani_obj4E:
	include "_anim\obj4E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - lava geyser / lava that falls from the ceiling (MZ)
; ---------------------------------------------------------------------------
Map_obj4C:
	include "_maps\obj4C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - advancing wall of lava (MZ)
; ---------------------------------------------------------------------------
Map_obj4E:
	include "_maps\obj4E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 40 - Moto Bug enemy (GHZ)
; ---------------------------------------------------------------------------

Obj40:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj40_Index(pc,d0.w),d1
		jmp	Obj40_Index(pc,d1.w)
; ===========================================================================
Obj40_Index:	dc.w Obj40_Main-Obj40_Index
		dc.w Obj40_Action-Obj40_Index
		dc.w Obj40_Animate-Obj40_Index
		dc.w Obj40_Delete-Obj40_Index
; ===========================================================================

Obj40_Main:				; XREF: Obj40_Index
		move.l	#Map_obj40,Mappings_Offset(a0)
		move.w	#$4F0,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$14,X_Visible(a0)
		tst.b	Anim(a0)		; is object a smoke trail?
		bne.s	Obj40_SetSmoke	; if yes, branch
		move.b	#$E,Y_Radius(a0)
		move.b	#8,X_Radius(a0)
		move.b	#$C,Coll(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_F68A
		add.w	d1,Y_Pos(a0)	; match	object's position with the floor
		move.w	#0,Y_Vel(a0)
		addq.b	#2,Routine(a0)
		bchg	#0,Status(a0)

locret_F68A:
		rts
; ===========================================================================

Obj40_SetSmoke:				; XREF: Obj40_Main
		addq.b	#4,Routine(a0)
		bra.w	Obj40_Animate
; ===========================================================================

Obj40_Action:				; XREF: Obj40_Index
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj40_Index2(pc,d0.w),d1
		jsr	Obj40_Index2(pc,d1.w)
		lea	(Ani_obj40).l,a1
		bsr.w	AnimateSprite

; ---------------------------------------------------------------------------
; Routine to mark an enemy/monitor/ring	as destroyed
; ---------------------------------------------------------------------------

MarkObjGone:
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Mark_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Mark_ChkGone:
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	Mark_Delete
		bclr	#7,2(a2,d0.w)

Mark_Delete:
		bra.w	DeleteObject

; ===========================================================================
Obj40_Index2:	dc.w Obj40_Move-Obj40_Index2
		dc.w Obj40_FixToFloor-Obj40_Index2
; ===========================================================================

Obj40_Move:				; XREF: Obj40_Index2
		subq.w	#1,Off30(a0)	; subtract 1 from pause	time
		bpl.s	locret_F70A	; if time remains, branch
		addq.b	#2,Routine2(a0)
		move.w	#-$100,X_Vel(a0)	; move object to the left
		move.b	#1,Anim(a0)
		bchg	#0,Status(a0)
		bne.s	locret_F70A
		neg.w	X_Vel(a0)		; change direction

locret_F70A:
		rts
; ===========================================================================

Obj40_FixToFloor:			; XREF: Obj40_Index2
		bsr.w	ObjectMove
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	Obj40_Pause
		cmpi.w	#$C,d1
		bge.s	Obj40_Pause
		add.w	d1,Y_Pos(a0)	; match	object's position with the floor
		subq.b	#1,Off33(a0)
		bpl.s	locret_F756
		move.b	#$F,Off33(a0)
		bsr.w	SingleObjLoad
		bne.s	locret_F756
		move.b	#$40,0(a1)	; load exhaust smoke object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	Status(a0),Status(a1)
		move.b	#2,Anim(a1)

locret_F756:
		rts
; ===========================================================================

Obj40_Pause:				; XREF: Obj40_FixToFloor
		subq.b	#2,Routine2(a0)
		move.w	#59,Off30(a0)	; set pause time to 1 second
		move.w	#0,X_Vel(a0)	; stop the object moving
		move.b	#0,Anim(a0)
		rts
; ===========================================================================

Obj40_Animate:				; XREF: Obj40_Index
		lea	(Ani_obj40).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj40_Delete:				; XREF: Obj40_Index
		bra.w	DeleteObject
; ===========================================================================
Ani_obj40:
	include "_anim\obj40.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Moto Bug enemy (GHZ)
; ---------------------------------------------------------------------------
Map_obj40:
	include "_maps\obj40.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4F - blank
; ---------------------------------------------------------------------------

Obj4F:					; XREF: Obj_Index
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj50_ChkWall:				; XREF: Obj50_FixToFloor
		move.w	($FFFFFE04).w,d0
		add.w	d7,d0
		andi.w	#3,d0
		bne.s	loc_F836
		moveq	#0,d3
		move.b	X_Visible(a0),d3
		tst.w	X_Vel(a0)
		bmi.s	loc_F82C
		jsr	ObjHitWallRight
		tst.w	d1
		bpl.s	loc_F836

loc_F828:
		moveq	#1,d0
		rts
; ===========================================================================

loc_F82C:
		not.w	d3
		jsr	ObjHitWallLeft
		tst.w	d1
		bmi.s	loc_F828

loc_F836:
		moveq	#0,d0
		rts
; End of function Obj50_ChkWall

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 50 - Yadrin enemy (SYZ)
; ---------------------------------------------------------------------------

Obj50:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj50_Index(pc,d0.w),d1
		jmp	Obj50_Index(pc,d1.w)
; ===========================================================================
Obj50_Index:	dc.w Obj50_Main-Obj50_Index
		dc.w Obj50_Action-Obj50_Index
; ===========================================================================

Obj50_Main:				; XREF: Obj50_Index
		move.l	#Map_obj50,Mappings_Offset(a0)
		move.w	#$247B,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$14,X_Visible(a0)
		move.b	#$11,Y_Radius(a0)
		move.b	#8,X_Radius(a0)
		move.b	#$CC,Coll(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_F89E
		add.w	d1,Y_Pos(a0)	; match	object's position with the floor
		move.w	#0,Y_Vel(a0)
		addq.b	#2,Routine(a0)
		bchg	#0,Status(a0)

locret_F89E:
		rts
; ===========================================================================

Obj50_Action:				; XREF: Obj50_Index
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj50_Index2(pc,d0.w),d1
		jsr	Obj50_Index2(pc,d1.w)
		lea	(Ani_obj50).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj50_Index2:	dc.w Obj50_Move-Obj50_Index2
		dc.w Obj50_FixToFloor-Obj50_Index2
; ===========================================================================

Obj50_Move:				; XREF: Obj50_Index2
		subq.w	#1,Off30(a0)	; subtract 1 from pause	time
		bpl.s	locret_F8E2	; if time remains, branch
		addq.b	#2,Routine2(a0)
		move.w	#-$100,X_Vel(a0)	; move object
		move.b	#1,Anim(a0)
		bchg	#0,Status(a0)
		bne.s	locret_F8E2
		neg.w	X_Vel(a0)		; change direction

locret_F8E2:
		rts
; ===========================================================================

Obj50_FixToFloor:			; XREF: Obj50_Index2
		bsr.w	ObjectMove
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	Obj50_Pause
		cmpi.w	#$C,d1
		bge.s	Obj50_Pause
		add.w	d1,Y_Pos(a0)	; match	object's position to the floor
		bsr.w	Obj50_ChkWall
		bne.s	Obj50_Pause
		rts
; ===========================================================================

Obj50_Pause:				; XREF: Obj50_FixToFloor
		subq.b	#2,Routine2(a0)
		move.w	#59,Off30(a0)	; set pause time to 1 second
		move.w	#0,X_Vel(a0)
		move.b	#0,Anim(a0)
		rts
; ===========================================================================
Ani_obj50:
	include "_anim\obj50.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Yadrin enemy (SYZ)
; ---------------------------------------------------------------------------
Map_obj50:
	include "_maps\obj50.asm"

; ---------------------------------------------------------------------------
; Solid	object subroutine (includes spikes, blocks, rocks etc)
;
; variables:
; d1 = width
; d2 = height /	2 (when	jumping)
; d3 = height /	2 (when	walking)
; d4 = x-axis position
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SolidObject:
		tst.b	Routine2(a0)
		beq.w	loc_FAC8
		move.w	d1,d2
		add.w	d2,d2
		lea	Object_RAM,a1
		btst	#1,Status(a1)
		bne.s	loc_F9FE
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d1,d0
		bmi.s	loc_F9FE
		cmp.w	d2,d0
		blo.s	loc_FA12

loc_F9FE:
		bclr	#3,Status(a1)
		bclr	#3,Status(a0)
		sf	Routine2(a0)
		moveq	#0,d4
		rts
; ===========================================================================

loc_FA12:
		move.w	d4,d2
		jsr	MvSonicOnPtfm
		moveq	#0,d4
		rts
; ===========================================================================

SolidObject71:				; XREF: Obj71_Solid
		tst.b	Routine2(a0)
		beq.w	loc_FAD0
		move.w	d1,d2
		add.w	d2,d2
		lea	Object_RAM,a1
		btst	#1,Status(a1)
		bne.s	loc_FA44
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d1,d0
		bmi.s	loc_FA44
		cmp.w	d2,d0
		blo.s	loc_FA58

loc_FA44:
		bclr	#3,Status(a1)
		bclr	#3,Status(a0)
		sf	Routine2(a0)
		moveq	#0,d4
		rts
; ===========================================================================

loc_FA58:
		move.w	d4,d2
		jsr	MvSonicOnPtfm
		moveq	#0,d4
		rts
; ===========================================================================

SolidObject2F:				; XREF: Obj2F_Solid
		lea	Object_RAM,a1
		tst.b	Render_Flags(a0)
		bpl.w	loc_FB92
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d1,d0
		bmi.w	loc_FB92
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	loc_FB92
		move.w	d0,d5
		btst	#0,Render_Flags(a0)
		beq.s	loc_FA94
		not.w	d5
		add.w	d3,d5

loc_FA94:
		lsr.w	#1,d5
		moveq	#0,d3
		move.b	(a2,d5.w),d3
		sub.b	(a2),d3
		move.w	Y_Pos(a0),d5
		sub.w	d3,d5
		move.b	Y_Radius(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	Y_Pos(a1),d3
		sub.w	d5,d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	loc_FB92
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bhs.w	loc_FB92
		bra.w	loc_FB0E
; ===========================================================================

loc_FAC8:
		tst.b	Render_Flags(a0)
		bpl.w	loc_FB92

loc_FAD0:
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d1,d0
		bmi.w	loc_FB92
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	loc_FB92
		move.b	Y_Radius(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	Y_Pos(a1),d3
		sub.w	Y_Pos(a0),d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	loc_FB92
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bhs.w	loc_FB92

loc_FB0E:
		tst.b	($FFFFF7C8).w
		bmi.w	loc_FB92
		cmpi.b	#6,Object_RAM+Routine
		bhs.w	loc_FB92
		tst.b	$FFFFFE08.w
		bne.w	loc_FBAC
		move.w	d0,d5
		cmp.w	d0,d1
		bhs.s	loc_FB36
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_FB36:
		move.w	d3,d1
		cmp.w	d3,d2
		bhs.s	loc_FB44
		subq.w	#4,d3
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_FB44:
		cmp.w	d1,d5
		bhi.w	loc_FBB0
		cmpi.w	#4,d1
		bls.s	loc_FB8C
		tst.w	d0
		beq.s	loc_FB70
		bmi.s	loc_FB5E
		tst.w	X_Vel(a1)
		bmi.s	loc_FB70
		bra.s	loc_FB64
; ===========================================================================

loc_FB5E:
		tst.w	X_Vel(a1)
		bpl.s	loc_FB70

loc_FB64:
		move.w	#0,Inertia(a1)	; stop Sonic moving
		move.w	#0,X_Vel(a1)

loc_FB70:
		sub.w	d0,X_pos(a1)
		btst	#1,Status(a1)
		bne.s	loc_FB8C
		bset	#5,Status(a1)
		bset	#5,Status(a0)
		bset    #5,Gliding_2
		bclr	#7,Player_DoubleJump
		move.b	#7,GlidingCollTimer	; set to not being able to move for 7 frames
		moveq	#1,d4
		rts

; ===========================================================================

loc_FB8C:
		bsr.s	loc_FBA0
		moveq	#1,d4
		rts
; ===========================================================================

loc_FB92:
		btst	#5,Status(a0)
		beq.s	loc_FBAC
		cmpi.b	#2,Anim(a1)	; check if in jumping/rolling animation
		beq.s	loc_FBA0
		cmpi.b	#$17,Anim(a1)	; check if in drowning animation
		beq.s	loc_FBA0
		cmpi.b	#$1A,Anim(a1)	; check if in hurt animation
		beq.s	loc_FBA0
		cmpi.b	#9,Anim(a1)	; check if in jumping/rolling animation
		beq.s	loc_FBA0
		move.w	#1,Anim(a1)	; use walking animation

loc_FBA0:
		bclr	#5,Status(a0)
		bclr	#5,Status(a1)

loc_FBAC:
		moveq	#0,d4
		rts
; ===========================================================================

loc_FBB0:
		tst.w	d3
		bmi.s	loc_FBBC
		cmpi.w	#$10,d3
		blo.s	loc_FBEE
		bra.s	loc_FB92
; ===========================================================================

loc_FBBC:
		tst.w	Y_Vel(a1)
		beq.s	loc_FBD6
		bpl.s	loc_FBD2
		tst.w	d3
		bpl.s	loc_FBD2
		move.w	#0,Y_Vel(a1)	; stop Sonic moving

loc_FBD2:
		sub.w	d3,Y_Pos(a1)
		bclr	#7,Player_DoubleJump
		move.b	#7,GlidingCollTimer	; set to not being able to move for 7 frames
		moveq	#-1,d4
		rts
; ===========================================================================

loc_FBD6:
		btst	#1,Status(a1)
		bne.s	loc_FBD2
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	KillSonic
		movea.l	(sp)+,a0
		moveq	#-1,d4
		rts
; ===========================================================================

loc_FBEE:
		subq.w	#4,d3
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		move.w	d1,d2
		add.w	d2,d2
		add.w	X_pos(a1),d1
		sub.w	X_pos(a0),d1
		bmi.s	loc_FC28
		cmp.w	d2,d1
		bhs.s	loc_FC28
		tst.w	Y_Vel(a1)
		bmi.s	loc_FC28
		sub.w	d3,Y_Pos(a1)
		subq.w	#1,Y_Pos(a1)
		bsr.s	sub_FC2C
		move.b	#2,Routine2(a0)
		bset	#3,Status(a0)

		bclr	#7,Player_DoubleJump
		move.b	#7,GlidingCollTimer	; set to not being able to move for 7 frames
		moveq	#-1,d4
		rts
; ===========================================================================

loc_FC28:
		moveq	#0,d4
		rts
; End of function SolidObject


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_FC2C:				; XREF: SolidObject
		btst	#3,Status(a1)
		beq.s	loc_FC4E
		moveq	#0,d0
		move.b	Off3D(a1),d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a2
		bclr	#3,Status(a2)
		sf	Routine2(a2)

loc_FC4E:
		move.w	a0,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,Off3D(a1)
		sf	Angle(a1)
		move.w	#0,Y_Vel(a1)
		move.w	X_Vel(a1),Inertia(a1)
		btst	#1,Status(a1)
		beq.s	loc_FC84
		movea.l	a0,a2
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	Sonic_ResetOnFloor
		movea.l	(sp)+,a0

loc_FC84:
		bset	#3,Status(a1)
		bset	#3,Status(a0)
		bset    #1,Gliding_2
		move.b	#7,GlidingCollTimer	; set to not being able to move for 7 frames
		bclr	#7,Player_DoubleJump
		rts
; End of function sub_FC2C

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 51 - smashable	green block (MZ)
; ---------------------------------------------------------------------------

Obj51:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj51_Index(pc,d0.w),d1
		jsr	Obj51_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj51_Index:	dc.w Obj51_Main-Obj51_Index
		dc.w Obj51_Solid-Obj51_Index
		dc.w Obj51_Display-Obj51_Index
; ===========================================================================

Obj51_Main:				; XREF: Obj51_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj51,Mappings_Offset(a0)
		move.w	#$42B8,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#4,Priority(a0)
		move.b	Subtype(a0),Anim_Frame(a0)

Obj51_Solid:				; XREF: Obj51_Index
		move.w	($FFFFF7D0).w,Off34(a0)
		move.b	Object_RAM+Anim,Off32(a0) ;	load Sonic's animation number
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		btst	#3,Status(a0)
		bne.s	Obj51_Smash

locret_FCFC:
		rts
; ===========================================================================

Obj51_Smash:				; XREF: Obj51_Solid
		cmpi.b	#2,Off32(a0)	; is Sonic rolling/jumping?
		bne.s	locret_FCFC	; if not, branch
		move.w	Off34(a0),($FFFFF7D0).w
		bset	#2,Status(a1)
		move.b	#$E,Y_Radius(a1)
		move.b	#7,X_Radius(a1)
		move.b	#2,Anim(a1)
		move.w	#-$300,Y_Vel(a1)	; bounce Sonic upwards
		bset	#1,Status(a1)
		bclr	#3,Status(a1)
		move.b	#2,Routine(a1)
		bclr	#3,Status(a0)
		sf	Routine2(a0)
		move.b	#1,Anim_Frame(a0)
		lea	(Obj51_Speeds).l,a4 ; load broken	fragment speed data
		moveq	#3,d1		; set number of	fragments to 4
		move.w	#$38,d2
		move.b	#4,d0
		bsr.w	SmashObject
		move.w	($FFFFF7D0).w,d2
		addq.w	#2,($FFFFF7D0).w
		cmpi.w	#6,d2
		blo.s	Obj51_Bonus
		moveq	#6,d2

Obj51_Bonus:
		moveq	#0,d0
		move.w	Obj51_Points(pc,d2.w),d0
		cmpi.w	#$20,($FFFFF7D0).w ; have 16 blocks been smashed?
		blo.s	loc_FD98	; if not, branch
		move.w	#1000,d0	; give higher points for 16th block
		moveq	#10,d2

loc_FD98:
		jsr	AddPoints

Obj51_Display:				; XREF: Obj51_Index
		bsr.w	ObjectMove
		addi.w	#$38,Y_Vel(a0)
		bsr.w	DisplaySprite
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		rts
; ===========================================================================
Obj51_Speeds:	dc.w $FE00, $FE00	; x-speed, y-speed
		dc.w $FF00, $FF00
		dc.w $200, $FE00
		dc.w $100, $FF00

Obj51_Points:	dc.w 10, 20, 50, 100
; ---------------------------------------------------------------------------
; Sprite mappings - smashable green block (MZ)
; ---------------------------------------------------------------------------
Map_obj51:
	include "_maps\obj51.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 52 - moving platform blocks (MZ, LZ, SBZ)
; ---------------------------------------------------------------------------

Obj52:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj52_Index(pc,d0.w),d1
		jmp	Obj52_Index(pc,d1.w)
; ===========================================================================
Obj52_Index:	dc.w Obj52_Main-Obj52_Index
		dc.w Obj52_Platform-Obj52_Index
		dc.w Obj52_StandOn-Obj52_Index

Obj52_Var:	dc.b $10, 0		; object width,	frame number
		dc.b $20, 1
		dc.b $20, 2
		dc.b $40, 3
		dc.b $30, 4
; ===========================================================================

Obj52_Main:				; XREF: Obj52_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj52,Mappings_Offset(a0)
		move.w	#$42B8,Art_Tile(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	loc_FE44
		move.l	#Map_obj52a,Mappings_Offset(a0) ; LZ specific	code
		move.w	#$43BC,Art_Tile(a0)
		move.b	#7,Y_Radius(a0)

loc_FE44:
		cmpi.b	#5,($FFFFFE10).w ; check if level is SBZ
		bne.s	loc_FE60
		move.w	#$22C0,Art_Tile(a0)	; SBZ specific code (object 5228)
		cmpi.b	#$28,Subtype(a0)	; is object 5228 ?
		beq.s	loc_FE60	; if yes, branch
		move.w	#$4460,Art_Tile(a0)	; SBZ specific code (object 523x)

loc_FE60:
		move.b	#4,Render_Flags(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Obj52_Var(pc,d0.w),a2
		move.b	(a2)+,X_Visible(a0)
		move.b	(a2)+,Anim_Frame(a0)
		move.b	#4,Priority(a0)
		move.w	X_pos(a0),Off30(a0)
		move.w	Y_Pos(a0),Off32(a0)
		andi.b	#$F,Subtype(a0)

Obj52_Platform:				; XREF: Obj52_Index
		bsr.w	Obj52_Move
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(PlatformObject).l
		bra.s	Obj52_ChkDel
; ===========================================================================

Obj52_StandOn:				; XREF: Obj52_Index
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(ExitPlatform).l
		move.w	X_pos(a0),-(sp)
		bsr.w	Obj52_Move
		move.w	(sp)+,d2
		jsr	(MvSonicOnPtfm2).l

Obj52_ChkDel:				; XREF: Obj52_Platform
		move.w	Off30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

Obj52_Move:				; XREF: Obj52_Platform; Obj52_StandOn
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj52_TypeIndex(pc,d0.w),d1
		jmp	Obj52_TypeIndex(pc,d1.w)
; ===========================================================================
Obj52_TypeIndex:dc.w Obj52_Type00-Obj52_TypeIndex, Obj52_Type01-Obj52_TypeIndex
		dc.w Obj52_Type02-Obj52_TypeIndex, Obj52_Type03-Obj52_TypeIndex
		dc.w Obj52_Type02-Obj52_TypeIndex, Obj52_Type05-Obj52_TypeIndex
		dc.w Obj52_Type06-Obj52_TypeIndex, Obj52_Type07-Obj52_TypeIndex
		dc.w Obj52_Type08-Obj52_TypeIndex, Obj52_Type02-Obj52_TypeIndex
		dc.w Obj52_Type0A-Obj52_TypeIndex
; ===========================================================================

Obj52_Type00:				; XREF: Obj52_TypeIndex
		rts
; ===========================================================================

Obj52_Type01:				; XREF: Obj52_TypeIndex
		move.b	($FFFFFE6C).w,d0
		move.w	#$60,d1
		btst	#0,Status(a0)
		beq.s	loc_FF26
		neg.w	d0
		add.w	d1,d0

loc_FF26:
		move.w	Off30(a0),d1
		sub.w	d0,d1
		move.w	d1,X_pos(a0)
		rts
; ===========================================================================

Obj52_Type02:				; XREF: Obj52_TypeIndex
		cmpi.b	#4,Routine(a0)	; is Sonic standing on the platform?
		bne.s	Obj52_02_Wait
		addq.b	#1,Subtype(a0)	; if yes, add 1	to type

Obj52_02_Wait:
		rts
; ===========================================================================

Obj52_Type03:				; XREF: Obj52_TypeIndex
		moveq	#0,d3
		move.b	X_Visible(a0),d3
		jsr	ObjHitWallRight
		tst.w	d1		; has the platform hit a wall?
		bmi.s	Obj52_03_End	; if yes, branch
		addq.w	#1,X_pos(a0)	; move platform	to the right
		move.w	X_pos(a0),Off30(a0)
		rts
; ===========================================================================

Obj52_03_End:
		sf	Subtype(a0)		; change to type 00 (non-moving	type)
		rts
; ===========================================================================

Obj52_Type05:				; XREF: Obj52_TypeIndex
		moveq	#0,d3
		move.b	X_Visible(a0),d3
		jsr	ObjHitWallRight
		tst.w	d1		; has the platform hit a wall?
		bmi.s	Obj52_05_End	; if yes, branch
		addq.w	#1,X_pos(a0)	; move platform	to the right
		move.w	X_pos(a0),Off30(a0)
		rts
; ===========================================================================

Obj52_05_End:
		addq.b	#1,Subtype(a0)	; change to type 06 (falling)
		rts
; ===========================================================================

Obj52_Type06:				; XREF: Obj52_TypeIndex
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)	; make the platform fall
		jsr	ObjHitFloor
		tst.w	d1		; has platform hit the floor?
		bpl.w	locret_FFA0	; if not, branch
		add.w	d1,Y_Pos(a0)
		clr.w	Y_Vel(a0)		; stop platform	falling
		sf	Subtype(a0)		; change to type 00 (non-moving)

locret_FFA0:
		rts
; ===========================================================================

Obj52_Type07:				; XREF: Obj52_TypeIndex
		tst.b	($FFFFF7E2).w	; has switch number 02 been pressed?
		beq.s	Obj52_07_ChkDel
		subq.b	#3,Subtype(a0)	; if yes, change object	type to	04

Obj52_07_ChkDel:
		addq.l	#4,sp
		move.w	Off30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================

Obj52_Type08:				; XREF: Obj52_TypeIndex
		move.b	($FFFFFE7C).w,d0
		move.w	#$80,d1
		btst	#0,Status(a0)
		beq.s	loc_FFE2
		neg.w	d0
		add.w	d1,d0

loc_FFE2:
		move.w	Off32(a0),d1
		sub.w	d0,d1
		move.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

Obj52_Type0A:				; XREF: Obj52_TypeIndex
		moveq	#0,d3
		move.b	X_Visible(a0),d3
		add.w	d3,d3
		moveq	#8,d1
		btst	#0,Status(a0)
		beq.s	loc_10004
		neg.w	d1
		neg.w	d3

loc_10004:
		tst.w	Off36(a0)		; is platform set to move back?
		bne.s	Obj52_0A_Back	; if yes, branch
		move.w	X_pos(a0),d0
		sub.w	Off30(a0),d0
		cmp.w	d3,d0
		beq.s	Obj52_0A_Wait
		add.w	d1,X_pos(a0)	; move platform
		move.w	#300,Off34(a0)	; set time delay to 5 seconds
		rts
; ===========================================================================

Obj52_0A_Wait:
		subq.w	#1,Off34(a0)	; subtract 1 from time delay
		bne.s	locret_1002E	; if time remains, branch
		move.w	#1,Off36(a0)	; set platform to move back to its original position

locret_1002E:
		rts
; ===========================================================================

Obj52_0A_Back:
		move.w	X_pos(a0),d0
		sub.w	Off30(a0),d0
		beq.s	Obj52_0A_Reset
		sub.w	d1,X_pos(a0)	; return platform to its original position
		rts
; ===========================================================================

Obj52_0A_Reset:
		clr.w	Off36(a0)
		subq.b	#1,Subtype(a0)
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - moving blocks (MZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj52:
	include "_maps\obj52mz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - moving block (LZ)
; ---------------------------------------------------------------------------
Map_obj52a:
	include "_maps\obj52lz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 55 - Basaran enemy (MZ)
; ---------------------------------------------------------------------------

Obj55:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj55_Index(pc,d0.w),d1
		jmp	Obj55_Index(pc,d1.w)
; ===========================================================================
Obj55_Index:	dc.w Obj55_Main-Obj55_Index
		dc.w Obj55_Action-Obj55_Index
; ===========================================================================

Obj55_Main:				; XREF: Obj55_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj55,Mappings_Offset(a0)
		move.w	#$84B8,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#$C,Y_Radius(a0)
		move.b	#2,Priority(a0)
		move.b	#$B,Coll(a0)
		move.b	#$10,X_Visible(a0)

Obj55_Action:				; XREF: Obj55_Index
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj55_Index2(pc,d0.w),d1
		jsr	Obj55_Index2(pc,d1.w)
		lea	(Ani_obj55).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj55_Index2:	dc.w Obj55_ChkDrop-Obj55_Index2
		dc.w Obj55_DropFly-Obj55_Index2
		dc.w Obj55_PlaySnd-Obj55_Index2
		dc.w Obj55_FlyUp-Obj55_Index2
; ===========================================================================

Obj55_ChkDrop:				; XREF: Obj55_Index2
		move.w	#$80,d2
		bsr.w	Obj55_ChkSonic
		bhs.s	Obj55_NoDrop
		move.w	Object_RAM+Y_Pos,d0
		move.w	d0,Off36(a0)
		sub.w	Y_Pos(a0),d0
		blo.s	Obj55_NoDrop
		cmpi.w	#$80,d0		; is Sonic within $80 pixels of	basaran?
		bhs.s	Obj55_NoDrop	; if not, branch
		tst.b	$FFFFFE08.w	; is debug mode	on?
		bne.s	Obj55_NoDrop	; if yes, branch
		move.b	($FFFFFE0F).w,d0
		add.b	d7,d0
		andi.b	#7,d0
		bne.s	Obj55_NoDrop
		move.b	#1,Anim(a0)
		addq.b	#2,Routine2(a0)

Obj55_NoDrop:
		rts
; ===========================================================================

Obj55_DropFly:				; XREF: Obj55_Index2
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)	; make basaran fall
		move.w	#$80,d2
		bsr.w	Obj55_ChkSonic
		move.w	Off36(a0),d0
		sub.w	Y_Pos(a0),d0
		blo.s	Obj55_ChkDel
		cmpi.w	#$10,d0
		bhs.s	locret_10180
		move.w	d1,X_Vel(a0)	; make basaran fly horizontally
		move.w	#0,Y_Vel(a0)	; stop basaran falling
		move.b	#2,Anim(a0)
		addq.b	#2,Routine2(a0)

locret_10180:
		rts
; ===========================================================================

Obj55_ChkDel:				; XREF: Obj55_DropFly
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		rts
; ===========================================================================

Obj55_PlaySnd:				; XREF: Obj55_Index2
		move.b	($FFFFFE0F).w,d0
		andi.b	#$F,d0
		bne.s	loc_101A0
		move.w	#$C0,d0
		jsr	(PlaySound).l ;	play flapping sound

loc_101A0:
		bsr.w	ObjectMove
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	loc_101B0
		neg.w	d0

loc_101B0:
		cmpi.w	#$80,d0
		blo.s	locret_101C6
		move.b	($FFFFFE0F).w,d0
		add.b	d7,d0
		andi.b	#7,d0
		bne.s	locret_101C6
		addq.b	#2,Routine2(a0)

locret_101C6:
		rts
; ===========================================================================

Obj55_FlyUp:				; XREF: Obj55_Index2
		bsr.w	ObjectMove
		subi.w	#$18,Y_Vel(a0)	; make basaran fly upwards
		jsr	ObjHitCeiling
		tst.w	d1		; has basaran hit the ceiling?
		bpl.s	locret_101F4	; if not, branch
		sub.w	d1,Y_Pos(a0)
		andi.w	#$FFF8,X_pos(a0)
		clr.w	X_Vel(a0)		; stop basaran moving
		clr.w	Y_Vel(a0)
		sf	Anim(a0)
		sf	Routine2(a0)

locret_101F4:
		rts
; ===========================================================================

Obj55_ChkSonic:				; XREF: Obj55_ChkDrop
		move.w	#$100,d1
		bset	#0,Status(a0)
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	loc_10214
		neg.w	d0
		neg.w	d1
		bclr	#0,Status(a0)

loc_10214:
		cmp.w	d2,d0
		rts
; ===========================================================================
		bsr.w	ObjectMove
		bsr.w	DisplaySprite
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		rts
; ===========================================================================
Ani_obj55:
	include "_anim\obj55.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Basaran enemy (MZ)
; ---------------------------------------------------------------------------
Map_obj55:
	include "_maps\obj55.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 56 - moving blocks (SYZ/SLZ), large doors (LZ)
; ---------------------------------------------------------------------------

Obj56:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj56_Index(pc,d0.w),d1
		jmp	Obj56_Index(pc,d1.w)
; ===========================================================================
Obj56_Index:	dc.w Obj56_Main-Obj56_Index
		dc.w Obj56_Action-Obj56_Index

Obj56_Var:	dc.b  $10, $10		; width, height
		dc.b  $20, $20
		dc.b  $10, $20
		dc.b  $20, $1A
		dc.b  $10, $27
		dc.b  $10, $10
		dc.b	8, $20
		dc.b  $40, $10
; ===========================================================================

Obj56_Main:				; XREF: Obj56_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj56,Mappings_Offset(a0)
		move.w	#$4000,Art_Tile(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	loc_102C8
		move.w	#$43C4,Art_Tile(a0)	; LZ specific code

loc_102C8:
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		lea	Obj56_Var(pc,d0.w),a2
		move.b	(a2)+,X_Visible(a0)
		move.b	(a2),Y_Radius(a0)
		lsr.w	#1,d0
		move.b	d0,Anim_Frame(a0)
		move.w	X_pos(a0),Off34(a0)
		move.w	Y_Pos(a0),Off30(a0)
		moveq	#0,d0
		move.b	(a2),d0
		add.w	d0,d0
		move.w	d0,Off3A(a0)
		moveq	#0,d0
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		beq.s	loc_10332
		move.b	Subtype(a0),d0	; SYZ/SLZ specific code
		andi.w	#$F,d0
		subq.w	#8,d0
		blo.s	loc_10332
		lsl.w	#2,d0
		lea	($FFFFFE8A).w,a2
		lea	(a2,d0.w),a2
		tst.w	(a2)
		bpl.s	loc_10332
		bchg	#0,Status(a0)

loc_10332:
		move.b	Subtype(a0),d0
		bpl.s	Obj56_Action
		andi.b	#$F,d0
		move.b	d0,Off3C(a0)
		move.b	#5,Subtype(a0)
		cmpi.b	#7,Anim_Frame(a0)
		bne.s	Obj56_ChkGone
		move.b	#$C,Subtype(a0)
		move.w	#$80,Off3A(a0)

Obj56_ChkGone:
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	Obj56_Action
		bclr	#7,2(a2,d0.w)
		btst	#0,2(a2,d0.w)
		beq.s	Obj56_Action
		addq.b	#1,Subtype(a0)
		clr.w	Off3A(a0)

Obj56_Action:				; XREF: Obj56_Index
		move.w	X_pos(a0),-(sp)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; get object type
		andi.w	#$F,d0		; read only the	2nd digit
		add.w	d0,d0
		move.w	Obj56_TypeIndex(pc,d0.w),d1
		jsr	Obj56_TypeIndex(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	Render_Flags(a0)
		bpl.s	Obj56_ChkDel
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	Y_Radius(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		bsr.w	SolidObject

Obj56_ChkDel:
		move.w	Off34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj56_TypeIndex:dc.w Obj56_Type00-Obj56_TypeIndex, Obj56_Type01-Obj56_TypeIndex
		dc.w Obj56_Type02-Obj56_TypeIndex, Obj56_Type03-Obj56_TypeIndex
		dc.w Obj56_Type04-Obj56_TypeIndex, Obj56_Type05-Obj56_TypeIndex
		dc.w Obj56_Type06-Obj56_TypeIndex, Obj56_Type07-Obj56_TypeIndex
		dc.w Obj56_Type08-Obj56_TypeIndex, Obj56_Type09-Obj56_TypeIndex
		dc.w Obj56_Type0A-Obj56_TypeIndex, Obj56_Type0B-Obj56_TypeIndex
		dc.w Obj56_Type0C-Obj56_TypeIndex, Obj56_Type0D-Obj56_TypeIndex
; ===========================================================================

Obj56_Type00:				; XREF: Obj56_TypeIndex
		rts
; ===========================================================================

Obj56_Type01:				; XREF: Obj56_TypeIndex
		move.w	#$40,d1
		moveq	#0,d0
		move.b	($FFFFFE68).w,d0
		bra.s	Obj56_Move_LR
; ===========================================================================

Obj56_Type02:				; XREF: Obj56_TypeIndex
		move.w	#$80,d1
		moveq	#0,d0
		move.b	($FFFFFE7C).w,d0

Obj56_Move_LR:
		btst	#0,Status(a0)
		beq.s	loc_10416
		neg.w	d0
		add.w	d1,d0

loc_10416:
		move.w	Off34(a0),d1
		sub.w	d0,d1
		move.w	d1,X_pos(a0)	; move object horizontally
		rts
; ===========================================================================

Obj56_Type03:				; XREF: Obj56_TypeIndex
		move.w	#$40,d1
		moveq	#0,d0
		move.b	($FFFFFE68).w,d0
		bra.s	Obj56_Move_UD
; ===========================================================================

Obj56_Type04:				; XREF: Obj56_TypeIndex
		move.w	#$80,d1
		moveq	#0,d0
		move.b	($FFFFFE7C).w,d0

Obj56_Move_UD:
		btst	#0,Status(a0)
		beq.s	loc_10444
		neg.w	d0
		add.w	d1,d0

loc_10444:
		move.w	Off30(a0),d1
		sub.w	d0,d1
		move.w	d1,Y_Pos(a0)	; move object vertically
		rts
; ===========================================================================

Obj56_Type05:				; XREF: Obj56_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_104A4
		cmpi.w	#$100,($FFFFFE10).w ; is level LZ1 ?
		bne.s	loc_1047A	; if not, branch
		cmpi.b	#3,Off3C(a0)
		bne.s	loc_1047A
		sf	($FFFFF7C9).w
		move.w	Object_RAM+X_Pos,d0
		cmp.w	X_pos(a0),d0
		bhs.s	loc_1047A
		move.b	#1,($FFFFF7C9).w

loc_1047A:
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	Off3C(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_104AE
		cmpi.w	#$100,($FFFFFE10).w ; is level LZ1 ?
		bne.s	loc_1049E	; if not, branch
		cmpi.b	#3,d0
		bne.s	loc_1049E
		sf	($FFFFF7C9).w

loc_1049E:
		move.b	#1,Off38(a0)

loc_104A4:
		tst.w	Off3A(a0)
		beq.s	loc_104C8
		subq.w	#2,Off3A(a0)

loc_104AE:
		move.w	Off3A(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_104BC
		neg.w	d0

loc_104BC:
		move.w	Off30(a0),d1
		add.w	d0,d1
		move.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

loc_104C8:
		addq.b	#1,Subtype(a0)
		sf	Off38(a0)
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_104AE
		bset	#0,2(a2,d0.w)
		bra.s	loc_104AE
; ===========================================================================

Obj56_Type06:				; XREF: Obj56_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_10500
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	Off3C(a0),d0
		tst.b	(a2,d0.w)
		bpl.s	loc_10512
		move.b	#1,Off38(a0)

loc_10500:
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		add.w	d0,d0
		cmp.w	Off3A(a0),d0
		beq.s	loc_1052C
		addq.w	#2,Off3A(a0)

loc_10512:
		move.w	Off3A(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_10520
		neg.w	d0

loc_10520:
		move.w	Off30(a0),d1
		add.w	d0,d1
		move.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

loc_1052C:
		subq.b	#1,Subtype(a0)
		sf	Off38(a0)
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_10512
		bclr	#0,2(a2,d0.w)
		bra.s	loc_10512
; ===========================================================================

Obj56_Type07:				; XREF: Obj56_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_1055E
		tst.b	($FFFFF7EF).w	; has switch number $F been pressed?
		beq.s	locret_10578
		move.b	#1,Off38(a0)
		clr.w	Off3A(a0)

loc_1055E:
		addq.w	#1,X_pos(a0)
		move.w	X_pos(a0),Off34(a0)
		addq.w	#1,Off3A(a0)
		cmpi.w	#$380,Off3A(a0)
		bne.s	locret_10578
		sf	Subtype(a0)

locret_10578:
		rts
; ===========================================================================

Obj56_Type0C:				; XREF: Obj56_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_10598
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	Off3C(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_105A2
		move.b	#1,Off38(a0)

loc_10598:
		tst.w	Off3A(a0)
		beq.s	loc_105C0
		subq.w	#2,Off3A(a0)

loc_105A2:
		move.w	Off3A(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_105B4
		neg.w	d0
		addi.w	#$80,d0

loc_105B4:
		move.w	Off34(a0),d1
		add.w	d0,d1
		move.w	d1,X_pos(a0)
		rts
; ===========================================================================

loc_105C0:
		addq.b	#1,Subtype(a0)
		sf	Off38(a0)
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_105A2
		bset	#0,2(a2,d0.w)
		bra.s	loc_105A2
; ===========================================================================

Obj56_Type0D:				; XREF: Obj56_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_105F8
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	Off3C(a0),d0
		tst.b	(a2,d0.w)
		bpl.s	loc_10606
		move.b	#1,Off38(a0)

loc_105F8:
		move.w	#$80,d0
		cmp.w	Off3A(a0),d0
		beq.s	loc_10624
		addq.w	#2,Off3A(a0)

loc_10606:
		move.w	Off3A(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_10618
		neg.w	d0
		addi.w	#$80,d0

loc_10618:
		move.w	Off34(a0),d1
		add.w	d0,d1
		move.w	d1,X_pos(a0)
		rts
; ===========================================================================

loc_10624:
		subq.b	#1,Subtype(a0)
		sf	Off38(a0)
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_10606
		bclr	#0,2(a2,d0.w)
		bra.s	loc_10606
; ===========================================================================

Obj56_Type08:				; XREF: Obj56_TypeIndex
		move.w	#$10,d1
		moveq	#0,d0
		move.b	($FFFFFE88).w,d0
		lsr.w	#1,d0
		move.w	($FFFFFE8A).w,d3
		bra.s	Obj56_Move_Sqr
; ===========================================================================

Obj56_Type09:				; XREF: Obj56_TypeIndex
		move.w	#$30,d1
		moveq	#0,d0
		move.b	($FFFFFE8C).w,d0
		move.w	($FFFFFE8E).w,d3
		bra.s	Obj56_Move_Sqr
; ===========================================================================

Obj56_Type0A:				; XREF: Obj56_TypeIndex
		move.w	#$50,d1
		moveq	#0,d0
		move.b	($FFFFFE90).w,d0
		move.w	($FFFFFE92).w,d3
		bra.s	Obj56_Move_Sqr
; ===========================================================================

Obj56_Type0B:				; XREF: Obj56_TypeIndex
		move.w	#$70,d1
		moveq	#0,d0
		move.b	($FFFFFE94).w,d0
		move.w	($FFFFFE96).w,d3

Obj56_Move_Sqr:
		tst.w	d3
		bne.s	loc_1068E
		addq.b	#1,Status(a0)
		andi.b	#3,Status(a0)

loc_1068E:
		move.b	Status(a0),d2
		andi.b	#3,d2
		bne.s	loc_106AE
		sub.w	d1,d0
		add.w	Off34(a0),d0
		move.w	d0,X_pos(a0)
		neg.w	d1
		add.w	Off30(a0),d1
		move.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

loc_106AE:
		subq.b	#1,d2
		bne.s	loc_106CC
		subq.w	#1,d1
		sub.w	d1,d0
		neg.w	d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)
		addq.w	#1,d1
		add.w	Off34(a0),d1
		move.w	d1,X_pos(a0)
		rts
; ===========================================================================

loc_106CC:
		subq.b	#1,d2
		bne.s	loc_106EA
		subq.w	#1,d1
		sub.w	d1,d0
		neg.w	d0
		add.w	Off34(a0),d0
		move.w	d0,X_pos(a0)
		addq.w	#1,d1
		add.w	Off30(a0),d1
		move.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

loc_106EA:
		sub.w	d1,d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)
		neg.w	d1
		add.w	Off34(a0),d1
		move.w	d1,X_pos(a0)
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - moving blocks (SYZ/SLZ/LZ)
; ---------------------------------------------------------------------------
Map_obj56:
	include "_maps\obj56.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 57 - spiked balls (SYZ, LZ)
; ---------------------------------------------------------------------------

Obj57:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj57_Index(pc,d0.w),d1
		jmp	Obj57_Index(pc,d1.w)
; ===========================================================================
Obj57_Index:	dc.w Obj57_Main-Obj57_Index
		dc.w Obj57_Move-Obj57_Index
		dc.w Obj57_Display-Obj57_Index
; ===========================================================================

Obj57_Main:				; XREF: Obj57_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj57,Mappings_Offset(a0)
		move.w	#$3BA,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#8,X_Visible(a0)
		move.w	X_pos(a0),Off3A(a0)
		move.w	Y_Pos(a0),Off38(a0)
		move.b	#$98,Coll(a0)	; SYZ specific code (chain hurts Sonic)
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	loc_107E8
		move.b	#0,Coll(a0)	; LZ specific code (chain doesn't hurt)
		move.w	#$310,Art_Tile(a0)
		move.l	#Map_obj57a,Mappings_Offset(a0)

loc_107E8:
		move.b	Subtype(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asl.w	#3,d1		; multiply by 8
		move.w	d1,Off3E(a0)	; set object twirl speed
		move.b	Status(a0),d0
		ror.b	#2,d0
		andi.b	#-$40,d0
		move.b	d0,Angle(a0)
		lea	$29(a0),a2
		move.b	Subtype(a0),d1	; get object type
		andi.w	#7,d1		; read only the	2nd digit
		move.b	#0,(a2)+
		move.w	d1,d3
		lsl.w	#4,d3
		move.b	d3,Off3C(a0)
		subq.w	#1,d1		; set chain length (type-1)
		blo.s	loc_10894
		btst	#3,Subtype(a0)
		beq.s	Obj57_MakeChain
		subq.w	#1,d1
		blo.s	loc_10894

Obj57_MakeChain:
		bsr.w	SingleObjLoad
		bne.s	loc_10894
		addq.b	#1,$29(a0)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#4,Routine(a1)
		move.b	0(a0),0(a1)
		move.l	Mappings_Offset(a0),Mappings_Offset(a1)
		move.w	Art_Tile(a0),Art_Tile(a1)
		move.b	Render_Flags(a0),Render_Flags(a1)
		move.b	Priority(a0),Priority(a1)
		move.b	X_Visible(a0),X_Visible(a1)
		move.b	Coll(a0),Coll(a1)
		subi.b	#$10,d3
		move.b	d3,Off3C(a1)
		cmpi.b	#1,($FFFFFE10).w
		bne.s	loc_10890
		tst.b	d3
		bne.s	loc_10890
		move.b	#2,Anim_Frame(a1)

loc_10890:
		dbf	d1,Obj57_MakeChain ; repeat for	length of chain

loc_10894:
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	Obj57_Move
		move.b	#$8B,Coll(a0)	; if yes, make last spikeball larger
		move.b	#1,Anim_Frame(a0)	; use different	frame

Obj57_Move:				; XREF: Obj57_Index
		bsr.w	Obj57_MoveSub
		bra.w	Obj57_ChkDel
; ===========================================================================

Obj57_MoveSub:				; XREF: Obj57_Move
		move.w	Off3E(a0),d1
		add.w	d1,Angle(a0)
		move.b	Angle(a0),d1
		jsr	(CalcSine).l
		move.w	Off38(a0),d2
		move.w	Off3A(a0),d3
		lea	$29(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

Obj57_MoveLoop:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFD000,d4
		movea.l	d4,a1
		moveq	#0,d4
		move.b	Off3C(a1),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,Y_Pos(a1)
		move.w	d5,X_pos(a1)
		dbf	d6,Obj57_MoveLoop
		rts
; ===========================================================================

Obj57_ChkDel:				; XREF: Obj57_Move
		move.w	Off3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj57_Delete
		bra.w	DisplaySprite
; ===========================================================================

Obj57_Delete:				; XREF: Obj57_ChkDel
		moveq	#0,d2
		lea	$29(a0),a2
		move.b	(a2)+,d2

Obj57_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		bsr.w	DeleteObject2
		dbf	d2,Obj57_DelLoop ; delete all pieces of	chain

		rts
; ===========================================================================

Obj57_Display:				; XREF: Obj57_Index
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - chain of spiked balls (SYZ)
; ---------------------------------------------------------------------------
Map_obj57:
	include "_maps\obj57syz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spiked ball	on a chain (LZ)
; ---------------------------------------------------------------------------
Map_obj57a:
	include "_maps\obj57lz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 58 - giant spiked balls (SYZ)
; ---------------------------------------------------------------------------

Obj58:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj58_Index(pc,d0.w),d1
		jmp	Obj58_Index(pc,d1.w)
; ===========================================================================
Obj58_Index:	dc.w Obj58_Main-Obj58_Index
		dc.w Obj58_Move-Obj58_Index
; ===========================================================================

Obj58_Main:				; XREF: Obj58_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj15b,Mappings_Offset(a0)
		move.w	#$396,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$18,X_Visible(a0)
		move.w	X_pos(a0),Off3A(a0)
		move.w	Y_Pos(a0),Off38(a0)
		move.b	#$86,Coll(a0)
		move.b	Subtype(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asl.w	#3,d1		; multiply by 8
		move.w	d1,Off3E(a0)	; set object speed
		move.b	Status(a0),d0
		ror.b	#2,d0
		andi.b	#$C0,d0
		move.b	d0,Angle(a0)
		move.b	#$50,Off3C(a0)	; set diameter of circle of rotation

Obj58_Move:				; XREF: Obj58_Index
		moveq	#0,d0
		move.b	Subtype(a0),d0	; get object type
		andi.w	#7,d0		; read only the	2nd digit
		add.w	d0,d0
		move.w	Obj58_TypeIndex(pc,d0.w),d1
		jsr	Obj58_TypeIndex(pc,d1.w)
		move.w	Off3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj58_TypeIndex:dc.w Obj58_Type00-Obj58_TypeIndex
		dc.w Obj58_Type01-Obj58_TypeIndex
		dc.w Obj58_Type02-Obj58_TypeIndex
		dc.w Obj58_Type03-Obj58_TypeIndex
; ===========================================================================

Obj58_Type00:				; XREF: Obj58_TypeIndex
		rts
; ===========================================================================

Obj58_Type01:				; XREF: Obj58_TypeIndex
		move.w	#$60,d1
		moveq	#0,d0
		move.b	($FFFFFE6C).w,d0
		btst	#0,Status(a0)
		beq.s	loc_10A38
		neg.w	d0
		add.w	d1,d0

loc_10A38:
		move.w	Off3A(a0),d1
		sub.w	d0,d1
		move.w	d1,X_pos(a0)	; move object horizontally
		rts
; ===========================================================================

Obj58_Type02:				; XREF: Obj58_TypeIndex
		move.w	#$60,d1
		moveq	#0,d0
		move.b	($FFFFFE6C).w,d0
		btst	#0,Status(a0)
		beq.s	loc_10A5C
		neg.w	d0
		addi.w	#$80,d0

loc_10A5C:
		move.w	Off38(a0),d1
		sub.w	d0,d1
		move.w	d1,Y_Pos(a0)	; move object vertically
		rts
; ===========================================================================

Obj58_Type03:				; XREF: Obj58_TypeIndex
		move.w	Off3E(a0),d1
		add.w	d1,Angle(a0)
		move.b	Angle(a0),d1
		jsr	(CalcSine).l
		move.w	Off38(a0),d2
		move.w	Off3A(a0),d3
		moveq	#0,d4
		move.b	Off3C(a0),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,Y_Pos(a0)
		move.w	d5,X_pos(a0)
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - SBZ	spiked ball on a chain
; ---------------------------------------------------------------------------
Map_obj15b:
	include "_maps\obj15sbz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 59 - platforms	that move when you stand on them (SLZ)
; ---------------------------------------------------------------------------

Obj59:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj59_Index(pc,d0.w),d1
		jsr	Obj59_Index(pc,d1.w)
		move.w	Off32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj59_Index:	dc.w Obj59_Main-Obj59_Index
		dc.w Obj59_Platform-Obj59_Index
		dc.w Obj59_Action-Obj59_Index
		dc.w Obj59_MakeMulti-Obj59_Index

Obj59_Var1:	dc.b $28, 0		; width, frame number

Obj59_Var2:	dc.b $10, 1		; width, action	type
		dc.b $20, 1
		dc.b $34, 1
		dc.b $10, 3
		dc.b $20, 3
		dc.b $34, 3
		dc.b $14, 1
		dc.b $24, 1
		dc.b $2C, 1
		dc.b $14, 3
		dc.b $24, 3
		dc.b $2C, 3
		dc.b $20, 5
		dc.b $20, 7
		dc.b $30, 9
; ===========================================================================

Obj59_Main:				; XREF: Obj59_Index
		addq.b	#2,Routine(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		bpl.s	Obj59_Main2
		addq.b	#4,Routine(a0)
		andi.w	#$7F,d0
		mulu.w	#6,d0
		move.w	d0,Off3C(a0)
		move.w	d0,Off3E(a0)
		addq.l	#4,sp
		rts
; ===========================================================================

Obj59_Main2:
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Obj59_Var1(pc,d0.w),a2
		move.b	(a2)+,X_Visible(a0)
		move.b	(a2)+,Anim_Frame(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	Obj59_Var2(pc,d0.w),a2
		move.b	(a2)+,d0
		lsl.w	#2,d0
		move.w	d0,Off3C(a0)
		move.b	(a2)+,Subtype(a0)
		move.l	#Map_obj59,Mappings_Offset(a0)
		move.w	#$4000,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.w	X_pos(a0),Off32(a0)
		move.w	Y_Pos(a0),Off30(a0)

Obj59_Platform:				; XREF: Obj59_Index
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(PlatformObject).l
		bra.w	Obj59_Types
; ===========================================================================

Obj59_Action:				; XREF: Obj59_Index
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(ExitPlatform).l
		move.w	X_pos(a0),-(sp)
		bsr.w	Obj59_Types
		move.w	(sp)+,d2
		tst.b	0(a0)
		beq.s	locret_10BD4
		jmp	(MvSonicOnPtfm2).l
; ===========================================================================

locret_10BD4:
		rts
; ===========================================================================

Obj59_Types:
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj59_TypeIndex(pc,d0.w),d1
		jmp	Obj59_TypeIndex(pc,d1.w)
; ===========================================================================
Obj59_TypeIndex:dc.w Obj59_Type00-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type02-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type04-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type06-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type08-Obj59_TypeIndex, Obj59_Type09-Obj59_TypeIndex
; ===========================================================================

Obj59_Type00:				; XREF: Obj59_TypeIndex
		rts
; ===========================================================================

Obj59_Type01:				; XREF: Obj59_TypeIndex
		cmpi.b	#4,Routine(a0)	; check	if Sonic is standing on	the object
		bne.s	locret_10C0C
		addq.b	#1,Subtype(a0)	; if yes, add 1	to type

locret_10C0C:
		rts
; ===========================================================================

Obj59_Type02:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	Off34(a0),d0
		neg.w	d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)
		rts
; ===========================================================================

Obj59_Type04:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	Off34(a0),d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)
		rts
; ===========================================================================

Obj59_Type06:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	Off34(a0),d0
		asr.w	#1,d0
		neg.w	d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)
		move.w	Off34(a0),d0
		add.w	Off32(a0),d0
		move.w	d0,X_pos(a0)
		rts
; ===========================================================================

Obj59_Type08:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	Off34(a0),d0
		asr.w	#1,d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)
		move.w	Off34(a0),d0
		neg.w	d0
		add.w	Off32(a0),d0
		move.w	d0,X_pos(a0)
		rts
; ===========================================================================

Obj59_Type09:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	Off34(a0),d0
		neg.w	d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)
		tst.b	Subtype(a0)
		beq.w	loc_10C94
		rts
; ===========================================================================

loc_10C94:
		btst	#3,Status(a0)
		beq.s	Obj59_Delete
		bset	#1,Status(a1)
		bclr	#3,Status(a1)
		move.b	#2,Routine(a1)

Obj59_Delete:
		bra.w	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj59_Move:				; XREF: Obj59_Type02; et al
		move.w	Off38(a0),d0
		tst.b	Off3A(a0)
		bne.s	loc_10CC8
		cmpi.w	#$800,d0
		bhs.s	loc_10CD0
		addi.w	#$10,d0
		bra.s	loc_10CD0
; ===========================================================================

loc_10CC8:
		tst.w	d0
		beq.s	loc_10CD0
		subi.w	#$10,d0

loc_10CD0:
		move.w	d0,Off38(a0)
		ext.l	d0
		asl.l	#8,d0
		add.l	Off34(a0),d0
		move.l	d0,Off34(a0)
		swap	d0
		move.w	Off3C(a0),d2
		cmp.w	d2,d0
		bls.s	loc_10CF0
		move.b	#1,Off3A(a0)

loc_10CF0:
		add.w	d2,d2
		cmp.w	d2,d0
		bne.s	locret_10CFA
		sf	Subtype(a0)

locret_10CFA:
		rts
; End of function Obj59_Move

; ===========================================================================

Obj59_MakeMulti:			; XREF: Obj59_Index
		subq.w	#1,Off3C(a0)
		bne.s	Obj59_ChkDel
		move.w	Off3E(a0),Off3C(a0)
		bsr.w	SingleObjLoad
		bne.s	Obj59_ChkDel
		move.b	#$59,0(a1)	; duplicate the	object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	#$E,Subtype(a1)

Obj59_ChkDel:
		addq.l	#4,sp
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - platforms that move	when you stand on them (SLZ)
; ---------------------------------------------------------------------------
Map_obj59:
	include "_maps\obj59.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5A - platforms	moving in circles (SLZ)
; ---------------------------------------------------------------------------

Obj5A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj5A_Index(pc,d0.w),d1
		jsr	Obj5A_Index(pc,d1.w)
		move.w	Off32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj5A_Index:	dc.w Obj5A_Main-Obj5A_Index
		dc.w Obj5A_Platform-Obj5A_Index
		dc.w Obj5A_Action-Obj5A_Index
; ===========================================================================

Obj5A_Main:				; XREF: Obj5A_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj5A,Mappings_Offset(a0)
		move.w	#$4000,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$18,X_Visible(a0)
		move.w	X_pos(a0),Off32(a0)
		move.w	Y_Pos(a0),Off30(a0)

Obj5A_Platform:				; XREF: Obj5A_Index
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(PlatformObject).l
		bra.w	Obj5A_Types
; ===========================================================================

Obj5A_Action:				; XREF: Obj5A_Index
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(ExitPlatform).l
		move.w	X_pos(a0),-(sp)
		bsr.w	Obj5A_Types
		move.w	(sp)+,d2
		jmp	(MvSonicOnPtfm2).l
; ===========================================================================

Obj5A_Types:
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#$C,d0
		lsr.w	#1,d0
		move.w	Obj5A_TypeIndex(pc,d0.w),d1
		jmp	Obj5A_TypeIndex(pc,d1.w)
; ===========================================================================
Obj5A_TypeIndex:dc.w Obj5A_Type00-Obj5A_TypeIndex
		dc.w Obj5A_Type04-Obj5A_TypeIndex
; ===========================================================================

Obj5A_Type00:				; XREF: Obj5A_TypeIndex
		move.b	($FFFFFE80).w,d1
		subi.b	#$50,d1
		ext.w	d1
		move.b	($FFFFFE84).w,d2
		subi.b	#$50,d2
		ext.w	d2
		btst	#0,Subtype(a0)
		beq.s	loc_10E24
		neg.w	d1
		neg.w	d2

loc_10E24:
		btst	#1,Subtype(a0)
		beq.s	loc_10E30
		neg.w	d1
		exg	d1,d2

loc_10E30:
		add.w	Off32(a0),d1
		move.w	d1,X_pos(a0)
		add.w	Off30(a0),d2
		move.w	d2,Y_Pos(a0)
		rts
; ===========================================================================

Obj5A_Type04:				; XREF: Obj5A_TypeIndex
		move.b	($FFFFFE80).w,d1
		subi.b	#$50,d1
		ext.w	d1
		move.b	($FFFFFE84).w,d2
		subi.b	#$50,d2
		ext.w	d2
		btst	#0,Subtype(a0)
		beq.s	loc_10E62
		neg.w	d1
		neg.w	d2

loc_10E62:
		btst	#1,Subtype(a0)
		beq.s	loc_10E6E
		neg.w	d1
		exg	d1,d2

loc_10E6E:
		neg.w	d1
		add.w	Off32(a0),d1
		move.w	d1,X_pos(a0)
		add.w	Off30(a0),d2
		move.w	d2,Y_Pos(a0)
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - platforms that move	in circles (SLZ)
; ---------------------------------------------------------------------------
Map_obj5A:
	include "_maps\obj5A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5B - blocks that form a staircase (SLZ)
; ---------------------------------------------------------------------------

Obj5B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj5B_Index(pc,d0.w),d1
		jsr	Obj5B_Index(pc,d1.w)
		move.w	Off30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj5B_Index:	dc.w Obj5B_Main-Obj5B_Index
		dc.w Obj5B_Move-Obj5B_Index
		dc.w Obj5B_Solid-Obj5B_Index
; ===========================================================================

Obj5B_Main:				; XREF: Obj5B_Index
		addq.b	#2,Routine(a0)
		moveq	#$38,d3
		moveq	#1,d4
		btst	#0,Status(a0)
		beq.s	loc_10EDA
		moveq	#$3B,d3
		moveq	#-1,d4

loc_10EDA:
		move.w	X_pos(a0),d2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj5B_MakeBlocks
; ===========================================================================

Obj5B_Loop:
		bsr.w	SingleObjLoad2
		bne.w	Obj5B_Move
		move.b	#4,Routine(a1)

Obj5B_MakeBlocks:			; XREF: Obj5B_Main
		move.b	#$5B,0(a1)	; load another block object
		move.l	#Map_obj5B,Mappings_Offset(a1)
		move.w	#$4000,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#3,Priority(a1)
		move.b	#$10,X_Visible(a1)
		move.b	Subtype(a0),Subtype(a1)
		move.w	d2,X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.w	X_pos(a0),Off30(a1)
		move.w	Y_Pos(a1),Off32(a1)
		addi.w	#$20,d2
		move.b	d3,Off37(a1)
		move.l	a0,Off3C(a1)
		add.b	d4,d3
		dbf	d1,Obj5B_Loop	; repeat sequence 3 times

Obj5B_Move:				; XREF: Obj5B_Index
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj5B_TypeIndex(pc,d0.w),d1
		jsr	Obj5B_TypeIndex(pc,d1.w)

Obj5B_Solid:				; XREF: Obj5B_Index
		movea.l	Off3C(a0),a2
		moveq	#0,d0
		move.b	Off37(a0),d0
		move.b	(a2,d0.w),d0
		add.w	Off32(a0),d0
		move.w	d0,Y_Pos(a0)
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject
		tst.b	d4
		bpl.s	loc_10F92
		move.b	d4,Off36(a2)

loc_10F92:
		btst	#3,Status(a0)
		beq.s	locret_10FA0
		move.b	#1,Off36(a2)

locret_10FA0:
		rts
; ===========================================================================
Obj5B_TypeIndex:dc.w Obj5B_Type00-Obj5B_TypeIndex
		dc.w Obj5B_Type01-Obj5B_TypeIndex
		dc.w Obj5B_Type02-Obj5B_TypeIndex
		dc.w Obj5B_Type01-Obj5B_TypeIndex
; ===========================================================================

Obj5B_Type00:				; XREF: Obj5B_TypeIndex
		tst.w	Off34(a0)
		bne.s	loc_10FC0
		cmpi.b	#1,Off36(a0)
		bne.s	locret_10FBE
		move.w	#$1E,Off34(a0)

locret_10FBE:
		rts
; ===========================================================================

loc_10FC0:
		subq.w	#1,Off34(a0)
		bne.s	locret_10FBE
		addq.b	#1,Subtype(a0)	; add 1	to type
		rts
; ===========================================================================

Obj5B_Type02:				; XREF: Obj5B_TypeIndex
		tst.w	Off34(a0)
		bne.s	loc_10FE0
		tst.b	Off36(a0)
		bpl.s	locret_10FDE
		move.w	#$3C,Off34(a0)

locret_10FDE:
		rts
; ===========================================================================

loc_10FE0:
		subq.w	#1,Off34(a0)
		bne.s	loc_10FEC
		addq.b	#1,Subtype(a0)	; add 1	to type
		rts
; ===========================================================================

loc_10FEC:
		lea	Off38(a0),a1
		move.w	Off34(a0),d0
		lsr.b	#2,d0
		andi.b	#1,d0
		move.b	d0,(a1)+
		eori.b	#1,d0
		move.b	d0,(a1)+
		eori.b	#1,d0
		move.b	d0,(a1)+
		eori.b	#1,d0
		move.b	d0,(a1)+
		rts
; ===========================================================================

Obj5B_Type01:				; XREF: Obj5B_TypeIndex
		lea	Off38(a0),a1
		cmpi.b	#$80,(a1)
		beq.s	locret_11038
		addq.b	#1,(a1)
		moveq	#0,d1
		move.b	(a1)+,d1
		swap	d1
		lsr.l	#1,d1
		move.l	d1,d2
		lsr.l	#1,d1
		move.l	d1,d3
		add.l	d2,d3
		swap	d1
		swap	d2
		swap	d3
		move.b	d3,(a1)+
		move.b	d2,(a1)+
		move.b	d1,(a1)+

locret_11038:
		rts
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - blocks that	form a staircase (SLZ)
; ---------------------------------------------------------------------------
Map_obj5B:
	include "_maps\obj5B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5C - metal girders in foreground (SLZ)
; ---------------------------------------------------------------------------

Obj5C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj5C_Index(pc,d0.w),d1
		jmp	Obj5C_Index(pc,d1.w)
; ===========================================================================
Obj5C_Index:	dc.w Obj5C_Main-Obj5C_Index
		dc.w Obj5C_Display-Obj5C_Index
; ===========================================================================

Obj5C_Main:				; XREF: Obj5C_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj5C,Mappings_Offset(a0)
		move.w	#$83CC,Art_Tile(a0)
		move.b	#$10,X_Visible(a0)

Obj5C_Display:				; XREF: Obj5C_Index
		move.l	($FFFFF700).w,d1
		add.l	d1,d1
		swap	d1
		neg.w	d1
		move.w	d1,X_pos(a0)
		move.l	($FFFFF704).w,d1
		add.l	d1,d1
		swap	d1
		andi.w	#$3F,d1
		neg.w	d1
		addi.w	#$100,d1
		move.w	d1,X_Pos2(a0)
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - metal girders in foreground	(SLZ)
; ---------------------------------------------------------------------------
Map_obj5C:
	include "_maps\obj5C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1B - water surface (LZ)
; ---------------------------------------------------------------------------

Obj1B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj1B_Index(pc,d0.w),d1
		jmp	Obj1B_Index(pc,d1.w)
; ===========================================================================
Obj1B_Index:	dc.w Obj1B_Main-Obj1B_Index
		dc.w Obj1B_Action-Obj1B_Index
; ===========================================================================

Obj1B_Main:				; XREF: Obj1B_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj1B,Mappings_Offset(a0)
		move.w	#$C300,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#$80,X_Visible(a0)
		move.w	X_pos(a0),Off30(a0)

Obj1B_Action:				; XREF: Obj1B_Index
		move.w	($FFFFF700).w,d1
		andi.w	#$FFE0,d1
		add.w	Off30(a0),d1
		btst	#0,($FFFFFE05).w
		beq.s	loc_11114
		addi.w	#$20,d1

loc_11114:
		move.w	d1,X_pos(a0)	; match	obj x-position to screen position
		move.w	($FFFFF646).w,d1
		move.w	d1,Y_Pos(a0)	; match	obj y-position to water	height
		tst.b	Off32(a0)
		bne.s	Obj1B_Animate
		btst	#7,($FFFFF605).w ; is Start button pressed?
		beq.s	loc_1114A	; if not, branch
		addq.b	#3,Anim_Frame(a0)	; use different	frames
		move.b	#1,Off32(a0)	; stop animation
		bra.s	Obj1B_Display
; ===========================================================================

Obj1B_Animate:				; XREF: loc_11114
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.s	Obj1B_Display	; if yes, branch
		move.b	#0,Off32(a0)	; resume animation
		subq.b	#3,Anim_Frame(a0)	; use normal frames

loc_1114A:				; XREF: loc_11114
		subq.b	#1,Anim_Dur(a0)
		bpl.s	Obj1B_Display
		move.b	#7,Anim_Dur(a0)
		addq.b	#1,Anim_Frame(a0)
		cmpi.b	#3,Anim_Frame(a0)
		blo.s	Obj1B_Display
		move.b	#0,Anim_Frame(a0)

Obj1B_Display:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - water surface (LZ)
; ---------------------------------------------------------------------------
Map_obj1B:
	include "_maps\obj1B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0B - pole that	breaks (LZ)
; ---------------------------------------------------------------------------

Obj0B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj0B_Index(pc,d0.w),d1
		jmp	Obj0B_Index(pc,d1.w)
; ===========================================================================
Obj0B_Index:	dc.w Obj0B_Main-Obj0B_Index
		dc.w Obj0B_Action-Obj0B_Index
		dc.w Obj0B_Display-Obj0B_Index
; ===========================================================================

Obj0B_Main:				; XREF: Obj0B_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj0B,Mappings_Offset(a0)
		move.w	#$43DE,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#8,X_Visible(a0)
		move.b	#4,Priority(a0)
		move.b	#$E1,Coll(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; get object type
		mulu.w	#60,d0		; multiply by 60 (1 second)
		move.w	d0,Off30(a0)	; set breakage time

Obj0B_Action:				; XREF: Obj0B_Index
		tst.b	Off32(a0)
		beq.s	Obj0B_Grab
		tst.w	Off30(a0)
		beq.s	Obj0B_MoveUp
		subq.w	#1,Off30(a0)
		bne.s	Obj0B_MoveUp
		move.b	#1,Anim_Frame(a0)	; break	the pole
		bra.s	Obj0B_Release
; ===========================================================================

Obj0B_MoveUp:				; XREF: Obj0B_Action
		lea	Object_RAM,a1
		move.w	Y_Pos(a0),d0
		subi.w	#$18,d0
		btst	#0,($FFFFF604).w ; check if "up" is pressed
		beq.s	Obj0B_MoveDown
		subq.w	#1,Y_Pos(a1)	; move Sonic up
		cmp.w	Y_Pos(a1),d0
		blo.s	Obj0B_MoveDown
		move.w	d0,Y_Pos(a1)

Obj0B_MoveDown:
		addi.w	#$24,d0
		btst	#1,($FFFFF604).w ; check if "down" is pressed
		beq.s	Obj0B_LetGo
		addq.w	#1,Y_Pos(a1)	; move Sonic down
		cmp.w	Y_Pos(a1),d0
		bhs.s	Obj0B_LetGo
		move.w	d0,Y_Pos(a1)

Obj0B_LetGo:
		move.b	($FFFFF603).w,d0
		andi.w	#JumpBtns,d0
		beq.s	Obj0B_Display

Obj0B_Release:				; XREF: Obj0B_Action
		sf	Coll(a0)
		addq.b	#2,Routine(a0)
		sf	($FFFFF7C8).w
		sf	($FFFFF7C9).w
		sf	Off32(a0)
		bra.s	Obj0B_Display
; ===========================================================================

Obj0B_Grab:				; XREF: Obj0B_Action
		tst.b	Coll2(a0)		; has Sonic touched the	pole?
		beq.s	Obj0B_Display	; if not, branch
		lea	Object_RAM,a1
		move.w	X_pos(a0),d0
		addi.w	#$14,d0
		cmp.w	X_pos(a1),d0
		bhs.s	Obj0B_Display
		sf	Coll2(a0)
		cmpi.b	#4,Routine(a1)
		bhs.s	Obj0B_Display
		clr.w	X_Vel(a1)		; stop Sonic moving
		clr.w	Y_Vel(a1)		; stop Sonic moving
		move.w	X_pos(a0),d0
		addi.w	#$14,d0
		move.w	d0,X_pos(a1)
		bclr	#0,Status(a1)
		move.b	#$11,Anim(a1)	; set Sonic's animation to "hanging" ($11)
		move.b	#1,($FFFFF7C8).w ; lock	controls
		move.b	#1,($FFFFF7C9).w ; disable wind	tunnel
		move.b	#1,Off32(a0)	; begin	countdown to breakage

Obj0B_Display:				; XREF: Obj0B_Index
		bra.w	MarkObjGone
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - pole that breaks (LZ)
; ---------------------------------------------------------------------------
Map_obj0B:
	include "_maps\obj0B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0C - flapping door (LZ)
; ---------------------------------------------------------------------------

Obj0C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj0C_Index(pc,d0.w),d1
		jmp	Obj0C_Index(pc,d1.w)
; ===========================================================================
Obj0C_Index:	dc.w Obj0C_Main-Obj0C_Index
		dc.w Obj0C_OpenClose-Obj0C_Index
; ===========================================================================

Obj0C_Main:				; XREF: Obj0C_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj0C,Mappings_Offset(a0)
		move.w	#$4328,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$28,X_Visible(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; get object type
		mulu.w	#60,d0		; multiply by 60 (1 second)
		move.w	d0,Off32(a0)	; set flap delay time

Obj0C_OpenClose:			; XREF: Obj0C_Index
		subq.w	#1,Off30(a0)	; subtract 1 from time delay
		bpl.s	Obj0C_Solid	; if time remains, branch
		move.w	Off32(a0),Off30(a0)	; reset	time delay
		bchg	#0,Anim(a0)	; open/close door
		tst.b	Render_Flags(a0)
		bpl.s	Obj0C_Solid
		move.w	#$BB,d0
		jsr	(PlaySound).l ;	play door sound

Obj0C_Solid:
		lea	(Ani_obj0C).l,a1
		bsr.w	AnimateSprite
		sf	($FFFFF7C9).w	; enable wind tunnel
		tst.b	Anim_Frame(a0)		; is the door open?
		bne.s	Obj0C_Display	; if yes, branch
		move.w	Object_RAM+X_Pos,d0
		cmp.w	X_pos(a0),d0	; is Sonic in front of the door?
		bhs.s	Obj0C_Display	; if yes, branch
		move.b	#1,($FFFFF7C9).w ; disable wind	tunnel
		move.w	#$13,d1
		move.w	#$20,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject	; make the door	solid

Obj0C_Display:
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj0C:
	include "_anim\obj0C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - flapping door (LZ)
; ---------------------------------------------------------------------------
Map_obj0C:
	include "_maps\obj0C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 71 - invisible	solid blocks
; ---------------------------------------------------------------------------

Obj71:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj71_Index(pc,d0.w),d1
		jmp	Obj71_Index(pc,d1.w)
; ===========================================================================
Obj71_Index:	dc.w Obj71_Main-Obj71_Index
		dc.w Obj71_Solid-Obj71_Index
; ===========================================================================

Obj71_Main:				; XREF: Obj71_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj71,Mappings_Offset(a0)
		move.w	#$8680,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	Subtype(a0),d0	; get object type
		move.b	d0,d1
		andi.w	#$F0,d0		; read only the	1st byte
		addi.w	#$10,d0
		lsr.w	#1,d0
		move.b	d0,X_Visible(a0)	; set object width
		andi.w	#$F,d1		; read only the	2nd byte
		addq.w	#1,d1
		lsl.w	#3,d1
		move.b	d1,Y_Radius(a0)	; set object height

Obj71_Solid:				; XREF: Obj71_Index
		bsr.w	ChkObjOnScreen
		bne.s	Obj71_ChkDel
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	Y_Radius(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	X_pos(a0),d4
		bsr.w	SolidObject71
		beq.s	Obj71_ChkDel
		bset	#7,Object_RAM+Status.w

Obj71_ChkDel:
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj71_Delete
		tst.b	$FFFFFE08.w	; are you using	debug mode?
		beq.s	Obj71_NoDisplay	; if not, branch
		jmp	DisplaySprite	; if yes, display the object
; ===========================================================================

Obj71_NoDisplay:
		rts
; ===========================================================================

Obj71_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - invisible solid blocks
; ---------------------------------------------------------------------------
Map_obj71:
	include "_maps\obj71.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5D - fans (SLZ)
; ---------------------------------------------------------------------------

Obj5D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj5D_Index(pc,d0.w),d1
		jmp	Obj5D_Index(pc,d1.w)
; ===========================================================================
Obj5D_Index:	dc.w Obj5D_Main-Obj5D_Index
		dc.w Obj5D_Delay-Obj5D_Index
; ===========================================================================

Obj5D_Main:				; XREF: Obj5D_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj5D,Mappings_Offset(a0)
		move.w	#$43A0,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#4,Priority(a0)

Obj5D_Delay:				; XREF: Obj5D_Index
		btst	#1,Subtype(a0)	; is object type 02/03?
		bne.s	Obj5D_Blow	; if yes, branch
		subq.w	#1,Off30(a0)	; subtract 1 from time delay
		bpl.s	Obj5D_Blow	; if time remains, branch
		move.w	#120,Off30(a0)	; set delay to 2 seconds
		bchg	#0,Off32(a0)	; switch fan on/off
		beq.s	Obj5D_Blow	; if fan is off, branch
		move.w	#180,Off30(a0)	; set delay to 3 seconds

Obj5D_Blow:
		tst.b	Off32(a0)		; is fan switched on?
		bne.w	Obj5D_ChkDel	; if not, branch
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		btst	#0,Status(a0)
		bne.s	Obj5D_ChkSonic
		neg.w	d0

Obj5D_ChkSonic:
		addi.w	#$50,d0
		cmpi.w	#$F0,d0		; is Sonic more	than $A0 pixels	from the fan?
		bhs.s	Obj5D_Animate	; if yes, branch
		move.w	Y_Pos(a1),d1
		addi.w	#$60,d1
		sub.w	Y_Pos(a0),d1
		blo.s	Obj5D_Animate
		cmpi.w	#$70,d1
		bhs.s	Obj5D_Animate
		subi.w	#$50,d0
		bhs.s	loc_1159A
		not.w	d0
		add.w	d0,d0

loc_1159A:
		addi.w	#$60,d0
		btst	#0,Status(a0)
		bne.s	loc_115A8
		neg.w	d0

loc_115A8:
		neg.b	d0
		asr.w	#4,d0
		btst	#0,Subtype(a0)
		beq.s	Obj5D_MoveSonic
		neg.w	d0

Obj5D_MoveSonic:
		add.w	d0,X_pos(a1)	; push Sonic away from the fan

Obj5D_Animate:				; XREF: Obj5D_ChkSonic
		subq.b	#1,Anim_Dur(a0)
		bpl.s	Obj5D_ChkDel
		move.b	#0,Anim_Dur(a0)
		addq.b	#1,Anim_scriptNum(a0)
		cmpi.b	#3,Anim_scriptNum(a0)
		blo.s	loc_115D8
		move.b	#0,Anim_scriptNum(a0)

loc_115D8:
		moveq	#0,d0
		btst	#0,Subtype(a0)
		beq.s	loc_115E4
		moveq	#2,d0

loc_115E4:
		add.b	Anim_scriptNum(a0),d0
		move.b	d0,Anim_Frame(a0)

Obj5D_ChkDel:				; XREF: Obj5D_Animate
		bsr.w	DisplaySprite
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - fans (SLZ)
; ---------------------------------------------------------------------------
Map_obj5D:
	include "_maps\obj5D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5E - seesaws (SLZ)
; ---------------------------------------------------------------------------

Obj5E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj5E_Index(pc,d0.w),d1
		jsr	Obj5E_Index(pc,d1.w)
		move.w	Off30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		bmi.w	DeleteObject
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj5E_Index:	dc.w Obj5E_Main-Obj5E_Index
		dc.w Obj5E_Slope-Obj5E_Index
		dc.w Obj5E_Slope2-Obj5E_Index
		dc.w Obj5E_Spikeball-Obj5E_Index
		dc.w Obj5E_MoveSpike-Obj5E_Index
		dc.w Obj5E_SpikeFall-Obj5E_Index
; ===========================================================================

Obj5E_Main:				; XREF: Obj5E_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj5E,Mappings_Offset(a0)
		move.w	#$374,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$30,X_Visible(a0)
		move.w	X_pos(a0),Off30(a0)
		tst.b	Subtype(a0)		; is object type 00 ?
		bne.s	loc_116D2	; if not, branch
		bsr.w	SingleObjLoad2
		bne.s	loc_116D2
		move.b	#$5E,0(a1)	; load spikeball object
		addq.b	#6,Routine(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	Status(a0),Status(a1)
		move.l	a0,Off3C(a1)

loc_116D2:
		btst	#0,Status(a0)
		beq.s	loc_116E0
		move.b	#2,Anim_Frame(a0)

loc_116E0:
		move.b	Anim_Frame(a0),Off3A(a0)

Obj5E_Slope:				; XREF: Obj5E_Index
		move.b	Off3A(a0),d1
		bsr.w	loc_11766
		lea	(Obj5E_Data1).l,a2
		btst	#0,Anim_Frame(a0)
		beq.s	loc_11702
		lea	(Obj5E_Data2).l,a2

loc_11702:
		lea	Object_RAM,a1
		move.w	Y_Vel(a1),Off38(a0)
		move.w	#$30,d1
		jsr	(SlopeObject).l
		rts
; ===========================================================================

Obj5E_Slope2:				; XREF: Obj5E_Index
		bsr.w	loc_1174A
		lea	(Obj5E_Data1).l,a2
		btst	#0,Anim_Frame(a0)
		beq.s	loc_11730
		lea	(Obj5E_Data2).l,a2

loc_11730:
		move.w	#$30,d1
		jsr	(ExitPlatform).l
		move.w	#$30,d1
		move.w	X_pos(a0),d2
		jsr	SlopeObject2
		rts
; ===========================================================================

loc_1174A:				; XREF: Obj5E_Slope2
		moveq	#2,d1
		lea	Object_RAM,a1
		move.w	X_pos(a0),d0
		sub.w	X_pos(a1),d0
		bhs.s	loc_1175E
		neg.w	d0
		moveq	#0,d1

loc_1175E:
		cmpi.w	#8,d0
		bhs.s	loc_11766
		moveq	#1,d1

loc_11766:
		move.b	Anim_Frame(a0),d0
		cmp.b	d1,d0
		beq.s	locret_11790
		bhs.s	loc_11772
		addq.b	#2,d0

loc_11772:
		subq.b	#1,d0
		move.b	d0,Anim_Frame(a0)
		move.b	d1,Off3A(a0)
		bclr	#0,Render_Flags(a0)
		btst	#1,Anim_Frame(a0)
		beq.s	locret_11790
		bset	#0,Render_Flags(a0)

locret_11790:
		rts
; ===========================================================================

Obj5E_Spikeball:			; XREF: Obj5E_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj5Ea,Mappings_Offset(a0)
		move.w	#$4F0,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$8B,Coll(a0)
		move.b	#$C,X_Visible(a0)
		move.w	X_pos(a0),Off30(a0)
		addi.w	#$28,X_pos(a0)
		move.w	Y_Pos(a0),Off34(a0)
		move.b	#1,Anim_Frame(a0)
		btst	#0,Status(a0)
		beq.s	Obj5E_MoveSpike
		subi.w	#$50,X_pos(a0)
		move.b	#2,Off3A(a0)

Obj5E_MoveSpike:			; XREF: Obj5E_Index
		movea.l	Off3C(a0),a1
		moveq	#0,d0
		move.b	Off3A(a0),d0
		sub.b	Off3A(a1),d0
		beq.s	loc_1183E
		bhs.s	loc_117FC
		neg.b	d0

loc_117FC:
		move.w	#-$818,d1
		move.w	#-$114,d2
		cmpi.b	#1,d0
		beq.s	loc_11822
		move.w	#-$AF0,d1
		move.w	#-$CC,d2
		cmpi.w	#$A00,Off38(a1)
		blt.s	loc_11822
		move.w	#-$E00,d1
		move.w	#-$A0,d2

loc_11822:
		move.w	d1,Y_Vel(a0)
		move.w	d2,X_Vel(a0)
		move.w	X_pos(a0),d0
		sub.w	Off30(a0),d0
		bhs.s	loc_11838
		neg.w	X_Vel(a0)

loc_11838:
		addq.b	#2,Routine(a0)
		bra.s	Obj5E_SpikeFall
; ===========================================================================

loc_1183E:				; XREF: Obj5E_MoveSpike
		lea	(Obj5E_Speeds).l,a2
		moveq	#0,d0
		move.b	Anim_Frame(a1),d0
		move.w	#$28,d2
		move.w	X_pos(a0),d1
		sub.w	Off30(a0),d1
		bhs.s	loc_1185C
		neg.w	d2
		addq.w	#2,d0

loc_1185C:
		add.w	d0,d0
		move.w	Off34(a0),d1
		add.w	(a2,d0.w),d1
		move.w	d1,Y_Pos(a0)
		add.w	Off30(a0),d2
		move.w	d2,X_pos(a0)
		clr.w	Y_Pos2(a0)
		clr.w	X_Pos2(a0)
		rts
; ===========================================================================

Obj5E_SpikeFall:			; XREF: Obj5E_Index
		tst.w	Y_Vel(a0)
		bpl.s	loc_1189A
		bsr.w	ObjectFall
		move.w	Off34(a0),d0
		subi.w	#$2F,d0
		cmp.w	Y_Pos(a0),d0
		bgt.s	locret_11898
		bsr.w	ObjectFall

locret_11898:
		rts
; ===========================================================================

loc_1189A:				; XREF: Obj5E_SpikeFall
		bsr.w	ObjectFall
		movea.l	Off3C(a0),a1
		lea	(Obj5E_Speeds).l,a2
		moveq	#0,d0
		move.b	Anim_Frame(a1),d0
		move.w	X_pos(a0),d1
		sub.w	Off30(a0),d1
		bhs.s	loc_118BA
		addq.w	#2,d0

loc_118BA:
		add.w	d0,d0
		move.w	Off34(a0),d1
		add.w	(a2,d0.w),d1
		cmp.w	Y_Pos(a0),d1
		bgt	locret_11938
		movea.l	Off3C(a0),a1
		moveq	#2,d1
		tst.w	X_Vel(a0)
		bmi.s	Obj5E_Spring
		moveq	#0,d1

Obj5E_Spring:
		move.b	d1,Off3A(a1)
		move.b	d1,Off3A(a0)
		cmp.b	Anim_Frame(a1),d1
		beq	loc_1192C
		bclr	#3,Status(a1)
		beq.s	loc_1192C
		sf	Routine2(a1)
		move.b	#2,Routine(a1)
		lea	Object_RAM,a2
		move.w	Y_Vel(a0),Y_Vel(a2)
		neg.w	Y_Vel(a2)
		bset	#1,Status(a2)
		bclr	#3,Status(a2)
		sf	Off3C(a2)
		move.b	#$10,Anim(a2)	; change Sonic's animation to "spring" ($10)
		clr.l	If_Spindash
		move.b	#0,SpinDust_RAM+Anim	; clear Spin Dash dust animation
		sf	PeelOut_Flag
		move.b	#2,Routine(a2)
		move.w	#$CC,d0
		jsr	(PlaySound).l ;	play spring sound

loc_1192C:
		clr.w	X_Vel(a0)
		clr.w	Y_Vel(a0)
		subq.b	#2,Routine(a0)

locret_11938:
		rts
; ===========================================================================
Obj5E_Speeds:	dc.w $FFF8, $FFE4, $FFD1, $FFE4, $FFF8

Obj5E_Data1:	incbin	misc\slzssaw1.bin
		even
Obj5E_Data2:	incbin	misc\slzssaw2.bin
		even
; ---------------------------------------------------------------------------
; Sprite mappings - seesaws (SLZ)
; ---------------------------------------------------------------------------
Map_obj5E:
	include "_maps\obj5E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spiked balls on the	seesaws	(SLZ)
; ---------------------------------------------------------------------------
Map_obj5Ea:
	include "_maps\obj5Eballs.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5F - walking bomb enemy (SLZ, SBZ)
; ---------------------------------------------------------------------------

Obj5F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj5F_Index(pc,d0.w),d1
		jmp	Obj5F_Index(pc,d1.w)
; ===========================================================================
Obj5F_Index:	dc.w Obj5F_Main-Obj5F_Index
		dc.w Obj5F_Action-Obj5F_Index
		dc.w Obj5F_Display-Obj5F_Index
		dc.w Obj5F_End-Obj5F_Index
; ===========================================================================

Obj5F_Main:				; XREF: Obj5F_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj5F,Mappings_Offset(a0)
		move.w	#$400,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#$C,X_Visible(a0)
		move.b	Subtype(a0),d0
		beq.s	loc_11A3C
		move.b	d0,Routine(a0)
		rts
; ===========================================================================

loc_11A3C:
		move.b	#$9A,Coll(a0)
		bchg	#0,Status(a0)

Obj5F_Action:				; XREF: Obj5F_Index
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj5F_Index2(pc,d0.w),d1
		jsr	Obj5F_Index2(pc,d1.w)
		lea	(Ani_obj5F).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj5F_Index2:	dc.w Obj5F_Walk-Obj5F_Index2
		dc.w Obj5F_Wait-Obj5F_Index2
		dc.w Obj5F_Explode-Obj5F_Index2
; ===========================================================================

Obj5F_Walk:				; XREF: Obj5F_Index2
		bsr.w	Obj5F_ChkSonic
		subq.w	#1,Off30(a0)	; subtract 1 from time delay
		bpl.s	locret_11A96	; if time remains, branch
		addq.b	#2,Routine2(a0)
		move.w	#1535,Off30(a0)	; set time delay to 25 seconds
		move.w	#$10,X_Vel(a0)
		move.b	#1,Anim(a0)
		bchg	#0,Status(a0)
		beq.s	locret_11A96
		neg.w	X_Vel(a0)		; change direction

locret_11A96:
		rts
; ===========================================================================

Obj5F_Wait:				; XREF: Obj5F_Index2
		bsr.w	Obj5F_ChkSonic
		subq.w	#1,Off30(a0)	; subtract 1 from time delay
		bmi.s	loc_11AA8
		bsr.w	ObjectMove
		rts
; ===========================================================================

loc_11AA8:
		subq.b	#2,Routine2(a0)
		move.w	#179,Off30(a0)	; set time delay to 3 seconds
		clr.w	X_Vel(a0)		; stop walking
		move.b	#0,Anim(a0)	; stop animation
		rts
; ===========================================================================

Obj5F_Explode:				; XREF: Obj5F_Index2
		subq.w	#1,Off30(a0)
		bpl.s	locret_11AD0
		move.b	#$3F,(a0)	; change bomb into an explosion
		move.w	#0,Art_Tile(a0)
		move.b	#0,Routine(a0)
		addq.l	#4,sp

locret_11AD0:
		rts
; ===========================================================================

Obj5F_ChkSonic:				; XREF: Obj5F_Walk; Obj5F_Wait
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	loc_11ADE
		neg.w	d0

loc_11ADE:
		cmpi.w	#$60,d0
		bhs.s	locret_11B5E
		move.w	Object_RAM+Y_Pos,d0
		sub.w	Y_Pos(a0),d0
		bhs.s	Obj5F_MakeFuse
		neg.w	d0

Obj5F_MakeFuse:
		cmpi.w	#$60,d0
		bhs.s	locret_11B5E
		tst.b	$FFFFFE08.w
		bne.s	locret_11B5E
		move.b	#4,Routine2(a0)
		move.w	#143,Off30(a0)	; set fuse time
		clr.w	X_Vel(a0)
		move.b	#2,Anim(a0)
		bsr.w	SingleObjLoad2
		bne.s	locret_11B5E
		move.b	#$5F,(a1)	; load fuse object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.w	Y_Pos(a0),Off34(a1)
		move.b	Status(a0),Status(a1)
		move.b	#4,Subtype(a1)
		move.b	#3,Anim(a1)
		move.w	#$10,Y_Vel(a1)
		btst	#1,Status(a0)
		beq.s	loc_11B54
		neg.w	Y_Vel(a1)

loc_11B54:
		move.w	#143,Off30(a1)	; set fuse time
		move.l	a0,Off3C(a1)

locret_11B5E:
		rts
; ===========================================================================

Obj5F_Display:				; XREF: Obj5F_Index
		bsr.s	loc_11B70
		lea	Ani_obj5F,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================

loc_11B70:
		subq.w	#1,Off30(a0)
		bmi.s	loc_11B7C
		bsr.w	ObjectMove
		rts
; ===========================================================================

loc_11B7C:
		clr.w	Off30(a0)
		sf	Routine(a0)
		move.w	Off34(a0),Y_Pos(a0)
		moveq	#3,d1
		movea.l	a0,a1
		lea	Obj5F_ShrSpeed,a2 ;	load shrapnel speed data
		bra.s	.MakeShrap
; ===========================================================================

.Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_11BCE

.MakeShrap:			; XREF: loc_11B7C
		move.w	#$5F84,(a1)	; load shrapnel	object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	#6,Subtype(a1)
		move.b	#4,Anim(a1)
		move.l	(a2)+,X_Vel(a1)
		move.b	#$98,Coll(a1)
		dbf	d1,.Loop	; repeat 3 more	times

loc_11BCE:
		move.b	#6,Routine(a0)

Obj5F_End:				; XREF: Obj5F_Index
		bsr.w	ObjectMove
		addi.w	#$18,Y_Vel(a0)
		lea	Ani_obj5F,a1
		bsr.w	AnimateSprite
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj5F_ShrSpeed:	dc.w $FE00, $FD00, $FF00, $FE00, $200, $FD00, $100, $FE00

Ani_obj5F:
	include "_anim\obj5F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - walking bomb enemy (SLZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj5F:
	include "_maps\obj5F.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 60 - Orbinaut enemy (LZ, SLZ, SBZ)
; ---------------------------------------------------------------------------

Obj60:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj60_Index(pc,d0.w),d1
		jmp	Obj60_Index(pc,d1.w)
; ===========================================================================
Obj60_Index:	dc.w Obj60_Main-Obj60_Index
		dc.w Obj60_ChkSonic-Obj60_Index
		dc.w Obj60_Display-Obj60_Index
		dc.w Obj60_MoveOrb-Obj60_Index
		dc.w Obj60_ChkDel2-Obj60_Index
; ===========================================================================

Obj60_Main:				; XREF: Obj60_Index
		move.l	#Map_obj60,Mappings_Offset(a0)
		move.w	#$429,Art_Tile(a0)	; SBZ specific code
		cmpi.b	#5,($FFFFFE10).w ; check if level is SBZ
		beq.s	loc_11D02
		move.w	#$2429,Art_Tile(a0)	; SLZ specific code

loc_11D02:
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	loc_11D10
		move.w	#$467,Art_Tile(a0)	; LZ specific code

loc_11D10:
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$B,Coll(a0)
		move.b	#$C,X_Visible(a0)
		moveq	#0,d2
		lea	Off37(a0),a2
		movea.l	a2,a3
		addq.w	#1,a2
		moveq	#3,d1

Obj60_MakeOrbs:
		bsr.w	SingleObjLoad2
		bne.s	loc_11D90
		addq.b	#1,(a3)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	(a0),(a1)	; load spiked orb object
		move.b	#6,Routine(a1)
		move.l	Mappings_Offset(a0),Mappings_Offset(a1)
		move.w	Art_Tile(a0),Art_Tile(a1)
		ori.b	#4,Render_Flags(a1)
		move.b	#4,Priority(a1)
		move.b	#8,X_Visible(a1)
		move.b	#3,Anim_Frame(a1)
		move.b	#$98,Coll(a1)
		move.b	d2,Angle(a1)
		addi.b	#$40,d2
		move.l	a0,Off3C(a1)
		dbf	d1,Obj60_MakeOrbs ; repeat sequence 3 more times

loc_11D90:
		moveq	#1,d0
		btst	#0,Status(a0)
		beq.s	Obj60_Move
		neg.w	d0

Obj60_Move:
		move.b	d0,Off36(a0)
		move.b	Subtype(a0),Routine(a0)	; if type is 02, skip the firing rountine
		addq.b	#2,Routine(a0)
		move.w	#-$40,X_Vel(a0)	; move orbinaut	to the left
		btst	#0,Status(a0)	; is orbinaut reversed?
		beq.s	locret_11DBC	; if not, branch
		neg.w	X_Vel(a0)		; move orbinaut	to the right

locret_11DBC:
		rts
; ===========================================================================

Obj60_ChkSonic:				; XREF: Obj60_Index
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		bhs.s	loc_11DCA
		neg.w	d0

loc_11DCA:
		cmpi.w	#$A0,d0		; is Sonic within $A0 pixels of	orbinaut?
		bhs.s	Obj60_Animate	; if not, branch
		move.w	Object_RAM+Y_Pos,d0
		sub.w	Y_Pos(a0),d0
		bhs.s	loc_11DDC
		neg.w	d0

loc_11DDC:
		cmpi.w	#$50,d0		; is Sonic within $50 pixels of	orbinaut?
		bhs.s	Obj60_Animate	; if not, branch
		tst.b	$FFFFFE08.w	; is debug mode	on?
		bne.s	Obj60_Animate	; if yes, branch
		move.b	#1,Anim(a0)	; use "angry" animation

Obj60_Animate:
		lea	(Ani_obj60).l,a1
		bsr.w	AnimateSprite
		bra.w	Obj60_ChkDel
; ===========================================================================

Obj60_Display:				; XREF: Obj60_Index
		bsr.w	ObjectMove

Obj60_ChkDel:				; XREF: Obj60_Animate
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj60_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Obj60_ChkGone:				; XREF: Obj60_ChkDel
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_11E34
		bclr	#7,2(a2,d0.w)

loc_11E34:
		lea	Off37(a0),a2
		moveq	#0,d2
		move.b	(a2)+,d2
		subq.w	#1,d2
		blo.s	Obj60_Delete

loc_11E40:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		bsr.w	DeleteObject2
		dbf	d2,loc_11E40

Obj60_Delete:
		bra.w	DeleteObject
; ===========================================================================

Obj60_MoveOrb:				; XREF: Obj60_Index
		movea.l	Off3C(a0),a1
		cmpi.b	#$60,(a1)
		bne.w	DeleteObject
		cmpi.b	#2,Anim_Frame(a1)
		bne.s	Obj60_Circle
		cmpi.b	#$40,Angle(a0)
		bne.s	Obj60_Circle
		addq.b	#2,Routine(a0)
		subq.b	#1,Off37(a1)
		bne.s	Obj60_FireOrb
		addq.b	#2,Routine(a1)

Obj60_FireOrb:
		move.w	#-$200,X_Vel(a0)	; move orb to the left (quickly)
		btst	#0,Status(a1)
		beq.s	Obj60_Display2
		neg.w	X_Vel(a0)

Obj60_Display2:
		bra.w	DisplaySprite
; ===========================================================================

Obj60_Circle:				; XREF: Obj60_MoveOrb
		move.b	Angle(a0),d1
		jsr	(CalcSine).l
		asr.w	#4,d1
		add.w	X_pos(a1),d1
		move.w	d1,X_pos(a0)
		asr.w	#4,d0
		add.w	Y_Pos(a1),d0
		move.w	d0,Y_Pos(a0)
		move.b	Off36(a1),d0
		add.b	d0,Angle(a0)
		bra.w	DisplaySprite
; ===========================================================================

Obj60_ChkDel2:				; XREF: Obj60_Index
		bsr.w	ObjectMove
		tst.b	Render_Flags(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj60:
	include "_anim\obj60.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Orbinaut enemy (LZ,	SLZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj60:
	include "_maps\obj60.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 16 - harpoon (LZ)
; ---------------------------------------------------------------------------

Obj16:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj16_Index(pc,d0.w),d1
		jmp	Obj16_Index(pc,d1.w)
; ===========================================================================
Obj16_Index:	dc.w Obj16_Main-Obj16_Index
		dc.w Obj16_Move-Obj16_Index
		dc.w Obj16_Wait-Obj16_Index
; ===========================================================================

Obj16_Main:				; XREF: Obj16_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj16,Mappings_Offset(a0)
		move.w	#$3CC,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	Subtype(a0),Anim(a0)
		move.b	#$14,X_Visible(a0)
		move.w	#60,Off30(a0)

Obj16_Move:				; XREF: Obj16_Index
		lea	(Ani_obj16).l,a1
		bsr.w	AnimateSprite
		moveq	#0,d0
		move.b	Anim_Frame(a0),d0	; move frame number to d0
		move.b	Obj16_Data(pc,d0.w),Coll(a0) ; load collision response (based on	d0)
		bra.w	MarkObjGone
; ===========================================================================
Obj16_Data:	dc.b $9B, $9C, $9D, $9E, $9F, $A0
; ===========================================================================

Obj16_Wait:				; XREF: Obj16_Index
		subq.w	#1,Off30(a0)
		bpl.s	Obj16_ChkDel
		move.w	#60,Off30(a0)
		subq.b	#2,Routine(a0)	; run "Obj16_Move" subroutine
		bchg	#0,Anim(a0)	; reverse animation

Obj16_ChkDel:
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj16:
	include "_anim\obj16.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - harpoon (LZ)
; ---------------------------------------------------------------------------
Map_obj16:
	include "_maps\obj16.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 61 - blocks (LZ)
; ---------------------------------------------------------------------------

Obj61:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj61_Index(pc,d0.w),d1
		jmp	Obj61_Index(pc,d1.w)
; ===========================================================================
Obj61_Index:	dc.w Obj61_Main-Obj61_Index
		dc.w Obj61_Action-Obj61_Index

Obj61_Var:	dc.b $10, $10		; width, height
		dc.b $20, $C
		dc.b $10, $10
		dc.b $10, $10
; ===========================================================================

Obj61_Main:				; XREF: Obj61_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj61,Mappings_Offset(a0)
		move.w	#$43E6,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		lea	Obj61_Var(pc,d0.w),a2
		move.b	(a2)+,X_Visible(a0)
		move.b	(a2),Y_Radius(a0)
		lsr.w	#1,d0
		move.b	d0,Anim_Frame(a0)
		move.w	X_pos(a0),Off34(a0)
		move.w	Y_Pos(a0),Off30(a0)
		move.b	Subtype(a0),d0
		andi.b	#$F,d0
		beq.s	Obj61_Action
		cmpi.b	#7,d0
		beq.s	Obj61_Action
		move.b	#1,Off38(a0)

Obj61_Action:				; XREF: Obj61_Index
		move.w	X_pos(a0),-(sp)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj61_TypeIndex(pc,d0.w),d1
		jsr	Obj61_TypeIndex(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	Render_Flags(a0)
		bpl.s	Obj61_ChkDel
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	Y_Radius(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		bsr.w	SolidObject
		move.b	d4,Off3F(a0)
		bsr.w	loc_12180

Obj61_ChkDel:
		move.w	Off34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj61_TypeIndex:dc.w Obj61_Type00-Obj61_TypeIndex, Obj61_Type01-Obj61_TypeIndex
		dc.w Obj61_Type02-Obj61_TypeIndex, Obj61_Type01-Obj61_TypeIndex
		dc.w Obj61_Type04-Obj61_TypeIndex, Obj61_Type05-Obj61_TypeIndex
		dc.w Obj61_Type02-Obj61_TypeIndex, Obj61_Type07-Obj61_TypeIndex
; ===========================================================================

Obj61_Type00:				; XREF: Obj61_TypeIndex
		rts
; ===========================================================================

Obj61_Type01:				; XREF: Obj61_TypeIndex
		tst.w	Off36(a0)		; is Sonic standing on the object?
		bne.s	loc_120D6	; if yes, branch
		btst	#3,Status(a0)
		beq.s	locret_120D4
		move.w	#30,Off36(a0)	; wait for ยซ second

locret_120D4:
		rts
; ===========================================================================

loc_120D6:
		subq.w	#1,Off36(a0)	; subtract 1 from waiting time
		bne.s	locret_120D4	; if time remains, branch
		addq.b	#1,Subtype(a0)	; add 1	to type
		sf	Off38(a0)
		rts
; ===========================================================================

Obj61_Type02:				; XREF: Obj61_TypeIndex
		bsr.w	ObjectMove
		addq.w	#8,Y_Vel(a0)	; make object fall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	locret_12106
		addq.w	#1,d1
		add.w	d1,Y_Pos(a0)
		clr.w	Y_Vel(a0)		; stop when it touches the floor
		sf	Subtype(a0)		; set type to 00 (non-moving type)

locret_12106:
		rts
; ===========================================================================

Obj61_Type04:				; XREF: Obj61_TypeIndex
		bsr.w	ObjectMove
		subq.w	#8,Y_Vel(a0)	; make object rise
		jsr	ObjHitCeiling
		tst.w	d1
		bpl.w	locret_12126
		sub.w	d1,Y_Pos(a0)
		clr.w	Y_Vel(a0)		; stop when it touches the ceiling
		sf	Subtype(a0)		; set type to 00 (non-moving type)

locret_12126:
		rts
; ===========================================================================

Obj61_Type05:				; XREF: Obj61_TypeIndex
		cmpi.b	#1,Off3F(a0)	; is Sonic touching the	object?
		bne.s	locret_12138	; if not, branch
		addq.b	#1,Subtype(a0)	; if yes, add 1	to type
		sf	Off38(a0)

locret_12138:
		rts
; ===========================================================================

Obj61_Type07:				; XREF: Obj61_TypeIndex
		move.w	($FFFFF646).w,d0
		sub.w	Y_Pos(a0),d0
		beq.s	locret_1217E
		bhs.s	loc_12162
		cmpi.w	#-2,d0
		bge.s	loc_1214E
		moveq	#-2,d0

loc_1214E:
		add.w	d0,Y_Pos(a0)	; make the block rise with water level
		jsr	ObjHitCeiling
		tst.w	d1
		bpl.w	locret_12160
		sub.w	d1,Y_Pos(a0)

locret_12160:
		rts
; ===========================================================================

loc_12162:				; XREF: Obj61_Type07
		cmpi.w	#2,d0
		ble.s	loc_1216A
		moveq	#2,d0

loc_1216A:
		add.w	d0,Y_Pos(a0)	; make the block sink with water level
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	locret_1217E
		addq.w	#1,d1
		add.w	d1,Y_Pos(a0)

locret_1217E:
		rts
; ===========================================================================

loc_12180:				; XREF: Obj61_Action
		tst.b	Off38(a0)
		beq.s	locret_121C0
		btst	#3,Status(a0)
		bne.s	loc_1219A
		tst.b	Off3E(a0)
		beq.s	locret_121C0
		subq.b	#4,Off3E(a0)
		bra.s	loc_121A6
; ===========================================================================

loc_1219A:
		cmpi.b	#$40,Off3E(a0)
		beq.s	locret_121C0
		addq.b	#4,Off3E(a0)

loc_121A6:
		move.b	Off3E(a0),d1
		jsr	(CalcSine).l
		move.w	#$400,d1
		muls.w	d1,d0
		swap	d0
		add.w	Off30(a0),d0
		move.w	d0,Y_Pos(a0)

locret_121C0:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - blocks (LZ)
; ---------------------------------------------------------------------------
Map_obj61:
	include "_maps\obj61.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 62 - gargoyle head (LZ)
; ---------------------------------------------------------------------------

Obj62:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj62_Index(pc,d0.w),d1
		jsr	Obj62_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj62_Index:	dc.w Obj62_Main-Obj62_Index
		dc.w Obj62_MakeFire-Obj62_Index
		dc.w Obj62_FireBall-Obj62_Index
		dc.w Obj62_AniFire-Obj62_Index

Obj62_SpitRate:	dc.b 30, 60, 90, 120, 150, 180,	210, 240
; ===========================================================================

Obj62_Main:				; XREF: Obj62_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj62,Mappings_Offset(a0)
		move.w	#$42E9,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#3,Priority(a0)
		move.b	#$10,X_Visible(a0)
		move.b	Subtype(a0),d0	; get object type
		andi.w	#$F,d0		; read only the	2nd digit
		move.b	Obj62_SpitRate(pc,d0.w),$1F(a0)	; set fireball spit rate
		move.b	$1F(a0),Anim_Dur(a0)
		andi.b	#$F,Subtype(a0)

Obj62_MakeFire:				; XREF: Obj62_Index
		subq.b	#1,Anim_Dur(a0)
		bne.s	Obj62_NoFire
		move.b	$1F(a0),Anim_Dur(a0)
		bsr.w	ChkObjOnScreen
		bne.s	Obj62_NoFire
		bsr.w	SingleObjLoad
		bne.s	Obj62_NoFire
		move.b	#$62,(a1)	; load fireball	object
		addq.b	#4,Routine(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	Render_Flags(a0),Render_Flags(a1)
		move.b	Status(a0),Status(a1)

Obj62_NoFire:
		rts
; ===========================================================================

Obj62_FireBall:				; XREF: Obj62_Index
		addq.b	#2,Routine(a0)
		move.b	#8,Y_Radius(a0)
		move.b	#8,X_Radius(a0)
		move.l	#Map_obj62,Mappings_Offset(a0)
		move.w	#$2E9,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$98,Coll(a0)
		move.b	#8,X_Visible(a0)
		move.b	#2,Anim_Frame(a0)
		addq.w	#8,Y_Pos(a0)
		move.w	#$200,X_Vel(a0)
		btst	#0,Status(a0)
		bne.s	Obj62_Sound
		neg.w	X_Vel(a0)

Obj62_Sound:
		move.w	#$AE,d0
		jsr	(PlaySound).l ;	play lava ball sound

Obj62_AniFire:				; XREF: Obj62_Index
		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	Obj62_StopFire
		bchg	#0,Anim_Frame(a0)	; switch between frame 01 and 02

Obj62_StopFire:
		bsr.w	ObjectMove
		btst	#0,Status(a0)
		bne.s	Obj62_StopFire2
		moveq	#-8,d3
		jsr	ObjHitWallLeft
		tst.w	d1
		bmi.w	DeleteObject	; delete if the	fireball hits a	wall
		rts
; ===========================================================================

Obj62_StopFire2:
		moveq	#8,d3
		jsr	ObjHitWallRight
		tst.w	d1
		bmi.w	DeleteObject
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - gargoyle head (LZ)
; ---------------------------------------------------------------------------
Map_obj62:
	include "_maps\obj62.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 63 - platforms	on a conveyor belt (LZ)
; ---------------------------------------------------------------------------

Obj63:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj63_Index(pc,d0.w),d1
		jsr	Obj63_Index(pc,d1.w)
		move.w	Off30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_1236A

Obj63_Display:				; XREF: loc_1236A
		bra.w	DisplaySprite
; ===========================================================================

loc_1236A:				; XREF: Obj63
		cmpi.b	#2,($FFFFFE11).w
		bne.s	loc_12378
		cmpi.w	#-$80,d0
		bhs.s	Obj63_Display

loc_12378:
		move.b	Off2F(a0),d0
		bpl.w	DeleteObject
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bclr	#0,(a2,d0.w)
		bra.w	DeleteObject
; ===========================================================================
Obj63_Index:	dc.w Obj63_Main-Obj63_Index
		dc.w loc_124B2-Obj63_Index
		dc.w loc_124C2-Obj63_Index
		dc.w loc_124DE-Obj63_Index
; ===========================================================================

Obj63_Main:				; XREF: Obj63_Index
		move.b	Subtype(a0),d0
		bmi.w	loc_12460
		addq.b	#2,Routine(a0)
		move.l	#Map_obj63,Mappings_Offset(a0)
		move.w	#$43F6,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#4,Priority(a0)
		cmpi.b	#$7F,Subtype(a0)
		bne.s	loc_123E2
		addq.b	#4,Routine(a0)
		move.w	#$3F6,Art_Tile(a0)
		move.b	#1,Priority(a0)
		bra.w	loc_124DE
; ===========================================================================

loc_123E2:
		move.b	#4,Anim_Frame(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Obj63_Data(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,Off38(a0)
		move.w	(a2)+,Off30(a0)
		move.l	a2,Off3C(a0)
		andi.w	#$F,d1
		lsl.w	#2,d1
		move.b	d1,Off38(a0)
		move.b	#4,Off3A(a0)
		tst.b	($FFFFF7C0).w
		beq.s	loc_1244C
		move.b	#1,Off3B(a0)
		neg.b	Off3A(a0)
		moveq	#0,d1
		move.b	Off38(a0),d1
		add.b	Off3A(a0),d1
		cmp.b	Off39(a0),d1
		blo.s	loc_12448
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_12448
		move.b	Off39(a0),d1
		subq.b	#4,d1

loc_12448:
		move.b	d1,Off38(a0)

loc_1244C:
		move.w	(a2,d1.w),Off34(a0)
		move.w	2(a2,d1.w),Off36(a0)
		bsr.w	Obj63_ChangeDir
		bra.w	loc_124B2
; ===========================================================================

loc_12460:				; XREF: Obj63_Main
		move.b	d0,Off2F(a0)
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bset	#0,(a2,d0.w)
		bne.w	DeleteObject
		add.w	d0,d0
		andi.w	#$1E,d0
	;	addi.w	#$100,d0
		lea	Objpos_index_LZpf,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d1
		movea.l	a0,a1
		bra.s	Obj63_MakePtfms
; ===========================================================================

Obj63_Loop:
		bsr.w	SingleObjLoad
		bne.s	loc_124AA

Obj63_MakePtfms:			; XREF: loc_12460
		move.b	#$63,0(a1)
		move.w	(a2)+,X_pos(a1)
		move.w	(a2)+,Y_Pos(a1)
		move.w	(a2)+,d0
		move.b	d0,Subtype(a1)

loc_124AA:
		dbf	d1,Obj63_Loop

		addq.l	#4,sp
		rts
; ===========================================================================

loc_124B2:				; XREF: Obj63_Index
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(PlatformObject).l
		bra.w	sub_12502
; ===========================================================================

loc_124C2:				; XREF: Obj63_Index
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(ExitPlatform).l
		move.w	X_pos(a0),-(sp)
		bsr.w	sub_12502
		move.w	(sp)+,d2
		jmp	(MvSonicOnPtfm2).l
; ===========================================================================

loc_124DE:				; XREF: Obj63_Index
		move.w	($FFFFFE04).w,d0
		andi.w	#3,d0
		bne.s	loc_124FC
		moveq	#1,d1
		tst.b	($FFFFF7C0).w
		beq.s	loc_124F2
		neg.b	d1

loc_124F2:
		add.b	d1,Anim_Frame(a0)
		andi.b	#3,Anim_Frame(a0)

loc_124FC:
		addq.l	#4,sp
		bra.w	MarkObjGone

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_12502:				; XREF: loc_124B2; loc_124C2
		tst.b	($FFFFF7EE).w
		beq.s	loc_12520
		tst.b	Off3B(a0)
		bne.s	loc_12520
		move.b	#1,Off3B(a0)
		move.b	#1,($FFFFF7C0).w
		neg.b	Off3A(a0)
		bra.s	loc_12534
; ===========================================================================

loc_12520:
		move.w	X_pos(a0),d0
		cmp.w	Off34(a0),d0
		bne.s	loc_1256A
		move.w	Y_Pos(a0),d0
		cmp.w	Off36(a0),d0
		bne.s	loc_1256A

loc_12534:
		moveq	#0,d1
		move.b	Off38(a0),d1
		add.b	Off3A(a0),d1
		cmp.b	Off39(a0),d1
		blo.s	loc_12552
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_12552
		move.b	Off39(a0),d1
		subq.b	#4,d1

loc_12552:
		move.b	d1,Off38(a0)
		movea.l	Off3C(a0),a1
		move.w	(a1,d1.w),Off34(a0)
		move.w	2(a1,d1.w),Off36(a0)
		bsr.w	Obj63_ChangeDir

loc_1256A:
		bsr.w	ObjectMove
		rts
; End of function sub_12502


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj63_ChangeDir:			; XREF: loc_123E2; sub_12502
		moveq	#0,d0
		move.w	#-$100,d2
		move.w	X_pos(a0),d0
		sub.w	Off34(a0),d0
		bhs.s	loc_12584
		neg.w	d0
		neg.w	d2

loc_12584:
		moveq	#0,d1
		move.w	#-$100,d3
		move.w	Y_Pos(a0),d1
		sub.w	Off36(a0),d1
		bhs.s	loc_12598
		neg.w	d1
		neg.w	d3

loc_12598:
		cmp.w	d0,d1
		blo.s	loc_125C2
		move.w	X_pos(a0),d0
		sub.w	Off34(a0),d0
		beq.s	loc_125AE
		ext.l	d0
		asl.l	#8,d0
		divs.w	d1,d0
		neg.w	d0

loc_125AE:
		move.w	d0,X_Vel(a0)
		move.w	d3,Y_Vel(a0)
		swap	d0
		move.w	d0,X_Pos2(a0)
		clr.w	Y_Pos2(a0)
		rts
; ===========================================================================

loc_125C2:				; XREF: Obj63_ChangeDir
		move.w	Y_Pos(a0),d1
		sub.w	Off36(a0),d1
		beq.s	loc_125D4
		ext.l	d1
		asl.l	#8,d1
		divs.w	d0,d1
		neg.w	d1

loc_125D4:
		move.w	d1,Y_Vel(a0)
		move.w	d2,X_Vel(a0)
		swap	d1
		move.w	d1,Y_Pos2(a0)
		clr.w	X_Pos2(a0)
		rts
; End of function Obj63_ChangeDir

; ===========================================================================
Obj63_Data:	dc.w word_125F4-Obj63_Data
		dc.w word_12610-Obj63_Data
		dc.w word_12628-Obj63_Data
		dc.w word_1263C-Obj63_Data
		dc.w word_12650-Obj63_Data
		dc.w word_12668-Obj63_Data
word_125F4:	dc.w $18, $1070, $1078,	$21A, $10BE, $260, $10BE, $393
		dc.w $108C, $3C5, $1022, $390, $1022, $244
word_12610:	dc.w $14, $1280, $127E,	$280, $12CE, $2D0, $12CE, $46E
		dc.w $1232, $420, $1232, $2CC
word_12628:	dc.w $10, $D68,	$D22, $482, $D22, $5DE,	$DAE, $5DE, $DAE, $482
word_1263C:	dc.w $10, $DA0,	$D62, $3A2, $DEE, $3A2,	$DEE, $4DE, $D62, $4DE
word_12650:	dc.w $14, $D00,	$CAC, $242, $DDE, $242,	$DDE, $3DE, $C52, $3DE,	$C52, $29C
word_12668:	dc.w $10, $1300, $1252,	$20A, $13DE, $20A, $13DE, $2BE,	$1252, $2BE

; ---------------------------------------------------------------------------
; Sprite mappings - platforms on a conveyor belt (LZ)
; ---------------------------------------------------------------------------
Map_obj63:
	include "_maps\obj63.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 64 - bubbles (LZ)
; ---------------------------------------------------------------------------

Obj64:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj64_Index(pc,d0.w),d1
		jmp	Obj64_Index(pc,d1.w)
; ===========================================================================
Obj64_Index:	dc.w Obj64_Main-Obj64_Index
		dc.w Obj64_Animate-Obj64_Index
		dc.w Obj64_ChkWater-Obj64_Index
		dc.w Obj64_Display2-Obj64_Index
		dc.w Obj64_Delete3-Obj64_Index
		dc.w Obj64_BblMaker-Obj64_Index
; ===========================================================================

Obj64_Main:				; XREF: Obj64_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj64,Mappings_Offset(a0)
		move.w	#$8348,Art_Tile(a0)
		move.b	#$84,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#1,Priority(a0)
		move.b	Subtype(a0),d0	; get object type
		bpl.s	Obj64_Bubble	; if type is $0-$7F, branch
		addq.b	#8,Routine(a0)
		andi.w	#$7F,d0		; read only last 7 bits	(deduct	$80)
		move.b	d0,Off32(a0)
		move.b	d0,Off33(a0)
		move.b	#6,Anim(a0)
		bra.w	Obj64_BblMaker
; ===========================================================================

Obj64_Bubble:				; XREF: Obj64_Main
		move.b	d0,Anim(a0)
		move.w	X_pos(a0),Off30(a0)
		move.w	#-$88,Y_Vel(a0)	; float	bubble upwards
		jsr	(RandomNumber).l
		move.b	d0,Angle(a0)

Obj64_Animate:				; XREF: Obj64_Index
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite
		cmpi.b	#6,Anim_Frame(a0)
		bne.s	Obj64_ChkWater
		move.b	#1,Off2E(a0)

Obj64_ChkWater:				; XREF: Obj64_Index
		move.w	($FFFFF646).w,d0
		cmp.w	Y_Pos(a0),d0	; is bubble underwater?
		blo.s	Obj64_Wobble	; if yes, branch

Obj64_Burst:				; XREF: Obj64_Wobble
		move.b	#6,Routine(a0)
		addq.b	#3,Anim(a0)	; run "bursting" animation
		bra.w	Obj64_Display2
; ===========================================================================

Obj64_Wobble:				; XREF: Obj64_ChkWater
		move.b	Angle(a0),d0
		addq.b	#1,Angle(a0)
		andi.w	#$7F,d0
		lea	(Obj0A_WobbleData).l,a1
		move.b	(a1,d0.w),d0
		ext.w	d0
		add.w	Off30(a0),d0
		move.w	d0,X_pos(a0)	; change bubble's horizontal position
		tst.b	Off2E(a0)
		beq.s	Obj64_Display
		bsr.w	Obj64_ChkSonic	; has Sonic touched the	bubble?
		beq.s	Obj64_Display	; if not, branch
		pea	Obj64_Burst(pc)

CollectBubble:
		bsr.w	ResumeMusic	; cancel countdown music
		moveq	#$FFFFFFAD,d0
		jsr	PlaySound	; play collecting bubble sound
		lea	Object_RAM,a1
		clr.w	X_Vel(a1)
		clr.w	Y_Vel(a1)
		clr.w	Inertia(a1)

		moveq	#$15,d0
		jsr	K_Glide_HitObj
		move.b	#$15,Anim(a1)

		move.w	#$23,Off3E(a1)
		move.b	#0,Off3C(a1)
		bclr	#5,Status(a1)
		bclr	#4,Status(a1)
		btst	#2,Status(a1)
		beq.s	.end
		bclr	#2,Status(a1)
		move.w	Player_StandHeight.w,Y_Radius(a1)	; set radius
		subq.w	#5,Y_Pos(a1)
.end		rts
; ===========================================================================

Obj64_Display:				; XREF: Obj64_Wobble
		bsr.w	ObjectMove
		tst.b	Render_Flags(a0)
		bpl.s	Obj64_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj64_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj64_Display2:				; XREF: Obj64_Index
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite
		tst.b	Render_Flags(a0)
		bpl.s	Obj64_Delete2
		jmp	DisplaySprite
; ===========================================================================

Obj64_Delete2:
		jmp	DeleteObject
; ===========================================================================

Obj64_Delete3:				; XREF: Obj64_Index
		bra.w	DeleteObject
; ===========================================================================

Obj64_BblMaker:				; XREF: Obj64_Index
		tst.w	Off36(a0)
		bne.s	loc_12874
		move.w	($FFFFF646).w,d0
		cmp.w	Y_Pos(a0),d0	; is bubble maker underwater?
		bhs.w	Obj64_ChkDel	; if not, branch
		tst.b	Render_Flags(a0)
		bpl.w	Obj64_ChkDel
		subq.w	#1,Off38(a0)
		bpl.w	loc_12914
		move.w	#1,Off36(a0)

loc_1283A:
		jsr	(RandomNumber).l
		move.w	d0,d1
		andi.w	#7,d0
		cmpi.w	#6,d0
		bhs.s	loc_1283A

		move.b	d0,Off34(a0)
		andi.w	#$C,d1
		lea	(Obj64_BblTypes).l,a1
		adda.w	d1,a1
		move.l	a1,Off3C(a0)
		subq.b	#1,Off32(a0)
		bpl.s	loc_12872
		move.b	Off33(a0),Off32(a0)
		bset	#7,Off36(a0)

loc_12872:
		bra.s	loc_1287C
; ===========================================================================

loc_12874:				; XREF: Obj64_BblMaker
		subq.w	#1,Off38(a0)
		bpl.w	loc_12914

loc_1287C:
		jsr	(RandomNumber).l
		andi.w	#$1F,d0
		move.w	d0,Off38(a0)
		bsr.w	SingleObjLoad
		bne.s	loc_128F8
		move.b	#$64,(a1)	; load bubble object
		move.w	X_pos(a0),X_pos(a1)
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		subq.w	#8,d0
		add.w	d0,X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		moveq	#0,d0
		move.b	Off34(a0),d0
		movea.l	Off3C(a0),a2
		move.b	(a2,d0.w),Subtype(a1)
		btst	#7,Off36(a0)
		beq.s	loc_128F8
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	loc_128E4
		bset	#6,Off36(a0)
		bne.s	loc_128F8
		move.b	#2,Subtype(a1)

loc_128E4:
		tst.b	Off34(a0)
		bne.s	loc_128F8
		bset	#6,Off36(a0)
		bne.s	loc_128F8
		move.b	#2,Subtype(a1)

loc_128F8:
		subq.b	#1,Off34(a0)
		bpl.s	loc_12914
		jsr	(RandomNumber).l
		andi.w	#$7F,d0
		addi.w	#$80,d0
		add.w	d0,Off38(a0)
		clr.w	Off36(a0)

loc_12914:
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite

Obj64_ChkDel:				; XREF: Obj64_BblMaker
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		move.w	($FFFFF646).w,d0
		cmp.w	Y_Pos(a0),d0
		blo.w	DisplaySprite
		rts
; ===========================================================================
; bubble production sequence

; 0 = small bubble, 1 =	large bubble

Obj64_BblTypes:	dc.b 0,	1, 0, 0, 0, 0, 1, 0, 0,	0, 0, 1, 0, 1, 0, 0, 1,	0

; ===========================================================================

Obj64_ChkSonic:				; XREF: Obj64_Wobble
		cmpi.b	#2,Shield_RAM+Inertia
	        beq	loc_12998
		tst.b	($FFFFF7C8).w
		bmi.s	loc_12998
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		move.w	X_pos(a0),d1
		subi.w	#$10,d1
		cmp.w	d0,d1
		bhs.s	loc_12998
		addi.w	#$20,d1
		cmp.w	d0,d1
		blo.s	loc_12998
		move.w	Y_Pos(a1),d0
		move.w	Y_Pos(a0),d1
		cmp.w	d0,d1
		bhs.s	loc_12998
		addi.w	#$10,d1
		cmp.w	d0,d1
		blo.s	loc_12998
		moveq	#1,d0
		rts
; ===========================================================================

loc_12998:
		moveq	#0,d0
		rts
; ===========================================================================
Ani_obj64:
	include "_anim\obj64.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - bubbles (LZ)
; ---------------------------------------------------------------------------
Map_obj64:
	include "_maps\obj64.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 65 - waterfalls (LZ)
; ---------------------------------------------------------------------------

Obj65:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj65_Index(pc,d0.w),d1
		jmp	Obj65_Index(pc,d1.w)
; ===========================================================================
Obj65_Index:	dc.w Obj65_Main-Obj65_Index
		dc.w Obj65_Animate-Obj65_Index
		dc.w Obj65_ChkDel-Obj65_Index
		dc.w Obj65_FixHeight-Obj65_Index
		dc.w loc_12B36-Obj65_Index
; ===========================================================================

Obj65_Main:				; XREF: Obj65_Index
		addq.b	#4,Routine(a0)
		move.l	#Map_obj65,Mappings_Offset(a0)
		move.w	#$4259,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$18,X_Visible(a0)
		move.b	#1,Priority(a0)
		move.b	Subtype(a0),d0	; get object type
		bpl.s	loc_12AE6
		bset	#7,Art_Tile(a0)

loc_12AE6:
		andi.b	#$F,d0		; read only the	2nd byte
		move.b	d0,Anim_Frame(a0)	; set frame number
		cmpi.b	#9,d0		; is object type $x9 ?
		bne.s	Obj65_ChkDel	; if not, branch
		sf	Priority(a0)
		subq.b	#2,Routine(a0)
		btst	#6,Subtype(a0)	; is object type $4x ?
		beq.s	loc_12B0A	; if not, branch
		move.b	#6,Routine(a0)

loc_12B0A:
		btst	#5,Subtype(a0)	; is object type $Ax ?
		beq.s	Obj65_Animate	; if not, branch
		move.b	#8,Routine(a0)

Obj65_Animate:				; XREF: Obj65_Index
		lea	(Ani_obj65).l,a1
		jsr	AnimateSprite

Obj65_ChkDel:				; XREF: Obj65_Index
		bra.w	MarkObjGone
; ===========================================================================

Obj65_FixHeight:			; XREF: Obj65_Index
		move.w	($FFFFF646).w,d0
		subi.w	#$10,d0
		move.w	d0,Y_Pos(a0)	; match	object position	to water height
		bra.s	Obj65_Animate
; ===========================================================================

loc_12B36:				; XREF: Obj65_Index
		bclr	#7,Art_Tile(a0)
		cmpi.b	#7,($FFFFA506).w
		bne.s	Obj65_Animate2
		bset	#7,Art_Tile(a0)

Obj65_Animate2:
		bra.s	Obj65_Animate
; ===========================================================================
Ani_obj65:
	include "_anim\obj65.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - waterfalls (LZ)
; ---------------------------------------------------------------------------
Map_obj65:
	include "_maps\obj65.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object $8E - Spindash dust
; ---------------------------------------------------------------------------

SpinDash_dust:
		moveq	#0,d0
		move.b	Routine(a0),d0
                move.w	.I(pc,d0.w),d1
		jmp	.I(pc,d1.w)
; ===========================================================================
.I		dc.w Spindust_Init-.I, Spindust_Main-.I, SpinDust_Anim-.I
		dc.w Deleteobject-.I
; ===========================================================================

Spindust_Init:
		addq.b	#2,Routine(a0)			; next routine
		move.l	#Map_DashDust,Mappings_offset(a0); mappings
		move.w	#$7A0,Art_Tile(a0)		; art location
		move.b	#1,Priority(a0)			; priority
		move.b	#$18,X_Radius(a0)		; size
		move.b	#4,Render_Flags(a0)		; render
; ===========================================================================

Spindust_Main:
		lea	Object_RAM,a2			; get Sonic's RAM address

		tst.b	If_Spindash.w			; are we spindashing?
		bne	Spindust_Common			; if yes, branch
		moveq	#$10,d1				; set offset
		cmpi.b	#$D,Anim(a2)			; is the animation $D?
		beq	StopDust_Main			; if is, branch

		moveq	#6,d1				; set offset
		cmpi.b	#3,Gliding_Main			; are we sliding
		beq	StopDust_Main			; if we are, branch
		move.b	#0,off32(a0)			; clear counter

Spindust_rts:
		rts
; ===========================================================================

StopDust_Main:
		move.b	#$15,Anim_Frame(a0)		; set frame ID (fixes art not loading bug)
		subq.b	#1,off32(a0)			; subtract 1 from counter
		bpl	Spindust_Common			; if positive, branch
		move.b	#3,off32(a0)			; move 3 to counter
		jsr	SingleObjLoad			; load object
		bne	Spindust_Common			; if full, branch
		move.b	(a0),(a1)			; set type
		move.w	X_Pos(a2),X_pos(a1)		; get position
		move.w	Y_Pos(a2),Y_pos(a1)		; ^
		tst.b	off34(a0)			; test... flag?
		beq	.				; if not set, branch
		sub.w	#4,d1				; sub 4 from offset

.		add.w	d1,Y_pos(a1)			; set offset
		move.b	#0,Status(a1)			; clear status
		move.b	#3,Anim(a1)			; move 3 to anim
		addq.b	#4,Routine(a1)			; move 4 to routine counter
		move.l	Mappings_offset(a0),Mappings_offset(a1); get mappings
		move.b	Render_Flags(a0),Render_Flags(a1); get render flags
		move.b	#1,Priority(a1)			; set priority
		move.b	#4,X_Visible(a1)		; set X-visiblity
		move.w	Art_Tile(a0),Art_Tile(a1)	; get art tile
; ===========================================================================

Spindust_Common:
		cmpi.b	#6,Routine(a2)			; Are you dead?
		bhs	Spindust_rts			; if you are, dont cheat!
		move.w	X_Pos(a2),X_Pos(a0)		; get pos
		move.w	Y_Pos(a2),Y_Pos(a0)		; ^

		cmpi.b	#2,Current_Character.w
		bne.s	.notTails
		subq.w	#4,Y_Pos(a0)			; hack to fix tails spindust

.notTails	move.b	Render_Flags(a2),d0		; get render flags
		move.b	d0,Render_Flags(a0)		; copy over to current object
		andi.b	#%00000011,d0			; filter out all bits but 0&1
		move.b	d0,Status(a0)			; save to status

		andi.b	#$7F,Art_Tile(a0)		; clear bit 7
		tst.b	Object_RAM+Art_Tile		; check if Sonic is in high plane
		bpl	.a				; if is not, branch
		ori.b	#$80,Art_Tile(a0)		; set to high plane

.a		lea	Anim_DashDust,a1		; get animation
		jsr	AnimateSprite			; animate

		lea	DPLC_DashDust,a2		; get the DPLC
                move.l	#Art_Dust,d6			; art
                move.w	#($7A0*$20),d4			; VRAM address
		jsr	Load_DPLC			; load DPLC
		bra	DisplaySprite			; display
; ===========================================================================

Spindust_Anim:
		lea	Anim_DashDust,a1		; get animation
		jsr	AnimateSprite			; animate
		bra	DisplaySprite			; display
; ===========================================================================

Anim_DashDust:	dc.w .0-Anim_DashDust
		dc.w .1-Anim_DashDust
		dc.w .2-Anim_DashDust
		dc.w .3-Anim_DashDust

.0		dc.b $1F,  0,$FF
.1		dc.b   3,  1,  2,  3,  4,  5,  6,  7,  8,  9,$FD,  0
.2		dc.b   1, $A, $B, $C, $D, $E, $F,$10,$FF
.3		dc.b   3,$11,$12,$13,$14,$FC
		even
; ===========================================================================

Map_DashDust:	include _maps\dashdust.asm
DPLC_DashDust:	include _inc\DPLC_Dashdust.asm
Art_Dust:	incbin	artunc\spindust.bin
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; Tails tail
; ---------------------------------------------------------------------------

Tails_Tail:
	   	moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	.Index(pc,d0.w),d1
		jmp	.Index(pc,d1.w)
; ===========================================================================
.Index:		dc.w Tails_Tail_Init-.Index
		dc.w Tails_Tail_Main-.Index
; ===========================================================================
; loc_1D212
Tails_Tail_Init:
		addq.b	#2,Routine(a0)		;
		move.l	#Map_Tail,Mappings_offset(a0);
		move.w	#$797,Art_Tile(a0)	;
		move.b	#2,Priority(a0)		;
		move.b	#$18,X_Radius(a0)	;
		move.b	#4,Render_Flags(a0)	; whatever
		move.l	#Object_RAM,Off3C(a0)	; just to deal with parent objects shit

Tails_Tail_Main:
		cmpi.b	#2,Current_Character.w	; is a tails?
		bne	TT_NotShow		; is a not?
		move.l	Off3C(a0),a2		; get parent object (usually tails, can be changed to lea $FFFFD000,a2retro286)

		move.b	Angle(a2),Angle(a0)	;
		move.b	Status(a2),Status(a0)	;
		move.w	X_Pos(a2),X_Pos(a0)	;
                move.w	Y_Pos(a2),Y_Pos(a0)	; copy all kinds of shite

		bclr	#7,Art_Tile(a0)		; set to low plane
		move.b	Art_Tile(a2),d0		; get first byte of Art_Tile for Sonic
		andi.b	#$80,d0			; only leave bit 7
		or.b	d0,Art_Tile(a0)		; set bit 7 if bit 7 was set on d0

loc_1D286:
		moveq	#0,d0
		move.b	Anim(a2),d0		; get animation
		bne	.NoPush			; if is not walking, branch
		btst	#5,Status(a2)		; is Sonic pushing something?
		beq.s	.NoPush			; if not, branch
		moveq	#4,d0			; set to push animation

.NoPush		move.b	Tails_Tail_Anis(pc,d0.w),Anim(a0); set animation

.NoChange	lea	Tails_Tail_AniData,a1	; get animation
		jsr	Sonic_Animate2		; animate
		lea     TailDynPLC,a2           ; get the DPLC
                move.l  #Art_Tail,d6		; art
                move.w  #$F2E0,d4               ; VRAM address
		jsr	Load_DPLC		; load the art to VRAM

		move.w	Object_RAM+Off30,d0	; check if sonic is hurt
		beq.s	.Show			; if not, branch
		lsr.w	#3,d0			; shift right by 3 (Divide by 8)
		bhs	TT_NotShow		; branch if higher than or same ???
.Show		jmp	DisplaySprite		; display the object
TT_NotShow	rts

Tails_Tail_Anis:
		dc.b 0, 0, 3, 3, 9, 1, 0, 1, 1, 7, 0, 0, 0, 8, 0, 0
		dc.b 0, 0, 0, 0, $A, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, $B
		dc.b $B, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
		dc.b 0, 0
	        even

; ---------------------------------------------------------------------------
; Animation script - Tails' tails
; ---------------------------------------------------------------------------
; off_1D2C0:
Tails_Tail_AniData:
        include _anim/Tail.asm
Map_Tail:
	include "_maps\Tail.asm"
TailDynPLC:
	include "_inc\Tail_DPLC.asm"
Art_Tail:	incbin	artunc\Tail.bin	; Sonic
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 01 - Sonic
; ---------------------------------------------------------------------------
Sonic_Setspeed:
	        moveq	#0,d0
		btst	#6,Status(a0)		; is underwater?
		beq.s	.NoUW			; if not, branch
		moveq	#16,d0

.NoUW		tst.b	($FFFFFE2E).w		; does Sonic have speed	shoes?
		beq.s	.NoShoes		; if not, branch
		addq.w	#8,d0

.NoShoes

.NoTurbo	move.w	SpeedList(pc,d0.w),$FFFFF760.w	; set max speed
		move.w	SpeedList+2(pc,d0.w),$FFFFF762.w	; set acceleration
		move.w	SpeedList+4(pc,d0.w),$FFFFF764.w	; set deceleration

		tst.b	Current_Character.w	; test for Sonic
		bra.s	.end			; if is Sonic, branch

		moveq	#0,d0
		move.w	$FFFFF760.w,d0		; get speed
		lsr.w	#5,d0			; shift bits right by 5 (divide by 32)
		sub.w	d0,$FFFFF760.w		; subtract the result

		move.w	$FFFFF762.w,d0		; get acceleration
		lsr.w	#3,d0			; shift bits right by 3 (divide by 8)
		sub.w	d0,$FFFFF762.w		; subtract the result

		move.w	$FFFFF764.w,d0		; get deceleration
		lsr.w	#3,d0			; shift bits right by 3 (divide by 8)
		sub.w	d0,$FFFFF764.w		; subtract the result

		cmpi.b	#1,Current_Character.w	; is Knuckles?
		bne	.end			; if not, branch
		subq.w	#1,$FFFFF762.w		; sub 1 from acceleration
		subq.w	#4,$FFFFF764.w		; sub 3 from deceleration
.end		rts

SpeedList:	dc.w Speed_Normal,Acc_Normal,Dec_Normal,0
		dc.w Speed_Shoes,Acc_Shoes,Dec_Shoes,0
		dc.w Speed_UW,Acc_UW,Dec_UW,0
		dc.w Speed_UW_Sho,Acc_UW_Sho,Dec_UW_Sho,0

Obj01:					; XREF: Obj_Index
		tst.b	$FFFFFE08.w	; is debug mode	being used?
		beq.s	Obj01_Normal	; if not, branch
		pea	DebugMode
		bra	ExtCam_Center
; ===========================================================================

Obj01_Normal:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj01_Index(pc,d0.w),d1
		jmp	Obj01_Index(pc,d1.w)
; ===========================================================================
Obj01_Index:	dc.w Obj01_Main-Obj01_Index
		dc.w Obj01_Control-Obj01_Index
		dc.w Obj01_Hurt-Obj01_Index
		dc.w Obj01_Death-Obj01_Index
		dc.w Obj01_ResetLevel-Obj01_Index
; ===========================================================================

Obj01_Main:				; XREF: Obj01_Index
		move.b	#0,Path_ID			; MJ: set collision to 1st
		move.b	#$8F,Tails_Tail_RAM		; load Tail's Tail
		move.b	#$90,Shield_RAM			; load instashield
		sf	Sonic_ForceRollMode
		move.b	#$8E,SpinDust_RAM
		addq.b	#2,Routine(a0)
		move.w	#$780,Art_Tile(a0)
		move.b	#2,Priority(a0)
		move.b	#$18,X_Visible(a0)
		move.b	#4,Render_Flags(a0)

		sf	$FFFFFE2E.w
		bsr	Sonic_Setspeed
		jsr	SetPlayerDisplay

Obj01_Control:					; XREF: Obj01_Index
		tst.b	Debug_Mode.w		; is debug cheat enabled?
		beq.s	loc_12C58		; if not, branch
		btst	#4,($FFFFF605).w	; is button C pressed?
		beq.s	loc_12C58		; if not, branch
		move.b	#2,$FFFFFE08.w		; change Sonic into a ring/item
		sf	($FFFFF7CC).w
Obj01_rts123:
		rts
; ===========================================================================

loc_12C58:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc_12C64	; if yes, branch
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc_12C64:
		btst	#0,($FFFFF7C8).w ; are controls	locked?
		bne	loc_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	Status(a0),d0
		andi.w	#6,d0
		move.w	Obj01_Modes(pc,d0.w),d1
		jsr	Obj01_Modes(pc,d1.w)

loc_12C7E:
		bsr	ExtCam
		bsr	Sonic_Display
		bsr	Sonic_KillEnemies
		bsr	Sonic_RecordPos
		bsr	Sonic_Water
		move.b	($FFFFF768).w,Off36(a0)
		move.b	($FFFFF76A).w,Off37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc_12CA6
		tst.b	Anim(a0)
		bne.s	loc_12CA6
		move.b	Anim_Restart(a0),Anim(a0)

loc_12CA6:
		bsr	SwitchChar
		bsr.w	Sonic_Animate
		tst.b	($FFFFF7C8).w
		bmi.s	loc_12CB6
		jsr	TouchResponse

loc_12CB6:
		bra.w	LoadSonicDynPLC
; ===========================================================================
Obj01_Modes:	dc.w Obj01_MdNormal-Obj01_Modes
		dc.w Obj01_MdJump-Obj01_Modes
		dc.w Obj01_MdRoll-Obj01_Modes
		dc.w Obj01_MdRollJump-Obj01_Modes

; ===========================================================================
SwitchChar:
		tst.l	($FFFFF680).w
		bne.s	SWrts
		cmpi.b	#$34,Ttlcard_RAM.w	; if title cards are on, prohibit
		beq.s	SWrts
		move.b	$FFFFF603,d0		; check button presses
		and.b	#CharBtn,d0		; are we pressing A buttons?
		beq	SWrts			; if we are not, branch
		moveq	#0,d0
		move.b	Current_Character.w,d0; store character number to stack
		move.w	d0,-(sp)

		tst.b	Player_DoubleJump	; is player doing doublejump move?
		beq.s	SW_chknext		; if not, branch

Switch_err:
		addq.l	#2,sp			; clear character from stack
		moveq	#$FFFFFF80+$19,d0
		jmp	PlaySound
SWrts		rts

SW_CharToTable	dc.w 2, 4, 0
SW_CharBitTable	dc.w -1, Bought_Knux, Bought_Tails

SW_chknext:
		moveq	#0,d0
		move.b	Current_Character.w,d0	; get current character
		move.w	SW_CharToTable(pc,d0.w),d0; change to next entry
		move.b	d0,Current_Character.w	; save

		move.w	(sp),d1
		cmp.b	d0,d1			; check if looped all characters
		beq.s	Switch_err		; if had, exit with error

		move.l	Bought_Items,d6
		move.w	SW_CharBitTable(pc,d0.w),d1; get bought item test bit
		bmi.s	.ok			; if negative, not buyable item
		btst	d1,d6			; check if bought
		beq.s	SW_chknext		; if not, check next

.ok		bsr	Sonic_Setspeed		; set speed and display of character
		jsr	SetPlayerDisplay

		move.b	#0,Off2C(a0)
		move.b	#0,Anim_Restart(a0)
		cmpi.b	#2,Current_Character	; is tails?
		bne	.doexplo		; if is, branch
		move.b	#$F,Y_Radius(a0)	; set radius for Tails
		move.b	#9,X_Radius(a0)		; ^

.doexplo	jsr	SingleObjLoad		; load object
		bne	.noExpo			; if none could be loaded, branch
		move.b	#$27,(a1)		; load "explosion from a destroyed enemy"
		move.b	#2,Routine(a1)		; set suboutine (Eplosion smoke
		move.w	X_Pos(a0),X_Pos(a1)	; set position
		move.w	Y_Pos(a0),Y_Pos(a1)	; ^

		moveq	#0,d0
		move.b	X_Vel(a0),d0		; get x speed
		add.b	d0,X_Pos+1(a1)		; add pixels to x pos
		move.b	Y_Vel(a0),d0		; same for y
		add.b	d0,Y_Pos+1(a1)

.noExpo		addq.l	#2,sp			; clear character from stack
		moveq	#0,d0
		move.b	Current_Character,d0	; get char
		addi.w	#13,d0			; add 14
		jmp	LoadPLC			; load the PLC

Sonic_Display:				; XREF: loc_12C7E
		move.w	Off30(a0),d0
		beq.s	Obj01_Display
		subq.w	#1,Off30(a0)
		lsr.w	#3,d0
		bhs.s	Obj01_ChkInvin

Obj01_Display:
		jsr	DisplaySprite

Obj01_ChkInvin:
		tst.b	($FFFFFE2D).w	; does Sonic have invincibility?
		beq.s	Obj01_ChkShoes	; if not, branch
		tst.w	Off32(a0)		; check	time remaining for invinciblity
		beq.s	Obj01_ChkShoes	; if no	time remains, branch
		subq.w	#1,Off32(a0)	; subtract 1 from time
		bne.s	Obj01_ChkShoes
		tst.b	($FFFFF7AA).w
		bne.s	Obj01_RmvInvin
		cmpi.w	#$C,($FFFFFE14).w
		blo.s	Obj01_RmvInvin
		moveq	#0,d0
		move.b	Music_StoreZoneID,d0
		jsr	PlayMusic	; play normal music

Obj01_RmvInvin:
		move.b	#0,($FFFFFE2D).w ; cancel invincibility
		cmpi.b	#16,Shield_Type
		bne	Obj01_ChkShoes
                lea	Comp_Sparks,a2			; sparks graphics
		move.l	#$6C000002,d6			; VRAM location
		jmp	CompDecToVRAM			; decompress
Obj01_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Sonic have speed	shoes?
		beq.s	Obj01_ExitChk	; if not, branch
		tst.w	Off34(a0)		; check	time remaining
		beq.s	Obj01_ExitChk
		subq.w	#1,Off34(a0)	; subtract 1 from time
		bne.s	Obj01_ExitChk
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		bsr	Sonic_Setspeed
		move.w	#$E3,d0
		jmp	PlayMusic_Speed	; run music at normal speed
; ===========================================================================
Obj01_ExitChk:
		rts
; ---------------------------------------------------------------------------
; Subroutine to make Sonic invincible if he goes faster than certain speed
; ---------------------------------------------------------------------------
Sonic_KillEnemies:
                btst	#1,Status(a0)		; check if in air
                bne	Sonic_KillEnemies_Air	; if is, check air movement
                move.w	#$B30,d1		; put the inertia needed to apply in d1
		move.w  Inertia(a0),d0		; put inertia to d0
                bpl.s   KM_Chk			; if positive, branch
                neg.w   d0			; negative to positive
KM_Chk:
		cmp.w	d1,d0			; compare speed to required speed
                blo.s   Sonic_killEnemies_NoInvin; if less than, no invin
Sonic_killEnemies_Invin:
                move.b	#1,FastInvis	; give Sonic invincibility
                rts
Sonic_killEnemies_NoInvin:
                move.b	#0,FastInvis	; remove Sonic's invincibility
                rts
; in air
Sonic_KillEnemies_Air:
		move.w  X_Vel(a0),d0	; put X velocity to d0
                bpl.s   .c		; if positive, branch
                neg.w   d0		; egative to positive
.c              cmpi.w  #$930,d0	; check if we go fast enough
                bhs.s   Sonic_killEnemies_Invin; if we do, grant invinsiblity
                move.w  #$6A0,d1	; put the Y velocity needed to apply in d1
                move.w  Y_Vel(a0),d0	; put Y velocity to d0
                bpl	KM_Chk		; if positive, branch
                neg.w   d0		; negative to positive
.a		bra	KM_Chk		; Branch

; ---------------------------------------------------------------------------
; Subroutine to	record Sonic's previous positions for invincibility stars
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RecordPos:			; XREF: loc_12C7E; Obj01_Hurt; Obj01_Death
		move.w	($FFFFF7A8).w,d0
		lea	($FFFFCB00).w,a1
		lea	(a1,d0.w),a1
		move.w	X_pos(a0),(a1)+
		move.w	Y_Pos(a0),(a1)+
		addq.b	#4,($FFFFF7A9).w
		rts
; End of function Sonic_RecordPos

; ---------------------------------------------------------------------------
; Subroutine for Sonic when he's underwater
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Water:				; XREF: loc_12C7E
		tst.l	Water_Array.w	; check if has water
		bpl.w	Obj01_InWater	; if yes, branch

locret_12D80:
		rts
; ===========================================================================

Obj01_InWater:
		move.w	($FFFFF646).w,d0
		cmp.w	Y_Pos(a0),d0	; is Sonic above the water?
		bge.s	Obj01_OutWater	; if yes, branch
		bset	#6,Status(a0)
		bne.s	locret_12D80
		bsr.w	ResumeMusic
		move.b	#$A,Bubbles_RAM ; load bubbles object	from Sonic's mouth
		move.b	#$81,Bubbles_RAM+Subtype
		bsr	Sonic_Setspeed
		asr	X_Vel(a0)
		asr	Y_Vel(a0)
		asr	Y_Vel(a0)
		beq.s	locret_12D80
		move.b	#8,Splash_RAM ; load	splash object
		move.w	#$AA,d0
		jmp	(PlaySound).l ;	play splash sound
; ===========================================================================

Obj01_OutWater:
		bclr	#6,Status(a0)
		beq.s	locret_12D80
		bsr.w	ResumeMusic
		bsr	Sonic_Setspeed
		asl	Y_Vel(a0)
		beq.w	locret_12D80
		move.b	#8,Splash_RAM ; load	splash object
		cmpi.w	#-$1000,Y_Vel(a0)
		bgt.s	loc_12E0E
		move.w	#-$1000,Y_Vel(a0)	; set maximum speed on leaving water

loc_12E0E:
		move.w	#$AA,d0
		jmp	(PlaySound).l ;	play splash sound
; End of function Sonic_Water
; ===========================================================================
; ---------------------------------------------------------------------------
; logic for extended camera
; ---------------------------------------------------------------------------

ExtCam:
       		buytest	Bought_ExtCam		; is extended camera on?
                beq	ExtCam_Center		; if not, see if camera position needs to be fixed

		tst.b	If_Spindash		; are we spindashing?
		bne	.movetoside		; if we are, branch
		tst.b	PeelOut_Flag		; are we peelouting?
		beq	.no			; if not, branch

.movetoside	btst	#0,Status(a0)		; check Sonic's direction
		beq	.extcamtoright		; if facing right, move camera to right
		bne	.extcamtoleft		; if facing left, move camera to left

.no		move.w	#$450,d1		; speed if in air
                move.w  X_Vel(a0),d0		; as well as velocity
                btst	#1,Status(a0)		; are we not in air?
                bne	.con			; if we are, branch
                move.w	#$500,d1		; speed if in ground
                move.w  Inertia(a0),d0		; ground speed
.con		tst.w	d0			; test d0
                bpl	.positive		; branch if positive

                neg.w	d1			; positive to negative
 		cmp.w	d1,d0			; compare between required speed and current speed
                bge	ExtCam_Center		; if you are going too slow branch away

.extcamtoleft	subq.b  #2,Extcam_pos		; move camera to left
                cmpi.b  #-$38,Extcam_pos	; check the max pos
                bge	.ext2			; if less, branch
                move.b  #-$38,Extcam_pos	; limit the camera
.ext2		rts

.positive	cmp.w	d1,d0			; compare between required speed and current speed
                ble	ExtCam_Center		; if you are going too slow branch away

.extcamtoright	addq.b  #2,Extcam_pos		; move camera to right
                cmpi.b  #$38,Extcam_pos		; check the max pos
                ble	.ext			; if less, branch
                move.b  #$38,Extcam_pos		; limit the camera
.ext		rts

ExtCam_Center:
                tst.b   Extcam_pos		; check the position
                beq	ExtCam_Exit		; if centered, exit
                bpl	.left			; if positive, branch
                addq.b  #4,Extcam_pos		; move to right
.left		subq.b  #2,Extcam_pos		; move to left

ExtCam_Exit:
                rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Sonic
; ---------------------------------------------------------------------------
Obj01_MdNormal:				; XREF: Obj01_Modes
		bsr	Sonic_SpeelOut
		bsr	Sonic_SpinDash
		bsr	Sonic_Jump
		bsr	Sonic_SlopeResist
		bsr	Sonic_Move
		bsr	Sonic_Roll
		bsr	Sonic_LevelBound
		jsr	ObjectMove
		jsr	Sonic_AnglePos
		bsr	Sonic_SlopeRepel
		rts
; ===========================================================================
Obj01_MdJump:				; XREF: Obj01_Modes
		bsr	Player_JumpMoves
		bsr.w	Sonic_JumpHeight
		bsr.w	Sonic_ChgJumpDir
		bsr.w	Obj01_SuperFly
		bsr.w	Sonic_LevelBound
		bsr	Player_Gravity
		bsr.w	Sonic_JumpAngle
		bsr.w	Sonic_Floor
		rts
; ===========================================================================
Obj01_MdRoll:				; XREF: Obj01_Modes
		bsr.w	Sonic_Jump
		bsr.w	Sonic_RollRepel
		bsr.w	Sonic_RollSpeed
		bsr.w	Sonic_LevelBound
		jsr	ObjectMove
		jsr	Sonic_AnglePos
		bsr.w	Sonic_SlopeRepel
		rts
; ===========================================================================
Obj01_MdRollJump:			; XREF: Obj01_Modes
		bsr	Player_JumpMoves
		bsr.w	Sonic_JumpHeight
		bsr.w	Sonic_ChgJumpDir
		bsr.w	Obj01_SuperFly
		bsr.w	Sonic_LevelBound
		bsr	Player_Gravity
		bsr.w	Sonic_JumpAngle
		bsr.w	Sonic_Floor
RJ_End		rts
; ===========================================================================
Player_Gravity:
		tst.b	Sonic_SuperFly.w
		bmi.s	.move

		jsr	ObjectFall		; default gravity
		btst	#6,Status(a0)		; are we underwater?
		beq	.NoUnderwater		; if not, branch
		subi.w	#$28,Y_Vel(a0)		; apply gravity changes

                btst	#6,Player_DoubleJump	; are we swimming?
		beq	.end			; if not, branch
		subi.w	#$C,Y_Vel(a0)		; apply gravity changes
		rts

.NoUnderwater	btst	#6,Player_DoubleJump	; are we flying?
		beq	.end			; if not, branch
		subi.w	#$30,Y_Vel(a0)		; apply gravity changes

.end		rts

.move		jmp	ObjectMove
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to do mid-jump moves for players
; ---------------------------------------------------------------------------
Player_JumpMoves:
		tst.b	Sonic_SuperFly.w
		bmi.s	RJ_End
		tst.b	Player_DoubleJump	; is player doing dooublejump move?
		beq	RJ_End			; if not, branch
		moveq	#0,d0
		move.b	Current_Character,d0	; get character id
		move.w	.Index(pc,d0.w),d1	; get index
		jmp	.Index(pc,d1.w)		; jump to correct routine handler
; ===========================================================================

.Index:		dc.w Sonic_InstaShieldMoves-.Index
		dc.w TailsFly-.Index
		dc.w Knux_GlideMain-.Index
; ===========================================================================

Knux_NoGlide:
		sf	Player_DoubleJump	; stop doubejumping

Sonic_InstaShieldMoves:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; moving Sonic up and down when flying
; ---------------------------------------------------------------------------
Obj01_SuperFly:
		tst.b	Sonic_SuperFly.w
		bpl.s	Sonic_InstaShieldMoves
		move.w	#0,Y_Vel(a0)		; clear Y-Velocity
		move.b	#1,Anim(a0)

		btst	#0,$FFFFF602.w	; is up being pressed?
		beq.s	.chkdwn		; if not, branch
		subq.w	#5,Y_Pos(a0)	; move up

.chkdwn		btst	#1,$FFFFF602.w	; is down being pressed?
		beq.s	.rts		; if not, branch
		addq.w	#5,Y_Pos(a0)	; move down

.rts		rts
; ===========================================================================
Knux_GlideMain:
		buytest Bought_SpinDash
		beq	RJ_End
		addq.l  #4,sp			; skip rest of Sonic control routines
		bsr.w   Extcam_center		; move the camera to center
                bsr.w	Knuckles_GlideSpeedControl; control gliding
		bsr.w	Sonic_LevelBound	; keep Sonic within level boundaries
		jsr	ObjectMove		; make Sonic able to move

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to control player actions while gliding
; ---------------------------------------------------------------------------
Knuckles_GlideControl:
		move.b	Gliding_Main.w,d0	; get gliding state
		beq	Knux_NoGlide		; if 0, stop trying to glide
		cmp.b	#2,d0			; is 2?
		beq	Knuckles_FallingFromGlide; if is, fall from glide
		cmp.b	#3,d0			; is 3?
		beq	Knuckles_Sliding	; if is, slide across floor
		cmp.b	#4,d0			; is 4?
		beq	Knuckles_Climbing_Wall	; if is, climb wall
		cmp.b	#5,d0			; is 5?
		beq	Knuckles_Climbing_Up	; if is, climb up to a ledge

Knuckles_NormalGlide:				; is 1!
		move.w	#$A0A,Y_Radius(a0)	; set size
		bsr	Glide_Collide		; collide with floor/ceiling/walls while gliding

		btst	#5,Gliding_2.w		; do we want to start climbing?
		bne	Knuckles_BeginClimb	; if that is the case, branch
		move.w	#$1309,Y_Radius(a0)	; set size

		btst	#1,Gliding_2.w		; should we slide across floor?
		beq	Knuckles_BeginSlide	; if yes, branch
		move.b	$FFFFF602.w,d0		; check button presses
		and.b	#JumpBtns,d0			; are we pressing A/B/C buttons?
		bne	K_SetAnim		; if we are, branch

		move.b	#2,Gliding_Main.w	; start falling
		move.b	#$21,Anim(a0)		; set animation
		bclr	#0,Status(a0)		; set Sonic to facing right
		tst.w	X_Vel(a0)		; check which way he is moving
		bpl	.NoRight		; if he is going forwards, branch
		bset	#0,Status(a0)		; set Sonic to facing left

.NoRight	asr	X_Vel(a0)		; slow down
		asr	X_Vel(a0)		; slow down
		move.w	#$1309,Y_Radius(a0)	; set size
		rts
; ===========================================================================

Knuckles_BeginSlide:
		bclr	#0,Status(a0)		; set Sonic to facing right
		tst.w	X_Vel(a0)		; check which way he is moving
		bpl	.NoRight		; if he is going forwards, branch
		bset	#0,Status(a0)		; set Sonic to facing left

.NoRight	move.b	Angle(a0),d0		; get angle
		add.b	#$20,d0			; add $20
		and.b	#$C0,d0			; mask against $C0
		beq	.StartSlide		; if 0 (?) branch
		move.w	Inertia(a0),X_Vel(a0)	; set inertia to X velocity
		move.w	#0,Y_Vel(a0)		; clear Y velocity
		bra	Knux_ResetOnFloor	; set Knuckles to Flor

.StartSlide	move.b	#3,Gliding_Main.w	; set to slide
		move.b	#$CC,Anim_Frame(a0)	; set animation frame
		move.b	#$7F,Anim_Dur(a0)	; and duration
		sf	Anim_scriptNum(a0)

		move.b  #$15,SpinDust_RAM+Anim_Frame.w	; ^
                move.b	#$97,d0			; play sliding sound
                jmp     PlaySound	; ^

return_3157AC:
		rts
; ===========================================================================

Knuckles_BeginClimb:
		tst.b	Player_DJ_Data
		bmi	K_StartFall
		move.b	#$D,d5			; set collision type
		move.b	Glide_AnimHandler,d0	; get animation handler data to d0 (to determine which way should we face)
		add.b	#$40,d0			; add $40 to d0
		bpl	.NotLeft		; if d0 is positive, branch
		bset	#0,Status(a0)		; set Sonic to facing right
		bsr	CheckLeftceilingDist	; check for left ceiling
		or.w	d0,d1			; set bits on d1 according to bits set on d0 or d1
		bne	Knuckles_AdjustFallPosLeft; branch if we are not colliding with wall
		addq.w	#1,X_pos(a0)		; add 1 to X position
		bra	K_Common		; branch away

.NotLeft	bclr	#0,Status(a0)		; set Sonic to facing left
		bsr	CheckRightceilingDist	; check for Right ceiling
		or.w	d0,d1			; set bits on d1 according to bits set on d0 or d1
		bne	Knuckles_AdjustFallPosRight; branch if we are not colliding with wall

K_Common	move.b	#$13,Y_Radius(a0)	; set size
		move.b	#9,X_Radius(a0)		; ^
		move.b	#-1,GlidingCollTimer	; make sure we wont loop back to positive
		move.b	#$98,d0			; get hitting wall sound
                jsr     PlaySound	; play it
		move.w	#0,Inertia(a0)		; clear inertia
		move.l	#0,X_Vel(a0)		; clear X&Y velocities
		move.b	#4,Gliding_Main	; start climbing
		move.b	#$B7,Anim_Frame(a0)	; set animation
		move.b	#$7F,Anim_Dur(a0)	; set duration
		sf	Anim_scriptNum(a0)
		move.b	#3,Glide_AnimHandler.w
		move.w	X_Pos(a0),X_Pos2(a0)	; save X position
		rts
; ===========================================================================

Knuckles_AdjustFallPosLeft:
		move.w	X_Pos(a0),d3		; get X position
		move.b	Y_Radius(a0),d0		; get vertical radius
		ext.w	d0			; extend the radius to word value
		sub.w	d0,d3			; subtract radius from X position
		subq.w	#1,d3			; subtract 1 from X position

K_ChkFloor	move.w	Y_Pos(a0),d2		; get Y position
		sub.w	#$B,d2			; subtract $B from it
		jsr	ObjHitFloor2		; see if we should be hitting floor
		tst.w	d1			; are we?
		bmi	K_StartFall		; if not, branch
		cmp.w	#$C,d1			; check $C from d1
		bhs	K_StartFall		; if higher or same, branch
		add.w	d1,Y_pos(a0)		; add d1 to Y position
		bra	K_Common		; start climbing
; ===========================================================================

Knuckles_AdjustFallPosRight:
		move.w	X_Pos(a0),d3		; get X position
		move.b	Y_Radius(a0),d0		; get vertical radius
		ext.w	d0			; extend the radius to word value
		add.w	d0,d3			; add radius to X position
		addq.w	#1,d3			; add 1 to X position
		bra	K_ChkFloor		; check collision

K_StartFall:
		move.b	#2,Gliding_Main.w	; set to fall
		move.b	#$21,Anim(a0)		; set animation
		move.w	#$1309,Y_Radius(a0)	; set size
		bset	#1,Gliding_2.w
		rts
; ===========================================================================

Knuckles_FallingFromGlide:
		bsr	Sonic_ChgJumpDir	; allow Sonic to change direction
		add.w	#$38,Y_Vel(a0)		; make him able to fall
		btst	#6,Status(a0)		; are we underwater?
		beq	.NoUnderwater		; if not, branch
		sub.w	#$28,Y_Vel(a0)		; fall slower

.NoUnderwater	bsr	Glide_Collide		; collide with floor/ceiling/walls while gliding
		btst	#1,Gliding_2	; is bit 1 set?
		bne	K_Return		; if is (?), branch
		move.w	#0,Inertia(a0)		; clear inertia
		move.l	#0,X_Vel(a0)		; clear X&Y velocities
		move.b	Y_Radius(a0),d0		; get vertical radius
		sub.b	#$13,d0			; subtract $13 from d0
		ext.w	d0			; extend the radius to word value
		add.w	d0,Y_pos(a0)		; add d0 to Y position
		move.b	Angle(a0),d0		; get angle
		add.b	#$20,d0			; add $20
		and.b	#$C0,d0			; mask against $C0
		bne	Knux_ResetOnFloor	; if not 0 (?) branch

loc_3158F0:
		bsr	Knux_ResetOnFloor	; reset on floor
		move.b	#$98,d0			; get landing sound
                jsr     PlaySound	; play it
		move.w	#$F,Off3E(a0)		; set delay for being able to move
		move.b	#$23,Anim(a0)		; and animation

K_return	rts
; ===========================================================================

Knuckles_Sliding:
		move.b	$FFFFF602.w,d0		; check buttons pressed
		and.b	#JumpBtns,d0			; filter out everything but A/B/C
		beq	.Common			; if none are pressed, branch

		tst.w	X_Vel(a0)		; test velocity
		bpl	.Right			; if going right, branch
		add.w	#$20,X_Vel(a0)		; increase velocity
		bmi	.ContinueSlide		; if negative, branch
		bra	.Common			; branch

.Right		sub.w	#$20,X_Vel(a0)		; decrease velocity
		bpl	.ContinueSlide		; if positive, branch

.Common		move.w	#0,Inertia(a0)		; clear inertia
		move.l	#0,X_Vel(a0)		; clear X&Y velocities
		move.b	Y_Radius(a0),d0		; get vertical radius
		sub.b	#$13,d0			; subtract $13 from d0
		ext.w	d0			; extend the radius to word value
		add.w	d0,Y_pos(a0)		; add d0 to Y position
		bsr	Knux_ResetOnFloor	; reset on floor
		move.w	#$F,Off3E(a0)		; set delay for being able to move
		move.b	#$22,Anim(a0)		; set animation
		rts

.ContinueSlide	move.w	#$A0A,Y_Radius(a0)	; set size
		bsr	Glide_Collide		; collide with floor/ceiling/walls while sliding
		jsr	Sonic_HitFloor		; check if we are hitting the floor
		cmp.w	#$E,d1			; ^
		bge	.StartFall		; branch if we are not
		add.w	d1,Y_pos(a0)		; add it to our Y position (se we are in right position on floor)
		move.b	d3,Angle(a0)		; set our angle as well
		move.w	#$1309,Y_Radius(a0)	; set size
		rts

.StartFall	move.b	#2,Gliding_Main	; set our state to falling
		move.b	#$20,Anim(a0)		; and set our animation
		move.w	#$1309,Y_Radius(a0)	; set size
		bset	#1,Gliding_2
K_rts		rts
; ===========================================================================

Knuckles_Climbing_Wall:
		tst.b	Player_DJ_Data
		bmi	K_StartFall2
		move.w	X_Pos(a0),d0		; move X position to d0
		cmp.w	X_Pos2(a0),d0		; compare with subpixel coordinates
		bne	K_StartFall2		; if not equal, branch
		btst	#3,Status(a0)		; is Sonic standing on an object?
		bne	K_StartFall2		; if is, branch
		move.w	#0,Inertia(a0)		; clear inertia
		move.l	#0,X_Vel(a0)		; clear X&Y velocities
                bsr	Sonic_GetCollisionLayer	; get the correct collision layer
		move.b	#$D,d5			; set collision type
		move.w	#$A0A,Y_Radius(a0)	; set size
		moveq	#0,d1
		btst	#0,$FFFFF602.w		; is up being pressed?
		beq	K_ClimbDown		; if not, branch
		subq.b	#1,GlidingCollTimer	; should we stop climbing?
		bpl	K_Climb_Common_2	; if yes, branch
		move.b	#-1,GlidingCollTimer	; make sure we wont loop back to positive
		move.w	Y_Pos(a0),d2		; get Y position
		sub.w	#$B,d2			; subtract $B from Y pos
		bsr	sub_315C22
		cmp.w	#4,d1			; is Sonic above the wall?
		bge	Knuckles_ClimbUp	; if is, branch
		tst.w	d1			; is d1 0?
		bne	K_Climb_SkipAnim	; if is, branch
		move.b	#$D,d5			; set collision type
		move.w	Y_Pos(a0),d2		; get Y position to d2
		subq.w	#8,d2			; subtract 8 from it
		move.w	X_Pos(a0),d3		; get X position to d3
		bsr	K_FindFloor2		; Doesn't exist in S2
		tst.w	d1			; test d1
		bpl	K_ClimbUp_NoClimb	; if it's positive, branch
		sub.w	d1,Y_pos(a0)		; subtract d1 from Y position
		moveq	#1,d1			; move 1 to d1
		bra	K_Climb_Common		; branch away

K_ClimbUp_NoClimb:
		subq.w	#1,Y_pos(a0)		; subtract 1 from Y position
K_Climb_Common_2:
		moveq	#1,d1
		move.w	$FFFFF72C,d0		; get max screen pos to d0
		cmp.w	#$FF00,d0		; is vertical wrapping enabled?
		beq	K_Climb_Common		; if is, branch
		add.w	#$10,d0			; add $10 to d0
		cmp.w	Y_Pos(a0),d0		; compare Y position with d0
		ble	K_Climb_Common		; if less than, branch
		move.w	d0,Y_pos(a0)		; move d0 to Y position
		bra	K_Climb_Common		; branch away
; ===========================================================================

K_ClimbDown:
		btst	#1,$FFFFF602		; is down being pressed?
		beq	K_Climb_Common		; if not, branch
		cmp.b	#$BD,Anim_Frame(a0)	; is anim frame $BD
		bne	.Right			; if not, branch
		move.b	#$B7,Anim_Frame(a0)	; set frame to $B7
		addq.w	#3,Y_pos(a0)		; add 3 to Y position
		subq.w	#3,X_pos(a0)		; subtract 3 X position
		btst	#0,Status(a0)		; is Sonic facing right?
		beq	.Right			; if is, branch
		addq.w	#6,X_pos(a0)		; add 6 to X position

.Right		move.b	#-1,GlidingCollTimer	; make sure we wont loop back to positive
		move.w	Y_Pos(a0),d2		; move Y position to d2
		add.w	#$B,d2			; add $B to d2
		bsr	sub_315C22
		tst.w	d1			; is d1 0?
		bne	K_StartFall2		; if is, branch
		move.b	#$D,d5			; set collision type
		move.w	Y_Pos(a0),d2		; move Y position to d2
		add.w	#9,d2			; add 9 to d2
		move.w	X_Pos(a0),d3		; move X position to d3
		bsr	K_FindFloor
		tst.w	d1			; test d1
		bpl	K_ClimbDown_NoClimb	; is is positive, branch
		add.w	d1,Y_pos(a0)		; add d1 to Y position
		move.b	$FFFFF768,Angle(a0)
		move.w	#0,Inertia(a0)		; clear inertia
		move.l	#0,X_Vel(a0)		; clear X&Y velocities
		bsr	Knux_ResetOnFloor	; reset on floor
		move.b	#5,Anim(a0)		; set to standing animation
		rts

K_ClimbDown_NoClimb:
		addq.w	#1,Y_pos(a0)		; add 1 from Y position
		moveq	#-1,d1

K_Climb_Common:
		tst.w	d1			; is d1 0?
		beq	K_Climb_SkipAnim	; if is (?), branch
		subq.b	#1,Glide_AnimHandler	; sub 1 from animation handler
		bpl	K_Climb_SkipAnim	; if positive, branch
		move.b	#3,Glide_AnimHandler	; move 3 to animatin handler
		add.b	Anim_Frame(a0),d1	; add animation frame to d1
		cmp.b	#$B7,d1			; is anim d1 $B7?
		bhs	.2			; if higher or same, branch
		move.b	#$BC,d1			; move $BC to d1

.2		cmp.b	#$BC,d1			; is d1 $BC
		bls	.3			; if less or same, branch
		move.b	#$B7,d1			; set d1 to $B7

.3		move.b	d1,Anim_Frame(a0)	; move d1 to Anim Frame

K_Climb_SkipAnim:
		move.b	#$20,Anim_Dur(a0)	; set animation duration
		sf	Anim_scriptNum(a0)
		move.w	#$1309,Y_Radius(a0)	; set size
		move.w	$FFFFF602,d0		; get button presses
		and.w	#JumpBtns,d0			; filter everything but A/B/C
		beq	return_315B94		; if none are pressed, branch

		move.w	#-$380,Y_Vel(a0)	; make Sonic jump
		move.w	#$400,X_Vel(a0)		; set X velocity
		bchg	#0,Status(a0)		; is Sonic facing right?
		bne	.Right			; if is, branch
		neg.w	X_Vel(a0)		; negate X velocity

.Right		bset	#1,Status(a0)		; set Sonic to being in air
		move.b	#1,Off3C(a0)		; set Sonic's jumping flag
		move.w	#$E07,Y_Radius(a0)	; set size
		move.b	#2,Anim(a0)		; set to rolling animation
		bset	#2,Status(a0)		; set jumping bit
		sf	Gliding_Main.w		; stop gliding

return_315B94:
		rts
; ===========================================================================

Knuckles_ClimbUp:
		move.b	#5,Gliding_Main	; make Sonic climb up to floor
	;	move.w	X_Pos(a0),Knux_StoreXYPos
               ; move.w	Y_Pos(a0),Knux_StoreXYPos+2
		cmp.b	#$BD,Anim_Frame(a0)	; is animation frame $BD?
		beq	return_315BAC		; if is, branch
		move.b	#0,Glide_AnimHandler	; clear animation handler
		bra	K_UseAnimHandler

return_315BAC:
		rts

K_StartFall2:
		move.b	#2,Gliding_Main	; set to glide
		move.w	#$2121,Anim(a0)		; set animation
		move.b	#$CB,Anim_Frame(a0)	; set anim frame
		move.b	#7,Anim_Dur(a0)		; duration
		move.b	#1,Anim_scriptNum(a0)
		move.w	#$1309,Y_Radius(a0)	; set size
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to handle special animations for player
; and move Knuckles while climbing to a ledge
; ---------------------------------------------------------------------------
K_UseAnimHandler:
		moveq	#0,d0
		move.b	Glide_AnimHandler,d0	; get anim handler to d0
		lea	.AniHandlerData(pc,d0.w),a1; get address based on d0
		move.b	(a1)+,Anim_Frame(a0)	; move first byte to anim frame
		move.b	(a1)+,d0		; move next byte to d0
		ext.w	d0			; extend to word
		btst	#0,Status(a0)		; is sonic facing right
		beq	.Right			; if is, branch
		neg.w	d0			; negate d0

.Right		add.w	d0,X_pos(a0)		; add it to X pos
		move.b	(a1)+,d1		; move next byte to d1
		ext.w	d1			; extend it to word value
		add.w	d1,Y_pos(a0)		; add to Y pos
		move.b	(a1)+,Anim_Dur(a0)	; set duration
		addq.b	#4,Glide_AnimHandler	; set to next value
		move.b	#0,Anim_scriptNum(a0)
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; animation handler byte array
;
; 4 bytes for each entry
; animation frame, addition to X position, addition to Y position, animation duration
; ---------------------------------------------------------------------------
.AniHandlerData	dc.b $BD, 3,   -3, 6
		dc.b $BE, 8,  -$A, 6
		dc.b $BF, $F8,-$C, 6
		dc.b $D2, 8,   -5, 6
; ===========================================================================

sub_315C22:
		move.b	#$D,d5			; set collision type
		move.w	X_Pos(a0),d3		; get X position
		btst	#0,Status(a0)		; is Sonic facing right?
		beq	K_FindWall		; if not, branch (?)
		subq.w	#1,d3			; subtract 1 from d3
		bra	K_FindWall2		; branch away

Knuckles_Climbing_Up:
		tst.b	Anim_Dur(a0)		; test anim duration
		bne	return_315C7A		; if is 0, branch
		bset	#7,$FFFFF7C8.w		; stop colliding with enemies/objects (so you can climb up to a ledge even if there is solid block)
		bsr	K_UseAnimHandler	; make Sonic climb up to ledge
		cmp.b	#16,Glide_AnimHandler	; is the handler 16?
		bne	return_315C7A		; if not, branc
		move.w	#0,Inertia(a0)		; clear inertia
		move.l	#0,X_Vel(a0)		; clear X&Y velocities
		bclr	#7,$FFFFF7C8		; start colliding with enemies/objects
		btst	#0,Status(a0)		; is Sonic facign right?
		beq	.NotRight		; if is, branch
		subq.w	#1,X_pos(a0)		; subtract 1 from X position

.NotRight	bsr	Knux_ResetOnFloor	; reset on floor
		move.b	#5,Anim(a0)		; set to standing animation

return_315C7A:
		rts
; ===========================================================================

K_SetAnim:
		move.b	#$20,Anim_Dur(a0)	; set animation duration
		move.b	#0,Anim_scriptNum(a0)
		move.w	#$2020,Anim(a0)		; set animation
		bclr	#5,Status(a0)		; stop pushing
		bclr	#0,Status(a0)		; face left
		moveq	#0,d0
		move.b	Glide_AnimHandler,d0	; get anim handler
		add.b	#16,d0			; add 16
		lsr.w	#5,d0			; shift bits left by 5 (divide by 64 (?))
		move.b	K_SA_AnimData(pc,d0.w),d1; get animation id based on d1
		move.b	d1,Anim_Frame(a0)	; set the frame
		bne	return_315CC0		; if not 0, branch
		bset	#0,Status(a0)		; set to face right
		move.b	#$C0,Anim_Frame(a0)	; set frame number

return_315CC0:
		rts
; ===========================================================================

K_SA_AnimData	dc.b $C0,$C1,$C2,$C3,0,$C3,$C2,$C1
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to control players speed while gliding, and testing for collision with walls or floor
; ---------------------------------------------------------------------------
Knuckles_GlideSpeedControl:
		cmp.b	#1,Gliding_Main
		bne	K_CenterCamera
		move.w	Inertia(a0),d0		; get inertia
		cmp.w	#$400,d0		; is it $400?
		bhs	.1			; if is same or more, branch
		addq.w	#8,d0			; add 8 to d0
		bra	.2			; branch away

.1		cmp.w	#$1800,d0		; is it $1800?
		bhs	.2			; if is same or more, branch
		move.b	Glide_AnimHandler,d1	; get anim handler
		and.b	#$7F,d1			; clear bits 1 and 7
		bne	.2			; if 0(?), branch
		addq.w	#4,d0			; add 4 to d0

.2		move.w	d0,Inertia(a0)		; move d0 to inertia
		move.b	Glide_AnimHandler,d1	; get anim handler
		btst	#2,$FFFFF602		; is left being pressed?
		beq	.ChkLeft		; if not, branch
		cmp.b	#$80,d1			; is d0 $80?
		beq	.ChkLeft		; if is, branch
		tst.b	d1			; test d0
		bpl	.positive		; if is positive, branch
		neg.b	d1			; negate d0

.positive	addq.b	#2,d1			; add 2 to d0
		bra	K_CalcVelocity		; branch away

.ChkLeft	btst	#3,$FFFFF602.w		; is right being pressed?
		beq	.3			; if not, branch
		tst.b	d1			; test d0
		beq	.3			; if 0, branch
		bmi	.Negative		; if negative, branch
		neg.b	d1			; positive to negative

.Negative	addq.b	#2,d1			; add 2 to d0
		bra	K_CalcVelocity		; branch away

.3		move.b	d1,d0			; move d0 to d1
		and.b	#$7F,d0			; clear bits 1 and 7
		beq	K_CalcVelocity		; if 0 (?), branch
		addq.b	#2,d1			; add 2 to d0

K_CalcVelocity:
		move.b	d1,Glide_AnimHandler	; save d0 to anim handler
		jsr	CalcSine		; calculate sine
		muls.w	Inertia(a0),d1		; multiply d1 with inertia
		asr.l	#8,d1			; shift bits left by 8 (divide by 256(?))
		move.w	d1,X_Vel(a0)		; move to X velocity
		cmp.w	#$80,Y_Vel(a0)		; is Y velocity $80?
		blt	.4			; if less, branch
		sub.w	#$20,Y_Vel(a0)		; subtract $20 from Y velocity
		bra	.CheckTopScrn		; branch away

.4		add.w	#$20,Y_Vel(a0)		; add $20 to Y velocity

.CheckTopScrn
		move.w	$FFFFF72C.w,d0		; get camera up limit
		cmp.w	#$FF00,d0		; is vertical wrapping enabled?
		beq	K_CenterCamera		; if is, branch
		add.w	#$10,d0			; add $10 to d0
		cmp.w	Y_Pos(a0),d0		; is it equal with Y position
		ble	K_CenterCamera		; if less than, branch
		asr	X_Vel(a0)		; slow down
		asr	Inertia(a0)		; slow down

K_CenterCamera:
		cmp.w	#$60,$FFFFF73E		; is sonic looking up/down?
		beq	.rts			; if not, bracnh
		bhs	.5			; if looking down, branch
		addq.w	#4,$FFFFF73E		; move camera down

.5		subq.w	#2,$FFFFF73E		; move camera up

.rts		rts
; ===========================================================================

K_FindFloor:
		move.b	X_Radius(a0),d0		; get X radius
		ext.w	d0			; extend to word
		add.w	d0,d2			; add d0 to d2
		lea	$FFFFF768,a4
		move.w	#$10,a3
		move.w	#0,d6			; clear d6
		bsr	FindFloor		; find out where floor is
		move.b	#0,d2			; clear low byte of d2
		bra	K_FindFloorWall_End	; branch away
; ===========================================================================

K_FindFloor2:
		move.b	X_Radius(a0),d0		; get X radius
		ext.w	d0			; extend to word
		sub.w	d0,d2			; sub d0 from d2
		eor.w	#$F,d2
		lea	$FFFFF768,a4
		move.w	#-$10,a3
		move.w	#$800,d6		; move $800 to d6
		bsr	FindFloor		; find out where floor is
		move.b	#$80,d2			; move $80 to low byte of d2
		bra	K_FindFloorWall_End	; branch away
; ===========================================================================

K_FindWall:
		move.b	X_Radius(a0),d0		; get X radius
		ext.w	d0			; extend to word
		add.w	d0,d3			; add d0 to d3
		lea	$FFFFF768,a4
		move.w	#$10,a3
		move.w	#0,d6			; clear low word of d2
		bsr	FindWall		; find nearest wall
		move.b	#$C0,d2			; move $C0 to low byte of d2
		bra	K_FindFloorWall_End	; branch away
; ===========================================================================

K_FindWall2:
		move.b	X_Radius(a0),d0		; get X radius
		ext.w	d0			; extend to word
		sub.w	d0,d3			; sub d0 from d3
		eor.w	#$F,d3
		lea	$FFFFF768,a4
		move.w	#-$10,a3
		move.w	#$400,d6		; move $400 to d6
		bsr	FindWall		; find nearest wall
		move.b	#$40,d2			; move $40 to low byte of d2
; ===========================================================================

K_FindFloorWall_End:
		move.b	$FFFFF768,d3
		btst	#0,d3			; test bit 0 of d3
		beq	KG_end			; if not set, branch
		move.b	d2,d3			; move low byte of d2 to d3

KG_end		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to do fly
; ---------------------------------------------------------------------------

TailsFly:
		buytest Bought_SpinDash
		beq	KG_end
		tst.w	Spindash_StorePitch	; is tails tired?
		beq	Fly_setAni		; if is, branch
	        subq.w	#1,Spindash_StorePitch	; if not, keep decreasing the counter

		btst	#7,Player_DoubleJump	; check if we should try to fly upwards
		beq	Fly_ChkUp		; if not, branch
		cmpi.w	#-$100,Y_Vel(a0)	; check if our speed is below -$100
		blt	Fly_NoUp		; if is, branch
		subi.w	#$1F,Y_Vel(a0)		; increase upwards momentum

		moveq	#0,d0
		move.b	Angle(a0),d0		; get our angle
		addi.b	#$80,d0			; rotate to left side

		bsr	Sonic_CheckFloorColl	; check if we are colliding with floor or ceiling
		cmpi.w	#6,d1			; ^
		bge	Fly_ChkUp		; if not, branch

		addq.b	#1,Player_DJ_Data-1	; add 1 to collision counter
		cmpi.b	#$10,Player_DJ_Data-1	; have we collided for past 16 frames?
		bne	Fly_SetAni		; if not, branch
Fly_NoUp:
		sf	Player_DJ_Data-1	; clear the collision counter
		bclr	#7,Player_DoubleJump	; stop flying upwards

Fly_ChkUp
		move.b	$FFFFF603,d0		; check the controller
		andi.b	#JumpBtns,d0			; read only A, B and C presses
		beq	Fly_SetAni		; if none was pressed, branch

		cmpi.w	#-$100,Y_Vel(a0)	; check if our speed is below -$100
		blt	Fly_SetAni		; if is, branch
		bset	#7,Player_DoubleJump	; start flying upwards
Fly_SetAni:
		move.b	#$1F,Anim(a0)		; set animation to $1F
		move.b	#$95,d0                 ; Flying sound
		tst.w	Spindash_StorePitch	; check if we are tired
		bne	.NotTired		; if we are not, branch

		addq.b	#1,d0			; add 1 to the flying sound (to get tired sound)
		addq.b	#1,Anim(a0)		; set animation to $20
.NotTired	btst	#6,Status(a0)		; are we underwater?
		beq	.PlayMusic		; if not, branch
		moveq	#0,d0			; we don't want any sound underwater
		addq.b	#2,Anim(a0)             ; set animation to $21 or $22 (depends on were you tired or not)

.PlayMusic	addq.b	#1,Spindash_SoundPitch	; add 1 to the sound counter
        	cmpi.b	#$C,Spindash_SoundPitch	; is the counter $C
        	blt	.chktop			; if less, branch
        	sf	Spindash_SoundPitch	; clear it
		jsr	PlaySound	; play the sound

.chktop		move.w	$FFFFF72C.w,d0		; get camera up limit
		cmp.w	#$FF00,d0		; is vertical wrapping enabled?
		beq.s	.rts			; if is, branch
		add.w	#$14,d0			; add $10 to d0
		cmp.w	Y_Pos(a0),d0		; is it equal with Y position
		ble.s	.rts			; if less than, branch
		move.w	d0,Y_Pos(a0)		; set Y position

.rts		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to do Super Speel Out ; Vldikcomper, timer added by GS
; ---------------------------------------------------------------------------
Sonic_SpeelOut:
		buytest Bought_SpinDash
		beq.w	Sonic_SpeelOut_Rts
                tst.b   PeelOut_Flag		; is already Speel Outing?
                bne	Sonic_SO_Launch		; if so, branch
                cmp.b   #7,Anim(a0)		; is anim look up?
                bne	Sonic_SpeelOut_Rts	; if not, branch
                btst    #0,($FFFFF602).w	; is Up is being held?
                beq	Sonic_SpeelOut_Rts	; if no, branch
                move.b  ($FFFFF603).w,d0
                and.b   #JumpBtns,d0         	; check if ABC is pressed
                beq.w   Sonic_SpeelOut_Rts

                sf	Spindash_SoundTimer	; reset spindash sound pitch setting
                move.b  #$D1,d0
                jsr     PlaySound
                move.w  #$60,($FFFFF73E).w	; reset looking up/down

Sonic_SO_Launch:
                bsr.w	Sonic_LevelBound
		bsr.w	Sonic_AnglePos

		bclr	#5,Status		; clear Sonic's pushing flag
                addq.b  #1,PeelOut_Flag		; set Speel Out flag
                cmpi.b  #$22,PeelOut_Flag	; check for speelout flag
                blo	.C			; if less, branch
                move.b  #$23,PeelOut_Flag  	; set Speel Out flag

.C		addq.l  #4,sp			; increase stack ptr to avoid jumping
                move.b  #1,Anim(a0)		; launch SO ani

                btst    #0,($FFFFF602).w	; is Up is being held?
                bne.s   Sonic_SpeelOut_Rts	; if yes, branch
                cmpi.b  #$22,PeelOut_Flag	; is SO enough powerful?
                blo.s   Sonic_SpeelOut_ChkSpeed	; if no, branch

                move.b  #$BC,d0			; play SO release sound
                jsr     PlaySound	;

                move.w	#$B00,d0		; get speed
                move.w  d0,Inertia(a0)		; set speed
		bsr	GetScreenDelay

Sonic_SO_Animate:
                move.w  #1,Anim(a0)		; use walking animation

Sonic_So_Release:
                move.b  #0,PeelOut_Flag		; clear SO flag

Sonic_SpeelOut_Rts:
                rts
; ===========================================================================

Sonic_SpeelOut_ChkSpeed:; this will force the peelout to continue until release if you have speelouted for long enough
                cmpi.b  #$14,PeelOut_Flag	; is SO enough powerful?
                blo.s   Sonic_So_Release	; if no, branch
                rts

GetScreenDelay:
		buytest	Bought_ExtCam		; is extended camera on?
                bne	xskip			; if not, branch
		subi.w	#$800,d0		; subtract $800
		add.w	d0,d0			; double it
		andi.w	#$1F00,d0		; mask it against $1F00
		neg.w	d0			; negate it
		addi.w	#$2000,d0		; add $2000
		move.w	d0,Spindash_HorizDelay	; move to $EED0
xskip		btst	#0,Status(a0)		; is sonic facing right?
		beq.s	.end			; if not, branch
		neg.w	Inertia(a0)		; negate inertia
.end		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; subroutine to do spindash
; ---------------------------------------------------------------------------

Sonic_SpinDash:
		buytest Bought_SpinDash
		beq	SD_rts
	       ; tst.w	Inertia(a0)		; test inertia
		;bne	ChkRelease		; if not 0, branch
		move.b	($FFFFF602).w,d0	; read controller
		btst	#1,d0			; check down button
		beq	ChkRelease		; if not held, branch

		move.b	($FFFFF603).w,d0	; read controller
		andi.b	#JumpBtns,d0			; pressing A/B/C ?
		beq	.SetAni			; if not, return
		tst.b	If_Spindash		; are we Spindashing?
  		beq	SD_Start		; if not, branch
	   	bra	SD_Charge		; go to charging routine

.SetAni		tst.b	If_Spindash		; are we Spindashing?
  		beq	SD_rts			; if not, branch

SD_SetAni:
		move.b	#9,Anim(a0)		; set to spindash animation
		addq.l	#4,sp			; skip the "modes" routines and display the object
		bra	CenterYCamera

ChkRelease:
	   	tst.b	If_Spindash		; are we Spindashing?
  		bne	SD_release		; if not, branch
SD_rts:	   	rts
; ===========================================================================

SD_Start:
		cmpi.b	#8,Anim(a0)
		bne	SD_rts
		move.b	#1,If_Spindash		; set Spin Dash flag

		move.w	#0,off3A(a0)		; set charge count to 0
		move.b	#2,SpinDust_RAM+Anim	; Set the Spin Dash dust animation to 2
		move.w	#$D1,d0			; spin sound ($E0 in s2)
		jsr	PlaySound	; play spin sound
		bra	SD_SetAni

SD_Release:
	   	addq.l	#4,sp			; increment stack ptr
		move.w	Player_RollHeight.w,Y_Radius(a0); set radius
		move.b	#2,Anim(a0)		; set animation to roll
		addq.w	#5,Y_Pos(a0)		; $C(a0) is Y coordinate
		move.b	#0,If_Spindash		; clear Spin Dash flag

		moveq	#0,d0
		move.b	off3A(a0),d0		; copy charge count
		add.w	d0,d0			; double it
		move.w	SD_Speeds(pc,d0.w),$14(a0) ; get normal speed

	;	tst.b	TurboMode_flag
		move.w	Inertia(a0),d0		; get inertia
		bsr	GetScreenDelay		; get the proper screen delay

                bset	#2,Status(a0)		; set jumping/rolling flag
		move.b	#0,SpinDust_RAM+Anim	; clear Spin Dash dust animation
		move.w	#$BC,d0			; spin release sound
		jmp	PlaySound	; play it!
; ===========================================================================

SD_Speeds:	dc.w  $800, $880, $900, $980, $A00, $A80, $B00, $B80, $C00
SD_TSpeeds:	dc.w  $800, $880, $900, $980, $A00, $A80, $B00, $B80, $C00
; ===========================================================================

SD_Charge:
		move.b	#9,Anim(a0)
		addq.l	#4,sp
	;	move.w	off3A(a0),d0	; otherwise put it in d0
	;	beq.s	.0		; if zero, branch
	;	lsr.w	#5,d0		; shift right 5 (divide it by 32)
	;	sub.w	d0,off3A(a0)	; subtract from charge count
	;	bhs.s	.0		; branch if carry clear
	;	move.w	#0,off3A(a0)	; set charge count to 0

.0		move.b	#2,SpinDust_RAM+Anim	; Set the Spin Dash dust animation to 2
		move.w	#$900,Anim(a0)		; reset spdsh animation
		move.w	#$D1,d0			; was $E0 in sonic 2
		jsr	PlaySound	; play charge sound
		addi.w	#$200,off3A(a0)		; increase charge count
		cmpi.w	#$800,off3A(a0)		; check if it's maxed
		blo.s	CenterYCamera		; if not, then branch
		move.w	#$800,off3A(a0)		; reset it to max

CenterYCamera:
	      	cmpi.w	#$60,($FFFFF73E).w	; is the Cameras Y position correct?
		beq.s	.NoMove			; if centered, branch
		bhs.s	.MoveDwn		; if more than, branch
		addq.w	#4,($FFFFF73E).w	; nove up

.MoveDwn	subq.w	#2,($FFFFF73E).w	; move down

.NoMove		jsr	Sonic_LevelBound
		jmp	Sonic_AnglePos
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	make Sonic walk/run
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Move:				; XREF: Obj01_MdNormal
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		move.w	($FFFFF764).w,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc_12FEE
		tst.w	Off3E(a0)	; is moving limited flag set?
		bne	Obj01_ResetScr	; if is, branch
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj01_NotLeft	; if not, branch
		bsr.w	Sonic_MoveLeft
	;	moveq	#1,d1
Obj01_NotLeft:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	Obj01_NotRight	; if not, branch
		bsr.w	Sonic_MoveRight
	;	moveq	#1,d1
Obj01_NotRight:
		move.b	Angle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0		; is Sonic on a	slope?
		bne.w	Obj01_ResetScr	; if yes, branch
		tst.w	Inertia(a0)		; is Sonic moving?
		bne.w	Obj01_ResetScr	; if yes, branch
		bclr	#5,Status(a0)
		move.b	#5,Anim(a0)	; use "standing" animation
		btst	#3,Status(a0)
		beq.s	Sonic_Balance
		moveq	#0,d0
		move.b	Off3D(a0),d0
		lsl.w	#6,d0
		lea	Object_RAM,a1
		lea	(a1,d0.w),a1
		tst.b	Status(a1)
		bmi.s	Sonic_LookUp
		moveq	#0,d1
		move.b	X_Visible(a1),d1
		move.w	d1,d2
		add.w	d2,d2
		subq.w	#4,d2
		add.w	X_pos(a0),d1
		sub.w	X_pos(a1),d1
		cmpi.w	#4,d1
		blt.s	loc_12F6A
		cmp.w	d2,d1
		bge.s	loc_12F5A
		bra.s	Sonic_LookUp
; ===========================================================================

Sonic_Balance:
		jsr	ObjHitFloor
		cmpi.w	#$C,d1
		blt.s	Sonic_LookUp
		cmpi.b	#3,Off36(a0)
		bne.s	loc_12F62

loc_12F5A:
		bclr	#0,Status(a0)
		bra.s	loc_12F70
; ===========================================================================

loc_12F62:
		cmpi.b	#3,Off37(a0)
		bne.s	Sonic_LookUp

loc_12F6A:
		bset	#0,Status(a0)

loc_12F70:
		move.b	#6,Anim(a0)	; use "balancing" animation
		bra.s	Obj01_ResetScr
; ===========================================================================

Sonic_LookUp:
	;	moveq	#0,d1
		btst	#0,($FFFFF602).w ; is up being pressed?
		beq.s	Sonic_Duck	; if not, branch
		move.b	#7,$1C(a0)	; use "looking up" animation
		addq.b	#1,Spindash_ChangeCnt
		cmp.b	#$25,Spindash_ChangeCnt
		blo.s	Obj01_ResetScr_Part2
		move.b	#$25,Spindash_ChangeCnt
		cmpi.w	#$C8,($FFFFF73E).w
		beq.s	loc_12FC2
		addq.w	#2,($FFFFF73E).w
		bra.s	loc_12FC2
; ===========================================================================

Sonic_Duck:
	;	tst.b	d1
	;	bne	Obj01_ResetScr
		btst	#1,($FFFFF602).w ; is down being pressed?
		beq.s	Obj01_ResetScr	; if not, branch
		move.b	#8,$1C(a0)	; use "ducking"	animation
		addq.b	#1,Spindash_ChangeCnt
		cmpi.b	#$25,Spindash_ChangeCnt
		blo.s	Obj01_ResetScr_Part2
		move.b	#$25,Spindash_ChangeCnt
		cmpi.w	#8,($FFFFF73E).w
		beq.s	loc_12FC2
		subq.w	#2,($FFFFF73E).w
		bra.s	loc_12FC2
; ===========================================================================

Obj01_ResetScr:
		move.b	#0,Spindash_ChangeCnt

Obj01_ResetScr_Part2:
		cmpi.w	#$60,($FFFFF73E).w ; is	screen in its default position?
		beq.s	loc_12FC2	; if yes, branch
		bhs.s	loc_12FBE
		addq.w	#4,($FFFFF73E).w ; move	screen back to default

loc_12FBE:
		subq.w	#2,($FFFFF73E).w ; move	screen back to default

loc_12FC2:
		move.b	($FFFFF602).w,d0
		andi.b	#$C,d0		; is left/right	pressed?
		bne.s	loc_12FEE	; if yes, branch
		move.w	Inertia(a0),d1
		beq.s	loc_12FEE
		bmi.s	loc_12FE2
		sub.w	d5,d1
		bhs.s	loc_12FDC
		move.w	#0,d1

loc_12FDC:
		move.w	d1,Inertia(a0)
		bra.s	loc_12FEE
; ===========================================================================

loc_12FE2:
		add.w	d5,d1
		bhs.s	loc_12FEA
		move.w	#0,d1

loc_12FEA:
		move.w	d1,Inertia(a0)

loc_12FEE:
		move.b	Angle(a0),d1
		jsr	(CalcSine).l
		muls.w	Inertia(a0),d1
		asr.l	#8,d1
		move.w	d1,X_Vel(a0)
		muls.w	Inertia(a0),d0
		asr.l	#8,d0
		move.w	d0,Y_Vel(a0)

loc_1300C:
		move.b	Angle(a0),d0
		addi.b	#$40,d0
		bmi.s	locret_1307C
		move.b	#$40,d1
		tst.w	Inertia(a0)
		beq.s	locret_1307C
		bmi.s	loc_13024
		neg.w	d1

loc_13024:
		move.b	Angle(a0),d0
		add.b	d1,d0
		move.w	d0,-(sp)
		bsr.w	Sonic_WalkSpeed
		move.w	(sp)+,d0
		tst.w	d1
		bpl.s	locret_1307C
		asl.w	#8,d1
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	loc_13078
		cmpi.b	#$40,d0
		beq.s	loc_13066
		cmpi.b	#$80,d0
		beq.s	loc_13060
		add.w	d1,X_Vel(a0)
		bset	#5,Status(a0)
		move.w	#0,Inertia(a0)
		rts
; ===========================================================================

loc_13060:
		sub.w	d1,Y_Vel(a0)
		rts
; ===========================================================================

loc_13066:
		sub.w	d1,X_Vel(a0)
		bset	#5,Status(a0)
		move.w	#0,Inertia(a0)
		rts
; ===========================================================================

loc_13078:
		add.w	d1,Y_Vel(a0)

locret_1307C:
		rts
; End of function Sonic_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_MoveLeft:				; XREF: Sonic_Move
		move.w	Inertia(a0),d0
		beq.s	loc_13086
		bpl.s	loc_130B2

loc_13086:
		bset	#0,Status(a0)
		bne.s	loc_1309A
		bclr	#5,Status(a0)
		move.b	#1,Anim_Restart(a0)

loc_1309A:
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_130A6
		add.w	d5,d0
		cmp.w	d1,d0
		ble.s	loc_130A6
		move.w	d1,d0
loc_130A6:
		move.w	d0,Inertia(a0)
		move.b	#0,Anim(a0)	; use walking animation
		rts
; ===========================================================================

loc_130B2:				; XREF: Sonic_MoveLeft
		sub.w	d4,d0
		bhs.s	loc_130BA
		move.w	#-$80,d0

loc_130BA:
		move.w	d0,Inertia(a0)
		move.b	Angle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret_130E8
		cmpi.w	#$400,d0
		blt.s	locret_130E8
		move.b	#$D,Anim(a0)	; use "stopping" animation
		bclr	#0,Status(a0)
		move.w	#$A4,d0
		jsr	(PlaySound).l ;	play stopping sound

locret_130E8:
		rts
; End of function Sonic_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_MoveRight:			; XREF: Sonic_Move
		move.w	Inertia(a0),d0
		bmi.s	loc_13118
		bclr	#0,Status(a0)
		beq.s	loc_13104
		bclr	#5,Status(a0)
		move.b	#1,Anim_Restart(a0)

loc_13104:
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc_1310C
		sub.w	d5,d0
		cmp.w	d6,d0
		bge.s	loc_1310C
		move.w	d6,d0
loc_1310C:
		move.w	d0,Inertia(a0)
		move.b	#0,Anim(a0)	; use walking animation
		rts
; ===========================================================================

loc_13118:				; XREF: Sonic_MoveRight
		add.w	d4,d0
		bhs.s	loc_13120
		move.w	#$80,d0

loc_13120:
		move.w	d0,Inertia(a0)
		move.b	Angle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret_1314E
		cmpi.w	#-$400,d0
		bgt.s	locret_1314E
		move.b	#$D,Anim(a0)	; use "stopping" animation
		bset	#0,Status(a0)
		move.w	#$A4,d0
		jsr	(PlaySound).l ;	play stopping sound

locret_1314E:
		rts
; End of function Sonic_MoveRight

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's speed as he rolls
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollSpeed:			; XREF: Obj01_MdRoll
		move.w	($FFFFF760).w,d6
		asl.w	#1,d6
		move.w	($FFFFF762).w,d5
		asr.w	#1,d5
		move.w	($FFFFF764).w,d4
		asr.w	#2,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc_131CC
		tst.w	Off3E(a0)
		bne.s	loc_13188
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	loc_1317C	; if not, branch
		bsr.w	Sonic_RollLeft

loc_1317C:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc_13188	; if not, branch
		bsr.w	Sonic_RollRight

loc_13188:
		move.w	Inertia(a0),d0
		beq.s	loc_131AA
		bmi.s	loc_1319E
		sub.w	d5,d0
		bhs.s	loc_13198
		move.w	#0,d0

loc_13198:
		move.w	d0,Inertia(a0)
		bra.s	loc_131AA
; ===========================================================================

loc_1319E:				; XREF: Sonic_RollSpeed
		add.w	d5,d0
		bhs.s	loc_131A6
		move.w	#0,d0

loc_131A6:
		move.w	d0,Inertia(a0)

loc_131AA:
		tst.w	Inertia(a0)		; is Sonic moving?
		bne	loc_131CC		; if yes, branch
		bclr	#2,Status(a0)
		move.w	Player_StandHeight.w,Y_Radius(a0)	; set radius
		move.b	#5,Anim(a0)		; use "standing" animation
		subq.w	#5,Y_Pos(a0)

loc_131CC:
		cmp.w	#$60,($FFFFF73E).w
		beq.s	.cont2
		bhs.s	.cont1
		addq.w	#4,($FFFFF73E).w

.cont1:
		subq.w	#2,($FFFFF73E).w

.cont2:
		move.b	$26(a0),d1
		jsr	CalcSine
		muls.w	Inertia(a0),d0
		asr.l	#8,d0
		move.w	d0,Y_Vel(a0)
		muls.w	Inertia(a0),d1
		asr.l	#8,d1
		cmpi.w	#$1000,d1
		ble.s	loc_131F0
		move.w	#$1000,d1

loc_131F0:
		cmpi.w	#-$1000,d1
		bge.s	loc_131FA
		move.w	#-$1000,d1

loc_131FA:
		move.w	d1,X_Vel(a0)
		bra.w	loc_1300C
; End of function Sonic_RollSpeed


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollLeft:				; XREF: Sonic_RollSpeed
		move.w	Inertia(a0),d0
		beq.s	loc_1320A
		bpl.s	loc_13218

loc_1320A:
		bset	#0,Status(a0)
		move.b	#2,Anim(a0)	; use "rolling"	animation
		rts
; ===========================================================================

loc_13218:
		sub.w	d4,d0
		bhs.s	loc_13220
		move.w	#-$80,d0

loc_13220:
		move.w	d0,Inertia(a0)
		rts
; End of function Sonic_RollLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollRight:			; XREF: Sonic_RollSpeed
		move.w	Inertia(a0),d0
		bmi.s	loc_1323A
		bclr	#0,Status(a0)
		move.b	#2,Anim(a0)	; use "rolling"	animation
		rts
; ===========================================================================

loc_1323A:
		add.w	d4,d0
		bhs.s	loc_13242
		move.w	#$80,d0

loc_13242:
		move.w	d0,Inertia(a0)
		rts
; End of function Sonic_RollRight

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's direction while jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_ChgJumpDir:			; XREF: Obj01_MdJump; Obj01_MdRollJump
		tst.w	Off3E(a0)
		bne	loc_13582
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		asl.w	#1,d5
	;	btst	#4,Status(a0)
	;	bne.s	Obj01_ResetScr2
		move.w	X_Vel(a0),d0
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	loc_13278	; if not, branch
		bset	#0,Status(a0)
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_13278
		add.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d1,d0		; +++ compare speed with top speed
		ble.s	loc_13278	; +++ if speed was already greater than the maximum, branch
		move.w	d1,d0

loc_13278:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	Obj01_JumpMove	; if not, branch
		bclr	#0,Status(a0)
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	Obj01_JumpMove
		sub.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d6,d0		; +++ compare speed with top speed
		bge.s	Obj01_JumpMove	; +++ if speed was already greater than the maximum, branch
		move.w	d6,d0

Obj01_JumpMove:
		move.w	d0,X_Vel(a0)	; change Sonic's horizontal speed

Obj01_ResetScr2:
		cmpi.w	#$60,($FFFFF73E).w ; is	the screen in its default position?
		beq.s	loc_132A4	; if yes, branch
		bhs.s	loc_132A0
		addq.w	#4,($FFFFF73E).w

loc_132A0:
		subq.w	#2,($FFFFF73E).w

loc_132A4:
		cmpi.w	#-$400,Y_Vel(a0)	; is Sonic moving faster than -$400 upwards?
		blo.s	locret_132D2	; if yes, branch
		move.w	X_Vel(a0),d0
		move.w	d0,d1
		asr.w	#5,d1
		beq.s	locret_132D2
		bmi.s	loc_132C6
		sub.w	d1,d0
		bhs.s	loc_132C0
		move.w	#0,d0

loc_132C0:
		move.w	d0,X_Vel(a0)
		rts
; ===========================================================================

loc_132C6:
		sub.w	d1,d0
		blo.s	loc_132CE
		move.w	#0,d0

loc_132CE:
		move.w	d0,X_Vel(a0)

locret_132D2:
		rts
; End of function Sonic_ChgJumpDir

; ---------------------------------------------------------------------------
; Subroutine to	prevent	Sonic leaving the boundaries of	a level
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_LevelBound:			; XREF: Obj01_MdNormal; et al
		tst.b	Hacky_Mode.w
		bmi	loc_13336
		moveq	#0,d2
		move.l	X_pos(a0),d1
		move.w	X_Vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d1
		swap	d1
		move.w	($FFFFF728).w,d0
		addi.w	#$10,d0
		cmp.w	d1,d0		; has Sonic touched the	side boundary?
		bgt	Boundary_Sides	; if yes, branch
		moveq	#1,d2
		move.w	($FFFFF72A).w,d0
		addi.w	#$130,d0
loc_13332:
		cmp.w	d1,d0		; has Sonic touched the	side boundary?
		blt.s	Boundary_Sides	; if yes, branch

loc_13336:
		tst.b	Sonic_SuperFly.w
		bmi.s	.super

		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	Y_Pos(a0),d0	; has Sonic touched the	bottom boundary?
		blt.s	Boundary_Bottom	; if yes, branch
		rts

.super		move.w	$FFFFF704.w,d0
		addi.w	#$14,d0
		cmp.w	Y_Pos(a0),d0	; has Sonic touched the	upper boundary?
		blt.s	.downer		; if not, branch
		move.w	d0,Y_Pos(a0)

.downer		addi.w	#$E0-$28,d0
		cmp.w	Y_Pos(a0),d0	; has Sonic touched the	lower boundary?
		bge.s	.nop		; if not, branch
		move.w	d0,Y_Pos(a0)

.nop		rts
; ===========================================================================

Boundary_Bottom:
		move.w	($FFFFF72E).w,d1
		cmp.w	($FFFFF726).w,d1	; screen still scrolling down?
		blt.s	Boundary_Bottom_locret	; if so, don't kill Sonic
		cmpi.w	#$502,($FFFFFE10).w	; is level SBZ2 ?
		bne	JMPKillSonic		; if not, kill Sonic

		; here code to next level

		cmpi.b	#7,Emeralds.w
		beq.s	Boundary_Bottom_locret
		move.w	#$700,$FFFFFE10.w	; is level SBZ2 ?
		st	$FFFFFE03.w

Boundary_Bottom_locret:
		rts
; ===========================================================================

Boundary_Sides:
		move.w	d0,X_pos(a0)
		move.w	#0,X_Pos2(a0)
		move.w	#0,X_Vel(a0)	; stop Sonic moving
		move.w	#0,Inertia(a0)
		bra	loc_13336
; End of function Sonic_LevelBound

JMPKillSonic:	jmp	KillSonic
; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to roll when he's moving
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Roll:				; XREF: Obj01_MdNormal
		tst.b	($FFFFF7CA).w
		bne.s	Obj01_NoRoll
		tst.b	Sonic_ForceRollMode
		bne	Obj01_ChkRoll
		move.w	Inertia(a0),d0
		bpl.s	loc_13392
		neg.w	d0

loc_13392:
		cmpi.w	#$80,d0		; is Sonic moving at $80 speed or faster?
		blo.s	Obj01_NoRoll	; if not, branch
		move.b	($FFFFF602).w,d0
		andi.b	#$C,d0		; is left/right	being pressed?
		bne.s	Obj01_NoRoll	; if yes, branch
		btst	#1,($FFFFF602).w ; is down being pressed?
		bne.s	Obj01_ChkRoll	; if yes, branch

Obj01_NoRoll:
		rts
; ===========================================================================

Obj01_ChkRoll:
		btst	#2,Status(a0)	; is Sonic already rolling?
		beq.s	Obj01_DoRoll	; if not, branch
		rts
; ===========================================================================

Obj01_DoRoll:
		bset	#2,Status(a0)
		move.w	Player_RollHeight.w,Y_Radius(a0); set radius
		move.b	#2,Anim(a0)	; use "rolling"	animation
		addq.w	#5,Y_Pos(a0)
		tst.b	Sonic_ForceRollMode
		bne	.NoSound
		move.w	#$BE,d0
		jsr	(PlaySound).l ;	play rolling sound
		rts
.NoSound	move.w	#$500,d0
		btst	#0,Status(a0)
		beq	.noflip
		move.w	#-$500,d0
		cmp.w	Inertia(a0),d0
		bgt	locret_133E8
		cmpi.w	#$100,Inertia(a0)
		bge	locret_133E8
		move.w	d0,Inertia(a0)
.noflip		cmp.w	Inertia(a0),d0
		blt	locret_133E8
		cmpi.w	#-$100,Inertia(a0)
		ble	locret_133E8
		move.w	d0,Inertia(a0)

locret_133E8:
		rts
; End of function Sonic_Roll

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to jump
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Jump:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		move.b	($FFFFF603).w,d0
		andi.b	#JumpBtns,d0		; is A,	B or C pressed?
		beq	locret_1348E	; if not, branch
		btst	#7,Off3E(a0)	; was bit 7 set (Ignore on jump)?
		bne	.		; if was, branch
		tst.w	Off3E(a0)	; is control limit flag set?
		bne	locret_1348E	; if is, branch
.		moveq	#0,d0
		move.b	Angle(a0),d0
		addi.b	#$80,d0
		bsr.w	Sonic_CheckFloorColl
		cmpi.w	#6,d1
		blt.w	locret_1348E
		move.w	Player_JumpHeight,d2
		addi.w	#$280,d2
		btst	#6,Status(a0)
		beq.s	loc_1341C
		subi.w	#$300,d2

loc_1341C:
		moveq	#0,d1
		move.b	Angle(a0),d1
		subi.b	#$40,d1
		jsr	CalcSine
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,X_Vel(a0)	; make Sonic jump
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,Y_Vel(a0)	; make Sonic jump
		bset	#1,Status(a0)
		bclr	#5,Status(a0)
		addq.l	#4,sp
		move.b	#1,Off3C(a0)
		sf	Off38(a0)
		move.w	#$A0,d0
		jsr	PlaySound ;	play jumping sound
		move.w	Player_StandHeight.w,Y_Radius(a0)	; set radius

		sf	Spindash_SoundPitch	; clear 1 byte
		clr.l	Spindash_StorePitch	; clear 4 bytes
		clr.l	Player_DJ_Data		; clear Double Jump flags

.NoTails	btst	#2,Status(a0)
		bne.s	loc_13490
		move.w	Player_RollHeight.w,Y_Radius(a0); set radius
		move.b	#2,Anim(a0)	; use "jumping"	animation
		bset	#2,Status(a0)
		addq.w	#5,Y_Pos(a0)

locret_1348E:
		rts
; ===========================================================================

loc_13490:
		bset	#4,Status(a0)
		rts
; End of function Sonic_Jump


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_JumpHeight:			; XREF: Obj01_MdJump; Obj01_MdRollJump
		tst.b	Sonic_SuperFly.w
		bmi.s	locret_134C2
		tst.b	Off3C(a0)
		beq.s	loc_134C4
		move.w	Player_JumpHeight,d1
		neg.w	d1
		btst	#6,Status(a0)
		beq.s	loc_134AE
		addi.w	#$200,d1

loc_134AE:
		cmp.w	Y_Vel(a0),d1
		ble.s	Player_JumpMove
		move.b	($FFFFF602).w,d0
		andi.b	#JumpBtns,d0		; is A,	B or C pressed?
		bne.s	locret_134C2	; if yes, branch
		move.w	d1,Y_Vel(a0)

locret_134C2:
		rts
; ===========================================================================

loc_134C4:
		cmpi.w	#-$FC0,Y_Vel(a0)
		bge.s	locret_134D2
		move.w	#-$FC0,Y_Vel(a0)

locret_134D2:
		rts
; End of function Sonic_JumpHeight

Player_JumpMove:

		buytest Bought_SpinDash
		beq	locret_134D2
		tst.b	Player_DoubleJump	; is doublejumping?
		bne	locret_134D2		; if is, branch
		move.b	($FFFFF603).w,d0	; get controls
		and.b	#JumpBtns,d0			; is A, B or C pressed?
		beq	locret_134D2		; if not, branch
		moveq	#0,d0
		move.b	Current_Character,d0	; get character id
		move.w	.Index(pc,d0.w),d1
		jmp	.Index(pc,d1.w)		; jump to approriate routine

.Index:		dc.w JumpHeight_Sonic-.Index
		dc.w JumpHeight_Tails-.Index
		dc.w JumpHeight_Knux-.Index

JumpHeight_Tails:
		move.w	#$150,Spindash_StorePitch; set the timer
		move.b	#$41,Player_DoubleJump	; tell we are flying
		move.b	#$1F,Anim(a0)		; use flying animation
		btst	#6,Status(a0)		; is Tails underwater?
		beq	.w			; if not, branch
		addq.b	#2,Anim(a0)		; use swimming animation
.w		rts

JumpHeight_Knux:
		tst.b	Gliding_Main
		bne	.end
		bclr	#2,Status(a0)
		move.b	#$A,Y_Radius(a0)
		move.b	#$A,X_Radius(a0)
		bclr	#4,Status(a0)
		move.b	#1,Player_DoubleJump
		move.b	#1,Gliding_Main
		add.w	#$200,Y_Vel(a0)
		bpl	.c
		move.w	#0,Y_Vel(a0)

.c              moveq	#0,d1
		move.w	#$400,d0
		move.w	d0,Inertia(a0)
		btst	#0,Status(a0)
		beq	.NotFlip
		neg.w	d0
		moveq	#-$80,d1

.NotFlip	move.w	d0,X_Vel(a0)
		move.b	d1,Glide_AnimHandler
		move.w	#0,Angle(a0)
		move.b	#$82,Gliding_2
		bsr	K_SetAnim
.end		rts

JumpHeight_Sonic:
		cmpi.b	#$34,Ttlcard_RAM.w	; if title cards are on, prohibit
		beq.s	.rts
		tst.b	$FFFFFE2D		; is invinciblity active?
		bne	.rts			; if is, branch
		buytest Bought_Shields
		beq	.rts

		move.b	#1,Player_DoubleJump	; make sure we can't abuse it
		moveq	#0,d0
		move.b	Shield_Type,d0
		lsr.w	#3,d0
		move.b	.Index2(pc,d0.w),d0
		jmp	.Index2(pc,d0.w)		; jump to approriate routine

.Index2		dc.b .Insta-.Index2, .Bubble-.Index2, .Light-.Index2, Fire-.Index2


.Insta		move.b	#2,Shield_RAM+Routine2	; use instashield
		move.b	#1,Shield_UseType
.rts		rts

.Bubble		move.b	#1,Shield_RAM+Anim	; set animation
		move.b	#2,Shield_UseType	; set to bounce
		move.w	#$800,Y_Vel(a0)		; set speed
		rts

.Light          move.w	#-$580,Y_Vel(a0)
		sf	Off3C(a0)
                move.b	#3,Shield_UseType	; set to electric shield

		lea	SparkVelocities(pc),a2
		moveq	#3,d1

.Loop	        jsr	Singleobjload
		bne	.rts
		move.b	#$90,(a1)
		move.b	#4,Subtype(a1)
		move.w	X_Pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_pos(a1)
		move.l	#Map_LighteningShield,Mappings_offset(a1)
		move.w	#$578,Art_Tile(a1)
		ori.b	#4,Render_Flags(a1)
		move.b	#1,Priority(a1)
		move.b	#8,X_Radius(a1)
		move.b	#8,Y_Radius(a1)
		move.b	#1,Anim(a1)
		move.w	(a2)+,X_Vel(a1)
		move.w	(a2)+,Y_Vel(a1)
		dbf	d1,.loop
		moveq	#$FFFFFF9A,d0
		jmp	PlaySound

Fire		move.b	#1,Shield_RAM+Anim	; set animation
		move.b	#4,Shield_UseType	; set to firemove
                move.b	#4,Shield_RAM+Routine2	; use fire shield
                move.w	#16,Object_RAM+Off3E	; prevent sonic from moving left

		move.w	#$800,d0		; set speed
		clr.w	Y_Vel(a0)		; clear Y Velocity
		move.w	d0,X_Vel(a0)		; set X Speed
		clr.w	Inertia(a0)		; set Inertia
		buytest	Bought_ExtCam		; is extended camera on?
                bne	.NoDelay		; if is, branch
		jsr	ClearTrackingarray	; clear trackign array to fix camera bugs
		move.w	#$2000,Spindash_HorizDelay; set screen delay
.NoDelay	btst	#0,Status(a0)		; is sonic facing right?
		beq	.NoFlip			; if not, branch
		neg.w	X_Vel(a0)
.NoFlip		rts

SparkVelocities:
		dc.w  -$200, -$200
		dc.w   $200, -$200
		dc.w  -$200,  $200
		dc.w   $200,  $200
; ---------------------------------------------------------------------------
; Subroutine to	slow Sonic walking up a	slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_SlopeResist:			; XREF: Obj01_MdNormal
		move.b	Angle(a0),d0
		addi.b	#$60,d0
		cmpi.b	#$C0,d0
		bhs.s	locret_13508
		move.b	Angle(a0),d1
		jsr	(CalcSine).l
		muls.w	#$20,d0
		asr.l	#8,d0
		tst.w	Inertia(a0)
		beq.s	locret_13508
		bmi.s	loc_13504
		tst.w	d0
		beq.s	locret_13502
		add.w	d0,Inertia(a0)	; change Sonic's inertia

locret_13502:
		rts
; ===========================================================================

loc_13504:
		add.w	d0,Inertia(a0)

locret_13508:
		rts
; End of function Sonic_SlopeResist

; ---------------------------------------------------------------------------
; Subroutine to	push Sonic down	a slope	while he's rolling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollRepel:			; XREF: Obj01_MdRoll
		move.b	Angle(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bhs.s	locret_13544
		move.b	Angle(a0),d1
		jsr	(CalcSine).l
		muls.w	#$50,d0
		asr.l	#8,d0
		tst.w	Inertia(a0)
		bmi.s	loc_1353A
		tst.w	d0
		bpl.s	loc_13534
		asr.l	#2,d0

loc_13534:
		add.w	d0,Inertia(a0)
		rts
; ===========================================================================

loc_1353A:
		tst.w	d0
		bmi.s	loc_13540
		asr.l	#2,d0

loc_13540:
		add.w	d0,Inertia(a0)

locret_13544:
		rts
; End of function Sonic_RollRepel

; ---------------------------------------------------------------------------
; Subroutine to	push Sonic down	a slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_SlopeRepel:			; XREF: Obj01_MdNormal; Obj01_MdRoll
		nop
		tst.b	Off38(a0)
		bne.s	locret_13580
		tst.w	Off3E(a0)
		bne	loc_13582
		move.b	Angle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	locret_13580
		move.w	Inertia(a0),d0
		bpl.s	loc_1356A
		neg.w	d0

loc_1356A:
		cmpi.w	#$280,d0
		bhs.s	locret_13580
		clr.w	Inertia(a0)
		bset	#1,Status(a0)
		sf	PeelOut_Flag
		move.w	#$1E,Off3E(a0)

locret_13580:
		rts
; ===========================================================================

loc_13582:
		subq.w	#1,Off3E(a0)	; subtract 1 from delay counter
		move.w	Off3E(a0),d0	; get the counter to d0
		andi.w	#$7FFF,d0	; clear bit 7 of counter (Used by springs, to no limit Sonic's jumping ability, but without set you can limit it (For Knuckles' glide move))
		bne	.rts		; if not 0, branch
		clr.w	Off3E(a0)	; clear the counter
.rts		rts
; End of function Sonic_SlopeRepel

; ---------------------------------------------------------------------------
; Subroutine to	return Sonic's angle to 0 as he jumps
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_JumpAngle:			; XREF: Obj01_MdJump; Obj01_MdRollJump
		move.b	Angle(a0),d0	; get Sonic's angle
		beq.s	locret_135A2	; if already 0,	branch
		bpl.s	loc_13598	; if higher than 0, branch

		addq.b	#2,d0		; increase angle
		bhs.s	loc_13596
		moveq	#0,d0

loc_13596:
		bra.s	loc_1359E
; ===========================================================================

loc_13598:
		subq.b	#2,d0		; decrease angle
		bhs.s	loc_1359E
		moveq	#0,d0

loc_1359E:
		move.b	d0,Angle(a0)

locret_135A2:
		rts
; End of function Sonic_JumpAngle

; ---------------------------------------------------------------------------
; Subroutine for Sonic to interact with	the floor after	jumping/falling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Glide_Collide:
		bsr	Sonic_GetCollisionLayer
		move.b	#$D,d5
		move.w	X_Vel(a0),d1
		move.w	Y_Vel(a0),d2
		jsr	CalcAngle
		sub.b	#$20,d1
		and.b	#$C0,d1
		cmp.b	#$40,d1
		beq.w	Knuckles_HitLeftWall2
		cmp.b	#$80,d1
		beq.w	Knuckles_HitCeilingAndWalls2
		cmp.b	#$C0,d1
		beq.w	Knuckles_HitRightWall2
		bsr.w	CheckLeftWallDist
		tst.w	d1
		bpl.s	loc_316998
		sub.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)
		bset	#5,Gliding_2

loc_316998:					  ; ...
		bsr.w	CheckRightWallDist
		tst.w	d1
		bpl.s	loc_3169B0
		add.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)
		bset	#5,Gliding_2

loc_3169B0:					  ; ...
		bsr.w	Sonic_HitFloor
		tst.w	d1
		bpl.s	return_3169CC
		add.w	d1,Y_pos(a0)
		move.b	d3,Angle(a0)
                cmpi.b  #$E0,d3
                bhs.s   .c
                cmpi.b  #$20,d3
                blo.s   .c
                sf   Gliding_Main
                clr.w   off3E(a0)
                rts
.c		move.w	#0,Y_Vel(a0)
		bclr	#1,Gliding_2
return_3169CC:					  ; ...
        	rts

Knuckles_HitLeftWall2:				  ; ...
		bsr.w	CheckLeftWallDist
		tst.w	d1
		bpl.s	Knuckles_HitCeilingAlt
		sub.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)
		bset	#5,Gliding_2

Knuckles_HitCeilingAlt:				  ; ...
		jsr	objHitCeiling
		tst.w	d1
		bpl.s	Knuckles_HitFloor
		neg.w	d1
		cmp.w	#$14,d1
		bhs.s	loc_316A08
		add.w	d1,Y_pos(a0)
		tst.w	Y_Vel(a0)
		bpl.s	return_316A06
		move.w	#0,Y_Vel(a0)

return_316A06:					  ; ...
		rts

loc_316A08:					  ; ...
		bsr.w	CheckRightWallDist
		tst.w	d1
		bpl.s	return_316A20
		add.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)
		bset	#5,Gliding_2

return_316A20:					  ; ...
		rts

Knuckles_HitFloor:				  ; ...
		tst.w	Y_Vel(a0)
		bmi.s	return_316A44
		bsr.w	Sonic_HitFloor
		tst.w	d1
		bpl.s	return_316A44
		add.w	d1,Y_pos(a0)
		move.b	d3,Angle(a0)
		cmpi.b  #$E0,d3
                bhs.s   .c
                cmpi.b  #$20,d3
                blo.s   .c
                sf   Gliding_Main
                clr.w   off3E(a0)
                rts
.c		move.w	#0,Y_Vel(a0)
		bclr	#1,Gliding_2
return_316A44:					  ; ...
                rts

Knuckles_HitCeilingAndWalls2:			  ; ...
		bsr.w	CheckLeftWallDist
		tst.w	d1
		bpl.s	loc_316A5E
		sub.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)
		bset	#5,Gliding_2

loc_316A5E:					  ; ...
		bsr.w	CheckRightWallDist
		tst.w	d1
		bpl.s	loc_316A76
		add.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)
		bset	#5,Gliding_2

loc_316A76:					  ; ...
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	return_316A88
		sub.w	d1,Y_pos(a0)
		move.w	#0,Y_Vel(a0)
return_316A88:					  ; ...
		rts

Knuckles_HitRightWall2:				  ; ...
		bsr.w	CheckRightWallDist
		tst.w	d1
		bpl.s	loc_316AA2
		add.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)
		bset	#5,Gliding_2

loc_316AA2:					  ; ...
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_316ABC
		sub.w	d1,Y_pos(a0)
		tst.w	Y_Vel(a0)
		bpl.s	return_316ABA
		move.w	#0,Y_Vel(a0)
return_316ABA:					  ; ...
		rts

loc_316ABC:					  ; ...
		tst.w	Y_Vel(a0)
		bmi.s	return_316ADE
		bsr.w	Sonic_HitFloor
		tst.w	d1
		bpl.s	return_316ADE
		add.w	d1,Y_pos(a0)
		move.b	d3,Angle(a0)
		cmpi.b  #$E0,d3
                bhs.s   .c
                cmpi.b  #$20,d3
                blo.s   .c
                sf   Gliding_Main
                clr.w   off3E(a0)
                rts
.c		move.w	#0,Y_Vel(a0)
		bclr	#1,Gliding_2
return_316ADE:					  ; ...
		rts
; End of function Knuckles_DoLevelCollision2

CheckRightWallDist:				  ; ...
		move.w	Y_Pos(a0),d2
		move.w	X_Pos(a0),d3

CheckRightWallDist_Part2:			  ; ...
		add.w	#$A,d3
		lea	($FFFFF768).w,a4
		move.w	#$10,a3
		move.w	#0,d6
		bsr.w	findwall
		move.b	#-$40,d2
		bra.w	K_FindFloorWall_End
; End of function CheckRightWallDist

CheckLeftWallDist:				  ; ...
		move.w	Y_Pos(a0),d2
		move.w	X_Pos(a0),d3

CheckLeftWallDist_Part2:			  ; ...
		sub.w	#$A,d3
		eor.w	#$F,d3
		lea	($FFFFF768).w,a4
		move.w	#$FFF0,a3
		move.w	#$400,d6
		bsr.w	findwall
		move.b	#$40,d2
		bra.w	K_FindFloorWall_End

CheckLeftCeilingDist:				  ; ...
		move.w	Y_Pos(a0),d2
		move.w	X_Pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eor.w	#$F,d3
		lea	($FFFFF768).w,a4
		move.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	findwall
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_Pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eor.w	#$F,d3
		lea	($FFFFF76A).w,a4
		move.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	findwall
		move.w	(sp)+,d0
		move.b	#$40,d2
		bra.w	loc_318FB0
; End of function CheckLeftCeilingDist

CheckRightCeilingDist:
		move.w	Y_Pos(a0),d2
		move.w	X_Pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		move.w	#$10,a3
		move.w	#0,d6
		bsr.w	findwall
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_Pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		move.w	#$10,a3
		move.w	#0,d6
		bsr.w	findwall
		move.w	(sp)+,d0
		move.b	#$C0,d2

loc_318FB0:					  ; ...
		move.b	($FFFFF76A).w,d3
		cmp.w	d0,d1
		ble.s	loc_318FBE
		move.b	($FFFFF768).w,d3
		exg	d0,d1

loc_318FBE:					  ; ...
		btst	#0,d3
		beq.s	return_318FC6
		move.b	d2,d3


return_318FC6:
.end		rts

Sonic_Floor:
		move.w	X_Vel(a0),d1
		move.w	Y_Vel(a0),d2
		jsr	(CalcAngle).l
		move.b	d1,($FFFFFFEC).w
		subi.b	#$20,d1
		move.b	d1,($FFFFFFED).w
		andi.b	#$C0,d1
		move.b	d1,($FFFFFFEE).w
		cmpi.b	#$40,d1
		beq.w	loc_13680
		cmpi.b	#$80,d1
		beq.w	loc_136E2
		cmpi.b	#-$40,d1
		beq.w	loc_1373E
		bsr.w	Sonic_HitWall
		tst.w	d1
		bpl.s	loc_135F0
		sub.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)

loc_135F0:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc_13602
		add.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)

loc_13602:
		bsr.w	Sonic_HitFloor
		move.b	d1,($FFFFFFEF).w
		tst.w	d1
		bpl.s	locret_1367E
		move.b	Y_Vel(a0),d2
		addq.b	#8,d2
		neg.b	d2
		cmp.b	d2,d1
		bge.s	loc_1361E
		cmp.b	d2,d0
		blt.s	locret_1367E

loc_1361E:
		add.w	d1,Y_Pos(a0)
		move.b	d3,Angle(a0)
		move.b	#0,Anim(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_1365C
		move.b	d3,d0
		addi.b	#$10,d0
		andi.b	#$20,d0
		beq.s	loc_1364E
		asr	Y_Vel(a0)
		bra	loc_13670
; ===========================================================================

loc_1364E:
		move.w	#0,Y_Vel(a0)
		move.w	X_Vel(a0),Inertia(a0)
		bsr	Sonic_ResetOnFloor
		rts
; ===========================================================================

loc_1365C:
		move.w	#0,X_Vel(a0)
		cmpi.w	#$FC0,Y_Vel(a0)
		ble.s	loc_13670
		move.w	#$FC0,Y_Vel(a0)

loc_13670:
		move.w	Y_Vel(a0),Inertia(a0)
		bsr	Sonic_ResetOnFloor
		tst.b	d3
		bpl.s	locret_1367E
		neg.w	Inertia(a0)

locret_1367E:
		rts
; ===========================================================================

loc_13680:
		bsr.w	Sonic_HitWall
		tst.w	d1
		bpl.s	loc_1369A
		sub.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)
		move.w	Y_Vel(a0),Inertia(a0)
		rts
; ===========================================================================

loc_1369A:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_136B4
		sub.w	d1,Y_Pos(a0)
		tst.w	Y_Vel(a0)
		bpl.s	locret_136B2
		move.w	#0,Y_Vel(a0)
locret_136B2:
		rts
; ===========================================================================

loc_136B4:
		tst.w	Y_Vel(a0)
		bmi.s	locret_136E0
		bsr.w	Sonic_HitFloor
		tst.w	d1
		bpl.s	locret_136E0
		add.w	d1,Y_Pos(a0)
		move.b	d3,Angle(a0)
		move.b	#0,Anim(a0)
		move.w	#0,Y_Vel(a0)
		move.w	X_Vel(a0),Inertia(a0)
                bsr	Sonic_ResetOnFloor
locret_136E0:
		rts
; ===========================================================================

loc_136E2:
		bsr.w	Sonic_HitWall
		tst.w	d1
		bpl.s	loc_136F4
		sub.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)

loc_136F4:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc_13706
		add.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)

loc_13706:
		moveq	#1,d4
		bsr	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	locret_1373C
		sub.w	d1,Y_Pos(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_13726
		move.w	#0,Y_Vel(a0)
		rts
; ===========================================================================

loc_13726:
		move.b	d3,Angle(a0)
		move.w	Y_Vel(a0),Inertia(a0)
		bsr	Sonic_ResetOnFloor
		tst.b	d3
		bpl.s	locret_1373C
		neg.w	Inertia(a0)

locret_1373C:
		rts
; ===========================================================================

loc_1373E:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc_13758
		add.w	d1,X_pos(a0)
		move.w	#0,X_Vel(a0)
		move.w	Y_Vel(a0),Inertia(a0)
		rts
; ===========================================================================

loc_13758:
		moveq	#0,d4
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_13772
		sub.w	d1,Y_Pos(a0)
		tst.w	Y_Vel(a0)
		bpl.s	locret_13770
		move.w	#0,Y_Vel(a0)

locret_13770:
		rts
; ===========================================================================

loc_13772:
		tst.w	Y_Vel(a0)
		bmi.s	locret_1379E
		bsr.w	Sonic_HitFloor
		tst.w	d1
		bpl.s	locret_1379E
		add.w	d1,Y_Pos(a0)
		move.b	d3,Angle(a0)
		move.b	#0,Anim(a0)
		move.w	#0,Y_Vel(a0)
		move.w	X_Vel(a0),Inertia(a0)
                bsr	Sonic_ResetOnFloor
locret_1379E:
		rts
; End of function Sonic_Floor

; ---------------------------------------------------------------------------
; Subroutine to	reset Sonic's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Knux_ResetOnFloor:
                move.b	Y_Radius(a0),d0  ; get Y radius
		sub.b	#$13,d0         ; subtract $13 from it
		ext.w	d0              ; extend to word value
		add.w	d0,Y_pos(a0)    ; add to Y position
                move.b	#$13,Y_Radius(a0)	; set radius
		move.b	#9,X_Radius(a0)		; ^

Sonic_ResetOnFloor:			; XREF: PlatformObject; et al
		cmpi.b	#$41,(a2)
		beq	Sonic_ResetOnFloor2
		sf	Spindash_SoundPitch	; clear 1 byte
		clr.l	Spindash_StorePitch	; clear 4 bytes
		clr.l	Player_DJ_Data		; clear Double Jump flags
                sf	PeelOut_Flag		; Stop peelout

Sonic_ResetOnFloor2:
		andi.b	#%11001101,Status(a0)	; clear pushing, on air, and rolljump bits
		bclr	#2,Status(a0)		; check rolling
		beq	loc_137E4		; if no(?), branch
                move.b	#0,Anim(a0)		; use running/walking animation
		move.w	Player_StandHeight.w,Y_Radius(a0)	; set radius
		subq.w	#5,Y_Pos(a0)		; sub 5 from Y_pos
loc_137E4:
		move.b	#0,Off3C(a0)		; clear jumping flag
		move.w	#0,$FFFFF7D0		; clear counter for in air hit enemies
		cmpi.b	#2,Shield_UseType
		beq.s	BubbleBounce
BubbleNoBounce	sf	Shield_UseType
		rts
; End of function Sonic_ResetOnFloor

BubbleBounce:
		move.w	#$780,d2
		btst	#6,Status(a0)
		beq.s	loc_12246
		move.w	#$400,d2

loc_12246:
		moveq	#0,d1
		move.b	Angle(a0),d1
		subi.b	#$40,d1
		bpl	BubbleNoBounce
		jsr	CalcSine
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,X_Vel(a0)
		muls.w	d2,d0
		asr.l	#8,d0
		move.w	d0,Y_Vel(a0)
		bset	#1,Status(a0)
		bclr	#5,Status(a0)
		move.b	#1,Off3C(a0)
		move.w	#$E07,Y_Radius(a0)
		move.b	#2,Anim(a0)
		bset	#2,Status(a0)
		move.b	#2,Shield_RAM+Anim
		move.b	#$82,Shield_UseType
		move.b	#$AF,d0
		jmp	PlaySound
; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when he	gets hurt
; ---------------------------------------------------------------------------

Obj01_Hurt:				; XREF: Obj01_Index
		tst.b   Debug_Mode.w	; do you have the cheat enabled?
	        beq.s   .NoDebug	; if not
	        btst	#4,($FFFFF604).w; did you press B?
                beq.s	.NoDebug	; if not
                move.b  #2,$FFFFFE08.w; activate debug mode
                move.b  #0,($FFFFF7CC).w; clear control lock
                move.b  #0,($FFFFF7C8).w; clear control lock
                rts

.NoDebug	jsr	ObjectMove
		addi.w	#$30,Y_Vel(a0)
		btst	#6,Status(a0)
		beq.s	loc_1380C
		subi.w	#$20,Y_Vel(a0)

loc_1380C:
		bsr	Sonic_Water
		bsr.w	Sonic_HurtStop
		bsr.w	Sonic_LevelBound
		bsr.w	Sonic_RecordPos
		bsr.w	Sonic_Animate
		bsr.w	LoadSonicDynPLC
		bsr	ExtCam_Center
		jmp	DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	stop Sonic falling after he's been hurt
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_HurtStop:				; XREF: Obj01_Hurt
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	Y_Pos(a0),d0
		blt	jmpto2_KillSonic
		bsr	Sonic_Floor
		btst	#1,Status(a0)
		bne	locret_13860
		moveq	#0,d0
		move.w	d0,Y_Vel(a0)
		move.w	d0,X_Vel(a0)
		move.w	d0,Inertia(a0)
		move.b	#0,Anim(a0)
		subq.b	#2,Routine(a0)
		move.w	#$78,Off30(a0)

locret_13860:
		rts
; End of function Sonic_HurtStop

Jmpto2_KillSonic	jmp KillSonic
; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when he	dies
; ---------------------------------------------------------------------------

Obj01_Death:					; XREF: Obj01_Index
		tst.b   Debug_Mode.w		; do you have the cheat enabled?
	        beq.s   .NoDebug		; if not
	        btst	#4,$FFFFF604.w		; did you press B?
                beq.s	.NoDebug		; if not
                move.b  #2,$FFFFFE08.w		; activate debug mode
                move.b  #0,$FFFFF7CC.w		; clear control lock
                move.b  #0,$FFFFF7C8.w		; clear control lock
                move.b	#$90,Shield_RAM		; load instashield
                sf	Shield_RAM+Routine2	; clear routine
                rts

.NoDebug	bsr	GameOver
		bsr	Death_Controlanim
		jsr	ObjectFall
		bsr	Sonic_RecordPos
		bsr	Sonic_Animate
		bsr	LoadSonicDynPLC
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Death_Controlanim:
		tst.w	Y_Vel(a0)
		bmi	.rts
		move.b  #$1B,Anim(a0)
		cmpi.b  #4,Current_Character
		bne	.rts
		move.b  #$1A,Anim(a0)
.rts		rts

GameOver:				; XREF: Obj01_Death
		move.w	$FFFFF704.w,d0
		addi.w	#$100,d0
		cmp.w	Y_Pos(a0),d0
		bge	locret_13914

		move.w	#-$38,Y_Vel(a0)
		addq.b	#2,Routine(a0)
		sf	$FFFFFE1E.w	; stop time counter
		addq.b	#1,$FFFFFE1C.w	; update lives	counter
		subq.b	#1,$FFFFFE12.w	; subtract 1 from number of lives
		bne.s	loc_138D4
		move.w	#0,Off3A(a0)
		sf	$FFFFFE1A.w
		move.b	#$39,Ttlcard_RAM.w ; load GAME object
		bsr.s	loc_138C2
		jmp	DLC_new__	; clear SRAM

loc_138C2:
		moveq	#3,d0
		jsr	LoadPLC		; load game over patterns
		buytest	Used_AirHorn
		beq.s	.nop
		moveq	#$FFFFFF8F,d0
		jmp	PlaySample

.nop		moveq	#$FFFFFF8F,d0
		jmp	PlayMusic	; play game over music
; ===========================================================================

loc_138D4:
		move.w	#60,Off3A(a0)	; set time delay to 1 second
		tst.b	($FFFFFE1A).w	; is TIME OVER tag set?
		beq.s	locret_13914	; if not, branch
		move.w	#0,Off3A(a0)
		move.b	#$39,Ttlcard_RAM.w	; load TIME object
		move.b	#$39,Ttlcard_RAM+$40.w	; load OVER object
		move.b	#2,Ttlcard_RAM+Anim_Frame.w
		move.b	#3,Ttlcard_RAM+$40+Anim_Frame.w
		bra.s	loc_138C2
; End of function GameOver

; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when the level is restarted
; ---------------------------------------------------------------------------

Obj01_ResetLevel:			; XREF: Obj01_Index
		tst.w	Off3A(a0)
		beq.s	locret_13914
		subq.w	#1,Off3A(a0)	; subtract 1 from time delay
		bne.s	locret_13914
		st	$FFFFFE03.w ; restart the level

locret_13914:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	animate	Sonic's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Animate:				; XREF: Obj01_Control; et al
		move.l	Player_AniDat,a1
		moveq	#0,d0
Sonic_Animate2:
		move.b	Anim(a0),d0
		cmp.b	Anim_Restart(a0),d0	; is animation set to restart?
		beq.s	SAnim_Do	; if not, branch
		move.b	d0,Anim_Restart(a0)	; set to "no restart"
		move.b	#0,Anim_scriptNum(a0)	; reset	animation
		move.b	#0,Anim_Dur(a0)	; reset	frame duration

SAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	SAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	Status(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,Render_Flags(a0)
		or.b	d1,Render_Flags(a0)
		subq.b	#1,Anim_Dur(a0)	; subtract 1 from frame	duration
		bpl.s	SAnim_Delay	; if time remains, branch
		move.b	d0,Anim_Dur(a0)	; load frame duration

SAnim_Do2:
		moveq	#0,d1
		move.b	Anim_scriptNum(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0		; read sprite number from script
		cmpi.b	#$F0,d0			; GS: is it a flag from FD to FF?
		bhs.s	SAnim_End_FF		; GS: if so, branch to flag routines

SAnim_Next:
		move.b	d0,Anim_Frame(a0)	; load sprite number
		addq.b	#1,Anim_scriptNum(a0)	; next frame number

SAnim_Delay:
		rts
; ===========================================================================

SAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	SAnim_End_FE	; if not, branch
		move.b	#0,Anim_scriptNum(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	SAnim_Next
; ===========================================================================

SAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	SAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,Anim_scriptNum(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	SAnim_Next
; ===========================================================================

SAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	SAnim_End	; if not, branch
		move.b	2(a1,d1.w),Anim(a0) ; read next byte, run that animation

SAnim_End:
		rts
; ===========================================================================
  ; Ported S3K routine for this
SAnim_WalkRun:				; XREF: SAnim_Do
		subq.b	#1,Anim_Dur(a0)	; subtract 1 from frame	duration
		bpl.s	SAnim_Delay	; if time remains, branch
		cmpi.b	#$8F,(a0)
		beq	Tails_Tail_Roll
		addq.b	#1,d0		; is animation walking/running?
		bne.w	SAnim_RollJump	; if not, branch
		moveq	#0,d1
		move.b	Angle(a0),d0	; get Sonic's angle
		bmi.s	.c
		beq.s	.c
		subq.b	#1,d0

.c		move.b	Status(a0),d2	; get status
		andi.b	#1,d2		; is Sonic mirrored horizontally?
		bne.s	loc_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc_13A78:
		andi.b	#$FC,Render_Flags(a0)
		eor.b	d1,d2
		or.b	d2,Render_Flags(a0)
		tst.b   PeelOut_Flag	; is sonic speelouting?
                bne.s   .nopush		; if so, branch
		btst	#5,Status(a0)	; check if Sonic is pushing
		bne.w	SAnim_Push	; if he is, branch away
.nopush		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	Inertia(a0),d2	; get Sonic's speed
		bpl.s	loc_13A9C	; if more than 0, branch
		neg.w	d2		; negate it

loc_13A9C:
		tst.b   PeelOut_Flag	; is sonic speelouting?
                bne.s   .here		; if so, branch
		lea	SonAni_Run,a1	; use running animation
		tst.b	Sonic_SuperFly.w
		bmi.s	.fly
		cmpi.w	#$600,d2	; is Sonic at running speed?
		bhs.s	loc_13AB4	; if yes, branch
		lea	SonAni_Walk,a1	; use walking animation
		add.b	d0,d0		; multiply d0 with 2
		bra	loc_13AB4	; branch away

.fly		move.w	#$700,d2	; tell that you have some speed (cheat to get proper animation speed)
		bra	loc_13AB4	; branch away

.here		lea	SonAni_Speelout,a1; Speelout ani
		move.w	#$520,d2	; tell that you have some speed (cheat to get proper animation speed)
loc_13AB4:
		add.b	d0,d0		; multiply d0 with 2
		move.b	d0,d3		; move d0 to d3
		move.b	Anim_scriptNum(a0),d1; current script id
		move.b	1(a1,d1.w),d0	; get the frame number from the script
		cmpi.b	#-2,d0		; is the id $FE?
		bne.s	.nope		; if not, go away
                move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,Anim_scriptNum(a0); jump back d0 bytes in the script
		sub.b	d0,d1		; get the new id for script
		move.b	1(a1,d1.w),d0	; read sprite number

.nope		cmpi.b	#-1,d0		; is it $FF?
		bne.s	loc_12742	; if not, go away
		move.b	#0,Anim_scriptNum(a0); set back to first frame in the script
		move.b	1(a1),d0	; get new animation id

loc_12742:
		move.b	d0,Anim_Frame(a0); put d0 to animation frame
		add.b	d3,Anim_Frame(a0); add angle to the frame
		subq.b	#1,Anim_Dur(a0)	; subtract 1 from durablity of the frame
		bpl.s	rts_1		; if on plus, branch away
		neg.w	d2		; negate d2
		addi.w	#$800,d2	; add $800
		bpl.s	loc_1275A	; if on plus, branch
		moveq	#0,d2		; othervise clear d2

loc_1275A:
		lsr.w	#8,d2		; shift right 8 bits
		move.b	d2,Anim_Dur(a0)	; set the duration
		addq.b	#1,Anim_scriptNum(a0); add 1 to script number
rts_1		rts
; ===========================================================================

SAnim_RollJump:				; XREF: SAnim_WalkRun
		addq.b	#1,d0		; is animation rolling/jumping?
		bne	SAnim_Push	; if not, branch
		move.w	Inertia(a0),d2	; get Sonic's speed
		bpl.s	loc_13ADE
		neg.w	d2

loc_13ADE:
		move.l	PAni_Roll2,a1	; get the animation
		cmpi.w	#$600,d2	; is Sonic moving fast?
		bhs.s	loc_13AF0	; if yes, branch
		move.l	PAni_Roll,a1	; get the animation

loc_13AF0:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc_13AFA
		moveq	#0,d2

loc_13AFA:
		lsr.w	#8,d2
		move.b	d2,Anim_Dur(a0)	; modify frame duration
		move.b	Status(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,Render_Flags(a0)
		or.b	d1,Render_Flags(a0)
		bra.w	SAnim_Do2
; ===========================================================================

SAnim_Push:				; XREF: SAnim_RollJump
		move.w	Inertia(a0),d2	; get Sonic's speed
		bmi.s	loc_13B1E
		neg.w	d2

loc_13B1E:
		addi.w	#$800,d2
		bpl.s	loc_13B26
		moveq	#0,d2

loc_13B26:
		lsr.w	#6,d2
		move.b	d2,Anim_Dur(a0)	; modify frame duration
		move.l	PAni_Push,a1	; get the animation
		move.b	Status(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,Render_Flags(a0)
		or.b	d1,Render_Flags(a0)
		bra.w	SAnim_Do2

Tails_Tail_Roll:
		move.w	X_Vel(a2),d1	; get X velocity
		move.w	Y_Vel(a2),d2	; get Y velocity
		jsr	CalcAngle	; calculate angle
		moveq	#0,d0
		move.b	Status(a0),d2	; get status
		andi.b	#1,d2		; clear all bits except 0
		bne	.left		; branch if bit 0 was set
		not.b	d1
		bra	.Right

.left		addi.b	#$80,d1		; get angle from left side
.Right		addi.b	#$10,d1		; add 10 to the angle
		bpl.s	.Positive	; if is positive, branch
		moveq	#3,d0

.Positive	andi.b	#$FC,Render_Flags(a0)
		eor.b	d0,d2
		or.b	d2,Render_Flags(a0)
		lsr.b	#3,d1		; shift bits right by 3 (Divide by 8)
		andi.b	#$C,d1		; clear all bits except 2 and 3
		move.b	d1,d3		; move d0 to d3
		lea	Tail_Roll,a1	; get the animation
		move.b	#3,Anim_Dur(a0)	; set duration
		bsr	SAnim_Do2
		add.b	d3,Anim_Frame(a0); set the correct frame to animation frame
		rts
; End of function Sonic_Animate

; ===========================================================================

SonicAniData:
	include "_anim\Sonic.asm"
KnuxAniData:
	include "_anim\Knux.asm"
TailsAniData:
	include "_anim\Tails.asm"

; ---------------------------------------------------------------------------
; Sonic	pattern	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadSonicDynPLC:			; XREF: Obj01_Control; et al
		move.l	Player_DPLCLoc,a2
		move.w	#$F000,d4
		move.l	Player_ArtLoc,d6
		jmp	Load_DPLC
; End of function LoadSonicDynPLC

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0A - drowning countdown numbers and small bubbles (LZ)
; ---------------------------------------------------------------------------

Obj0A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj0A_Index(pc,d0.w),d1
		jmp	Obj0A_Index(pc,d1.w)
; ===========================================================================
Obj0A_Index:	dc.w Obj0A_Main-Obj0A_Index, Obj0A_Animate-Obj0A_Index
		dc.w Obj0A_ChkWater-Obj0A_Index, Obj0A_Display-Obj0A_Index
		dc.w Obj0A_Delete2-Obj0A_Index,	Obj0A_Countdown-Obj0A_Index
		dc.w Obj0A_AirLeft-Obj0A_Index,	Obj0A_Display-Obj0A_Index
		dc.w Obj0A_Delete2-Obj0A_Index
; ===========================================================================

Obj0A_Main:				; XREF: Obj0A_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj64,Mappings_Offset(a0)
		move.w	#$8348,Art_Tile(a0)
		move.b	#$84,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#1,Priority(a0)
		move.b	Subtype(a0),d0
		bpl.s	loc_13D00
		addq.b	#8,Routine(a0)
		move.l	#Map_obj0A,Mappings_Offset(a0)
		move.w	#$376,Art_Tile(a0)
		andi.w	#$7F,d0
		move.b	d0,Off33(a0)
		bra.w	Obj0A_Countdown
; ===========================================================================

loc_13D00:
		move.b	d0,Anim(a0)
		move.w	X_pos(a0),Off30(a0)
		move.w	#-$88,Y_Vel(a0)

Obj0A_Animate:				; XREF: Obj0A_Index
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite

Obj0A_ChkWater:				; XREF: Obj0A_Index
		move.w	($FFFFF646).w,d0
		cmp.w	Y_Pos(a0),d0	; has bubble reached the water surface?
		blo.s	Obj0A_Wobble	; if not, branch
		move.b	#6,Routine(a0)
		addq.b	#7,Anim(a0)
		cmpi.b	#$D,Anim(a0)
		beq.s	Obj0A_Display
		bra.s	Obj0A_Display
; ===========================================================================

Obj0A_Wobble:
		cmpi.b	#2,Shield_RAM+Inertia
	        beq	Obj0A_Delete
		tst.b	($FFFFF7C7).w
		beq.s	loc_13D44
		addq.w	#4,Off30(a0)

loc_13D44:
		move.b	Angle(a0),d0
		addq.b	#1,Angle(a0)
		andi.w	#$7F,d0
		lea	(Obj0A_WobbleData).l,a1
		move.b	(a1,d0.w),d0
		ext.w	d0
		add.w	Off30(a0),d0
		move.w	d0,X_pos(a0)
		bsr.s	Obj0A_ShowNumber
		jsr	ObjectMove
		tst.b	Render_Flags(a0)
		bpl.s	Obj0A_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj0A_Display:				; XREF: Obj0A_Index
		bsr.s	Obj0A_ShowNumber
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete2:				; XREF: Obj0A_Index
		jmp	DeleteObject
; ===========================================================================

Obj0A_AirLeft:				; XREF: Obj0A_Index
		cmpi.w	#$C,($FFFFFE14).w ; check air remaining
		bhi.s	Obj0A_Delete3	; if higher than $C, branch
		subq.w	#1,Off38(a0)
		bne.s	Obj0A_Display2
		move.b	#$E,Routine(a0)
		addq.b	#7,Anim(a0)
		bra.s	Obj0A_Display
; ===========================================================================

Obj0A_Display2:
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite
		tst.b	Render_Flags(a0)
		bpl.s	Obj0A_Delete3
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete3:
		jmp	DeleteObject
; ===========================================================================

Obj0A_ShowNumber:			; XREF: Obj0A_Wobble; Obj0A_Display
		tst.w	Off38(a0)
		beq.s	locret_13E1A
		subq.w	#1,Off38(a0)
		bne.s	locret_13E1A
		cmpi.b	#7,Anim(a0)
		bhs.s	locret_13E1A
		move.w	#$F,Off38(a0)
		clr.w	Y_Vel(a0)
		move.b	#$80,Render_Flags(a0)
		move.w	X_pos(a0),d0
		sub.w	($FFFFF700).w,d0
		addi.w	#$80,d0
		move.w	d0,X_pos(a0)
		move.w	Y_Pos(a0),d0
		sub.w	($FFFFF704).w,d0
		addi.w	#$80,d0
		move.w	d0,X_Pos2(a0)
		move.b	#$C,Routine(a0)

locret_13E1A:
		rts
; ===========================================================================
Obj0A_WobbleData:
		dc.b 0, 0, 0, 0, 0, 0,	1, 1, 1, 1, 1, 2, 2, 2,	2, 2, 2
		dc.b 2,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 3, 3, 4, 3
		dc.b 3,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 2, 2, 2, 2
		dc.b 2,	2, 2, 1, 1, 1, 1, 1, 0,	0, 0, 0, 0, 0, -1, -1
		dc.b -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3
		dc.b -3, -3, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3, -2
		dc.b -2, -2, -2, -2, -1, -1, -1, -1, -1
; ===========================================================================

Obj0A_Countdown:			; XREF: Obj0A_Index
		tst.w	Off2C(a0)
		bne.w	loc_13F86
		cmpi.b	#6,Object_RAM+Routine
		bhs.w	locret_1408C
		btst	#6,Object_RAM+Status
		beq.w	locret_1408C
		subq.w	#1,Off38(a0)
		bpl.w	loc_13FAC
		move.w	#59,Off38(a0)
		move.w	#1,Off36(a0)
		jsr	RandomNumber
		andi.w	#1,d0
		move.b	d0,Off34(a0)
		move.w	($FFFFFE14).w,d0 ; check air remaining
		cmpi.w	#$19,d0
		beq.s	Obj0A_WarnSound	; play sound if	air is $19
		cmpi.w	#$14,d0
		beq.s	Obj0A_WarnSound
		cmpi.w	#$F,d0
		beq.s	Obj0A_WarnSound
		cmpi.w	#$C,d0
		bhi.s	Obj0A_ReduceAir	; if air is above $C, branch
		bne.s	loc_13F02
		moveq	#$FFFFFF92,d0
		jsr	PlaySound	; play countdown music

loc_13F02:
		subq.b	#1,Off32(a0)
		bpl.s	Obj0A_ReduceAir
		move.b	Off33(a0),Off32(a0)
		bset	#7,Off36(a0)
		bra.s	Obj0A_ReduceAir
; ===========================================================================

Obj0A_WarnSound:			; XREF: Obj0A_Countdown
		move.w	#$C2,d0
		jsr	(PlaySound).l ;	play "ding-ding" warning sound

Obj0A_ReduceAir:
		subq.w	#1,($FFFFFE14).w ; subtract 1 from air remaining
		bhs.w	Obj0A_GoMakeItem ; if air is above 0, branch
		bsr.w	ResumeMusic
		move.b	#$81,($FFFFF7C8).w ; lock controls

		moveq	#$FFFFFF80,d0
		jsr	PlayMusic	; reset music

		move.w	#$B2,d0
		jsr	(PlaySound).l ;	play drowning sound
		move.b	#$A,Off34(a0)
		move.w	#1,Off36(a0)
		sf	If_Spindash.w
		move.w	#$78,Off2C(a0)
		move.l	a0,-(sp)
		lea	Object_RAM,a0
		bsr.w	Sonic_ResetOnFloor
		move.b	#$17,Anim(a0)	; use Sonic's drowning animation
		bset	#1,Status(a0)
		bset	#7,Art_Tile(a0)
		move.w	#0,Y_Vel(a0)
		move.w	#0,X_Vel(a0)
		move.w	#0,Inertia(a0)
		move.b	#1,($FFFFF744).w
		movea.l	(sp)+,a0
		rts
; ===========================================================================

loc_13F86:
		subq.w	#1,Off2C(a0)
		bne.s	loc_13F94
		move.b	#6,Object_RAM+Routine
		rts
; ===========================================================================

loc_13F94:
		move.l	a0,-(sp)
		lea	Object_RAM,a0
		jsr	ObjectMove
		addi.w	#$10,Y_Vel(a0)
		movea.l	(sp)+,a0
		bra.s	loc_13FAC
; ===========================================================================

Obj0A_GoMakeItem:			; XREF: Obj0A_ReduceAir
		bra.s	Obj0A_MakeItem
; ===========================================================================

loc_13FAC:
		tst.w	Off36(a0)
		beq.w	locret_1408C
		subq.w	#1,Off3A(a0)
		bpl.w	locret_1408C

Obj0A_MakeItem:
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		move.w	d0,Off3A(a0)
		jsr	SingleObjLoad
		bne.w	locret_1408C
		move.b	#$A,0(a1)	; load object
		move.w	Object_RAM+X_Pos,X_pos(a1) ; match X position to Sonic
		moveq	#6,d0
		btst	#0,Object_RAM+Status
		beq.s	loc_13FF2
		neg.w	d0
		move.b	#$40,Angle(a1)

loc_13FF2:
		add.w	d0,X_pos(a1)
		move.w	Object_RAM+Y_Pos,Y_Pos(a1)
		move.b	#6,Subtype(a1)
		tst.w	Off2C(a0)
		beq.w	loc_1403E
		andi.w	#7,Off3A(a0)
		addi.w	#0,Off3A(a0)
		move.w	Object_RAM+Y_Pos,d0
		subi.w	#$C,d0
		move.w	d0,Y_Pos(a1)
		jsr	RandomNumber
		move.b	d0,Angle(a1)
		move.w	($FFFFFE04).w,d0
		andi.b	#3,d0
		bne.s	loc_14082
		move.b	#$E,Subtype(a1)
		bra.s	loc_14082
; ===========================================================================

loc_1403E:
		btst	#7,Off36(a0)
		beq.s	loc_14082
		move.w	($FFFFFE14).w,d2
		lsr.w	#1,d2
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	loc_1406A
		bset	#6,Off36(a0)
		bne.s	loc_14082
		move.b	d2,Subtype(a1)
		move.w	#$1C,Off38(a1)

loc_1406A:
		tst.b	Off34(a0)
		bne.s	loc_14082
		bset	#6,Off36(a0)
		bne.s	loc_14082
		move.b	d2,Subtype(a1)
		move.w	#$1C,Off38(a1)

loc_14082:
		subq.b	#1,Off34(a0)
		bpl.s	locret_1408C
		clr.w	Off36(a0)

locret_1408C:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	play music for LZ/SBZ3 after a countdown
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ResumeMusic:				; XREF: Obj64_Wobble; Sonic_Water; Obj0A_ReduceAir
		cmpi.w	#$C,($FFFFFE14).w
		bhi.s	loc_140AC
		move.b	Music_StorePrevID.w,d0
		tst.b   ($FFFFFE2D).w
	        beq.s   .c

                moveq	#$FFFFFF87,d0	; the music id
		buytest	Used_AltMusic
		beq.s	.c
		moveq	#Music_Invin,d0

.c        	jsr	PlayMusic
loc_140AC:
		move.w	#$1E,($FFFFFE14).w
		sf	Bubbles_RAM+Off32
		rts
; End of function ResumeMusic

; ===========================================================================
Ani_obj0A:
	include "_anim\obj0A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - drowning countdown numbers (LZ)
; ---------------------------------------------------------------------------
Map_obj0A:
	include "_maps\obj0A.asm"

Object_Sparks:
		jsr	ObjectMove		; move the object
		addi.w  #$18,Y_Vel(a0)		; add velocity
		lea	Ani_LightningShield,a1	; get animations
		jsr	AnimateSprite		; animate
		tst.b	Routine(a0)		; check routine counter
		bne	loc_19898		; if not 0, branch
		jmp	DisplaySprite		; display

loc_19898:
		jmp	DeleteObject		; delete

Elemental_Shields:
		moveq	#0,d0
		move.b	Subtype(a0),d0
		move.w	.Index(pc,d0.w),d1
		jmp	.Index(pc,d1.w)
; ===========================================================================
.Index:		dc.w .Main-.Index
		dc.w .Shields_Main-.Index
		dc.w Object_Sparks-.Index

.Main		addq.b	#2,Subtype(a0)
		move.b	#1,Priority(a0)
		move.b	#$18,X_Visible(a0)
		move.w	#$1818,Y_Radius(a0)
		move.w	#$54E,Art_Tile(a0)

.Shields_Main	moveq	#0,d0
		move.b	Routine2(a0),d0		; get secondary routine counter
		add.b	Shield_Type_obj(a0),d0	; get shield ID
                move.w	.Index2(pc,d0.w),d1	; index address
		jmp	.Index2(pc,d1.w)	; jump to index
; ===========================================================================
.Index2:	dc.w .NoProgram-.Index2, .InstashieldMain-.Index2, .InstashieldDisPlay-.Index2, .Insta_Count-.Index2
		dc.w BubbleShield_init-.Index2, BubbleShield_main-.Index2, .NoProgram-.Index2, .NoProgram-.Index2
		dc.w ElectricShield_init-.Index2, ElectricShield_main-.Index2, .NoProgram-.Index2, .NoProgram-.Index2
		dc.w FireShield_init-.Index2, FireShield_main-.Index2, FireShield_Use-.Index2, .NoProgram-.Index2
		dc.w Shield_init-.Index2, Shield_Main-.Index2, .NoProgram-.Index2, .NoProgram-.Index2

.Insta_Count	subq.b	#1,Routine(a0)
		bne	.NoProgram
		sf	Routine2(a0)
		bra	LightningShield_FlashWater_normal
.NoProgram	rts

.InstashieldMain
		addq.b	#2,Routine2(a0)				; advance routine counter
		move.l	#Map_InstaShield,Mappings_Offset(a0)	; load the mappings
		move.l	#ArtUnc_InstaShield,Shield_ArtLoc_obj(a0); load art location
		move.l	#DPLC_InstaShield,Shield_DPLCLoc_obj(a0); load DPLC
		move.l	#Ani_InstaShield,Shield_AniLoc_obj(a0)	; load Animations
		clr.l	Anim_Frame(a0)				; clear animations for easy reset functions
		move.b	#1,Shield_UseType_obj(a0)		; set shield use to instashield

.InstashieldDisplay
		bsr	Shields_SetFlip
		bsr	Shields_Animate
		move.b	#1,Inertia(a0)
		tst.b	Anim(a0)		; is animation 0?
		beq	Shields_Display		; if is, branch
		move.b	#$81,Shield_UseType_obj(a0); set the shield type to used instashield
		move.b	#0,Inertia(a0)
		sf	Routine2(a0)
		move.b	#1,Priority(a0)				; set priority
Instarts	rts

Shields_SetFlip:
		move.b	Object_RAM+Render_Flags,d0
		move.b	d0,Render_Flags(a0)	; get info of how to render the object
		andi.b	#3,d0			; filter everything but flip flags
		move.b	d0,Status(a0)		; save to status bitfield
		rts

Shields_Animate:
		move.l	Shield_AniLoc_obj(a0),a1	; get animation file
		jmp	AnimateSprite			; animate the sprite

Shields_Display:
                tst.b	$FFFFFE2D.w			; is invinciblity active?
		bne	Instarts			; if is, branch

		move.w	Object_RAM+X_Pos,X_Pos(a0)	; Get Sonic's X position
		move.w	Object_RAM+Y_Pos,Y_Pos(a0)	; Get Sonic's Y position

		move.l	Shield_DPLCLoc_obj(a0),a2	; get DPLC file
	 	move.l	Shield_ArtLoc_obj(a0),d6	; get art file
                move.w	#$A9C0,d4			; get VRAM address
        	jsr	Load_DPLC			; get DPLC's

                jmp	DisplaySprite			; display sprites

Shield_init:
		addq.b	#2,Routine2(a0)				; advance routine counter
		move.l	#Map_obj38,Mappings_Offset(a0)		; load the mappings
		move.l	#0,Anim_Frame(a0)			; clear animations for easy reset functions
		move.b	#4,Render_Flags(a0) 			; render on plane A
		move.b	#1,Priority(a0)				; set priority
		move.b	#-1,Shield_ArtLoc_obj(a0)

Shield_Main:
		tst.b	$FFFFFE2D.w			; is invinciblity active?
		bne.s	Shield_stars			; if is, branch
		tst.b	Shield_ArtLoc_obj(a0)
		bpl.s	.cont

		move.b	#0,Shield_ArtLoc_obj(a0)
		lea	ArtComp_Shield,a2		; sparks graphics
		move.l	#$69C00002,d6			; VRAM location
		jsr	CompDecToVRAM			; decompress

.cont		move.b	#5,Inertia(a0)
		move.w	Object_RAM+X_Pos,X_Pos(a0)	; Get Sonic's X position
		move.w	Object_RAM+Y_Pos,Y_Pos(a0)	; Get Sonic's Y position

		lea	Ani_obj38,a1
		jsr	AnimateSprite
		jmp	DisplaySprite

Shield_stars:
		move.b	#-1,Shield_ArtLoc_obj(a0)
		rts

BubbleShield_init:
		addq.b	#2,Routine2(a0)				; advance routine counter
		move.l	#Map_BubbleShield,Mappings_Offset(a0)	; load the mappings
		move.l	#ArtUnc_BubbleShield,Shield_ArtLoc_obj(a0); load art location
		move.l	#DPLC_BubbleShield,Shield_DPLCLoc_obj(a0); load DPLC
		move.l	#Ani_BubbleShield,Shield_AniLoc_obj(a0)	; load Animations
		move.l	#0,Anim_Frame(a0)			; clear animations for easy reset functions
		move.b	#$82,Shield_UseType_obj(a0)		; set shield use to not-in-use bubbleshield
		move.b	#4,Render_Flags(a0) 			; render on plane A
		move.b	#1,Priority(a0)				; set priority

BubbleShield_main:
		bsr.w	Resumemusic
                move.b	#2,Inertia(a0)
		bsr	Shields_Animate
		bra	Shields_Display

ElectricShield_init:
		addq.b	#2,Routine2(a0)					; advance routine counter
		move.l	#Map_LighteningShield,Mappings_Offset(a0);	 load the mappings
		move.l	#ArtUnc_LighteningShield,Shield_ArtLoc_obj(a0)	; load art location
		move.l	#DPLC_LighteningShield,Shield_DPLCLoc_obj(a0)	; load DPLC
		move.l	#Ani_LightningShield,Shield_AniLoc_obj(a0)	; load Animations

		clr.l	Anim_Frame(a0)			; clear animations for easy reset functions
		move.b	#$83,Shield_UseType_obj(a0)	; set shield use to not-in-use electric shield
		move.b	#4,Render_Flags(a0)		; render on plane A

		lea	Comp_Sparks,a2			; sparks graphics
		move.l	#$6F000002,d6			; VRAM location
		jmp	CompDecToVRAM			; decompress

ElectricShield_main:
		btst	#6,Object_RAM+Status		; is Sonic underwater?
		bne	LightningShield_FlashWater	; if is, branch
		bsr	Shields_Animate
		move.b	#3,Inertia(a0)
		move.b	#1,Priority(a0)			; in front of Sonic
		cmpi.b	#$E,Anim_Frame(a0)		; check ani frame
		blo	.continue			; branch if lower or same
		move.b	#3,Priority(a0)			; behind sonic
.continue	bra	Shields_Display

FireShield_init:
		addq.b	#2,Routine2(a0)				; advance routine counter
		move.l	#Map_FireShield,Mappings_Offset(a0)	; load the mappings
		move.l	#artUnc_FireShield,Shield_ArtLoc_obj(a0); load art location
		move.l	#DPLC_FireShield,Shield_DPLCLoc_obj(a0)	; load DPLC
		move.l	#Ani_FireShield,Shield_AniLoc_obj(a0)	; load Animations
		clr.l	Anim_Frame(a0)				; clear animations for easy reset functions
		move.b	#$84,Shield_UseType_obj(a0)		; set shield use to not-in-use fire shield
		rts
FireShield_Use:
	        btst	#7,Shield_UseType_obj(a0); check bit 7
	        bne	.StopMove		; if set, branch
		clr.w	Object_RAM+Y_Vel	; clear sonic's Y velocity
	        move.w	#16,Object_RAM+Off3E	; prevent sonic from moving left
		cmpi.b	#$C,Anim_Frame(a0)	; is frame $C being displayed?
		bne	FireShield_main		; if not, branch
.StopMove	move.b	#2,Routine2(a0)		; come back to normal routine
FireShield_main:
		btst	#6,Object_RAM+Status	; is Sonic underwater?
		bne	.SetToNormal		; if not, branch
		move.b	#4,Inertia(a0)
		bsr	Shields_SetFlip
		bsr	Shields_Animate
		move.b	#1,Priority(a0)
		cmpi.b	#$F,Anim_Frame(a0)
		blo	.continue
		move.b	#3,Priority(a0)
.continue	bra	Shields_Display

.SetToNormal	sf	Routine2(a0)
		sf	Shield_Type_obj(a0)
		move.b	#0,Inertia(a0)
		rts

LightningShield_FlashWater:
		sf	Shield_Type_obj(a0)
		move.b	#0,Inertia(a0)
		move.b	#6,Routine2(a0)		; use routine to get pallet normal
		move.b	#3,Routine(a0)		; time in frames (-1)
		lea	Palette_Ncurr,a1		; normal pallet
		lea	Palette_NTarget,a2		; target pallet
		lea	Palette_UCurr,a3		; water pallet
		moveq	#$1F,d0

.SetToWhite	move.l	(a1),(a2)+ 		; store normal pallet
		move.l	#$CCC0CCC,(a1)+		; set to white
		move.l	#$CCC0CCC,(a3)+		; set to white
		dbf	d0,.SetToWhite		; loop
		rts

LightningShield_FlashWater_normal:
        	moveq	#$1F,d0
		lea	Palette_Ncurr,a2		; normal pallet
		lea	Palette_NTarget,a1		; target pallet
		lea	Palette_UCurr,a4		; water pallet
		lea	Pal_LZWater-$20,a3	; get LZ pallet

.loop		move.l	(a1)+,(a2)+		; make pallet be normal again
                move.l	(a3)+,(a4)+		; load water pallet
		dbf	d0,.loop		; loop
		lea	Palette_Ncurr,a2		; get normal pallet
		lea	Palette_UCurr,a3		; and water pallet
		jmp	LoadPlayerPallets	; correct player pallets

          include _maps/Insta.asm
          include _maps/Bubbleshield.asm
          include _maps/Lightning.asm
          include _maps/FireShield.asm

          include _inc/DPLC_Insta.asm
          include _inc/DPLC_BubbleShield.asm
          include _inc/DPLC_Lightning.asm
          include _inc/DPLC_FireShield.asm

Ani_InstaShield:
		dc.w .AniNormal-Ani_InstaShield,.AniEmpty-Ani_InstaShield
.AniNormal	dc.b 0, 0, 1, 2, 3, 4, 5, 6, 6, 6, $FD, 1
.AniEmpty	dc.b 0, 7, $FF
                even

Ani_BubbleShield:
		dc.w byte_19A80-Ani_BubbleShield
		dc.w byte_19AB8-Ani_BubbleShield
		dc.w byte_19ABF-Ani_BubbleShield

byte_19A80:	dc.b 1,   0,	  9,   0,   9,	 0,   9,   1,  $A,   1,	 $A,   1,  $A,	 2,   9,   2
		dc.b 	9,   2,	  9,   3,  $A,	 3,  $A,   3,  $A,   4,	  9,   4,   9,	 4,   9,   5
		dc.b   $A,   5,	 $A,   5,  $A,	 6,   9,   6,	9,   6,	  9,   7,  $A,	 7,  $A,   7
		dc.b   $A,   8,	  9,   8,   9,	 8,   9, $FF

byte_19AB8:	dc.b	5,   9,	 $B,  $B,  $B, $FD,   0

byte_19ABF:	dc.b	5,  $C,	 $C,  $B, $FD,	 0
		even

Ani_LightningShield:
		dc.w bytet_19A30-Ani_LightningShield
		dc.w byte_19A5C-Ani_LightningShield
		dc.w byte_19A73-Ani_LightningShield

bytet_19A30:	dc.b 1,   0,	  0,   1,   1,	 2,   2,   3,	3,   4,	  4,   5,   5,	 6,   6,   7
		dc.b 	7,   8,	  8,   9,  $A,	$B, $16, $16, $15, $15,	$14, $14, $13, $13, $12, $12
		dc.b  $11, $11,	$10, $10,  $F,	$F,  $E,  $E,	9,  $A,	 $B, $FF

byte_19A5C:	dc.b 0,  $C,	 $D, $17,  $C,	$D, $17,  $C,  $D, $17,	 $C,  $D, $17,	$C,  $D, $17
		dc.b   $C,  $D,	$17,  $C,  $D, $FC, $FF

byte_19A73:	dc.b	3,   0,	  1,   2, $FC, $FF
		even

Ani_FireShield:
		dc.w byte_19A06-Ani_FireShield
		dc.w byte_19A1A-Ani_FireShield

byte_19A06:	dc.b 1, 0, $F, 1, $10, 2, $11, 3, $12, 4, $13, 5, $14, 6, $15, 7
		dc.b $16, 8, $17, $FF

byte_19A1A:	dc.b	1,   9,	 $A,  $B,  $C,	$D,  $E,   9,  $A,  $B,	 $C,  $D,  $E, $FD,   0
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 38 - shield and invincibility stars
; ---------------------------------------------------------------------------

Obj38:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj38_Index(pc,d0.w),d1
		jmp	Obj38_Index(pc,d1.w)
; ===========================================================================
Obj38_Index:	dc.w Obj38_Main-Obj38_Index
		dc.w Obj38_Stars-Obj38_Index
; ===========================================================================

Obj38_Main:				; XREF: Obj38_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj38,Mappings_Offset(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#1,Priority(a0)
		move.b	#$10,X_Visible(a0)
		move.w	#$54E,Art_Tile(a0)
		lea	Comp_Stars,a2
		move.l	#$69C00002,d6
		jmp	CompDecToVRAM
; ===========================================================================

Obj38_Stars:				; XREF: Obj38_Index
		tst.b	($FFFFFE2D).w	; does Sonic have invincibility?
		beq.s	Obj38_Delete2	; if not, branch
		move.w	($FFFFF7A8).w,d0
		move.b	Anim(a0),d1
		subq.b	#1,d1

Obj38_StarTrail:			; XREF: Obj38_Stars
		lsl.b	#3,d1
		move.b	d1,d2
		add.b	d1,d1
		add.b	d2,d1
		addq.b	#4,d1
		sub.b	d1,d0
		move.b	Off30(a0),d1
		sub.b	d1,d0
		addq.b	#4,d1
		cmpi.b	#$18,d1
		blo.s	Obj38_StarTrail2
		moveq	#0,d1

Obj38_StarTrail2:
		move.b	d1,Off30(a0)

Obj38_StarTrail2a:
		lea	($FFFFCB00).w,a1
		lea	(a1,d0.w),a1
		move.w	(a1)+,X_pos(a0)
		move.w	(a1)+,Y_Pos(a0)
		move.b	Object_RAM+Status,Status(a0)
		lea	(Ani_obj38).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj38_Delete2:				; XREF: Obj38_Stars
		jmp	DeleteObject

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 08 - water splash (LZ)
; ---------------------------------------------------------------------------

Obj08:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj08_Index(pc,d0.w),d1
		jmp	Obj08_Index(pc,d1.w)
; ===========================================================================
Obj08_Index:	dc.w Obj08_Main-Obj08_Index
		dc.w Obj08_Display-Obj08_Index
		dc.w Obj08_Delete-Obj08_Index
; ===========================================================================

Obj08_Main:				; XREF: Obj08_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj08,Mappings_Offset(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#1,Priority(a0)
		move.b	#$10,X_Visible(a0)
		move.w	#$4259,Art_Tile(a0)
		move.w	Object_RAM+X_Pos,X_pos(a0) ; copy x-position from Sonic

Obj08_Display:				; XREF: Obj08_Index
		move.w	($FFFFF646).w,Y_Pos(a0) ; copy y-position from water height
		lea	(Ani_obj08).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj08_Delete:				; XREF: Obj08_Index
		jmp	DeleteObject	; delete when animation	is complete
; ===========================================================================
Ani_obj38:
	include "_anim\obj38.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - shield and invincibility stars
; ---------------------------------------------------------------------------
Map_obj38:
	include "_maps\obj38.asm"
Ani_obj08:
	include "_anim\obj08.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - water splash (LZ)
; ---------------------------------------------------------------------------
Map_obj08:
	include "_maps\obj08.asm"



Sonic_GetCollisionLayer:
		move.l	CollIndx1,($FFFFF796).w		; MJ: load first collision data location
		tst.b	Path_ID				; MJ: is second sollision set to be used?
		beq.s	SAP_First				; MJ: if not, branch
		move.l	CollIndx2,($FFFFF796).w		; MJ: load second collision data location

SAP_First:
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's angle & position as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Sonic_AnglePos:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		bsr	Sonic_GetCollisionLayer
		btst	#3,Status(a0)
		beq.s	loc_14602
		moveq	#0,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		rts
; ===========================================================================

loc_14602:
		moveq	#3,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	Angle(a0),d0
		addi.b	#$20,d0
		bpl.s	loc_14624
		move.b	Angle(a0),d0
		bpl.s	loc_1461E
		subq.b	#1,d0

loc_1461E:
		addi.b	#$20,d0
		bra.s	loc_14630
; ===========================================================================

loc_14624:
		move.b	Angle(a0),d0
		bpl.s	loc_1462C
		addq.b	#1,d0

loc_1462C:
		addi.b	#$1F,d0

loc_14630:
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	Sonic_WalkVertL
		cmpi.b	#$80,d0
		beq.w	Sonic_WalkCeiling
		cmpi.b	#$C0,d0
		beq.w	Sonic_WalkVertR
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	X_Radius(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Sonic_Angle
		tst.w	d1
		beq.s	locret_146BE
		bpl.s	loc_146C0
		cmpi.w	#-$E,d1
		blt.s	locret_146BE
		add.w	d1,Y_Pos(a0)

locret_146BE:
		rts
; ===========================================================================

loc_146C0:
		cmpi.w	#$E,d1
		bgt.s	loc_146CC

loc_146C6:
		add.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

loc_146CC:
		tst.b	Off38(a0)
		bne.s	loc_146C6
		bset	#1,Status(a0)
		sf	PeelOut_Flag
		bclr	#5,Status(a0)
		move.b	#1,Anim_Restart(a0)
		rts
; End of function Sonic_AnglePos

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's angle as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Angle:				; XREF: Sonic_AnglePos; et al
		move.b	($FFFFF76A).w,d2
		cmp.w	d0,d1
		ble.s	loc_1475E
		move.b	($FFFFF768).w,d2
		move.w	d0,d1

loc_1475E:
		btst	#0,d2
		bne.s	loc_1476A
		move.b	d2,Angle(a0)
		rts
; ===========================================================================

loc_1476A:
		move.b	Angle(a0),d2
		addi.b	#$20,d2
		andi.b	#$C0,d2
		move.b	d2,Angle(a0)
		rts
; End of function Sonic_Angle

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk up a vertical slope/wall to	his right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkVertR:			; XREF: Sonic_AnglePos
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Sonic_Angle
		tst.w	d1
		beq.s	locret_147F0
		bpl.s	loc_147F2
		cmpi.w	#-$E,d1
		blt.s	locret_147F0
		add.w	d1,X_pos(a0)

locret_147F0:
		rts
; ===========================================================================

loc_147F2:
		cmpi.w	#$E,d1
		bgt.s	loc_147FE

loc_147F8:
		add.w	d1,X_pos(a0)
		rts
; ===========================================================================

loc_147FE:
		tst.b	Off38(a0)
		bne.s	loc_147F8
		bset	#1,Status(a0)
		sf	PeelOut_Flag
		bclr	#5,Status(a0)
		move.b	#1,Anim_Restart(a0)
		rts
; End of function Sonic_WalkVertR

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk upside-down
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkCeiling:			; XREF: Sonic_AnglePos
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	X_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Sonic_Angle
		tst.w	d1
		beq.s	locret_14892
		bpl.s	loc_14894
		cmpi.w	#-$E,d1
		blt.s	locret_14892
		sub.w	d1,Y_Pos(a0)

locret_14892:
		rts
; ===========================================================================

loc_14894:
		cmpi.w	#$E,d1
		bgt.s	loc_148A0

loc_1489A:
		sub.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

loc_148A0:
		tst.b	Off38(a0)
		bne.s	loc_1489A
		bset	#1,Status(a0)
		sf	PeelOut_Flag
		bclr	#5,Status(a0)
		move.b	#1,Anim_Restart(a0)
		rts
; End of function Sonic_WalkCeiling

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk up a vertical slope/wall to	his left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkVertL:
		move.w	Y_Pos(a0),d2				; MJ: Load Y position
		move.w	X_pos(a0),d3				; MJ: Load X position
		moveq	#0,d0					; MJ: clear d0
		move.b	X_Radius(a0),d0				; MJ: load height
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d2					; MJ: subtract from Y position
		move.b	Y_Radius(a0),d0				; MJ: load width
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d3					; MJ: subtract from X position
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4			; MJ: load address of the angle value set
		movea.w	#-$10,a3
		move.w	#$400,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Sonic_Angle
		tst.w	d1
		beq.s	locret_14934
		bpl.s	loc_14936
		cmpi.w	#-$E,d1
		blt.s	locret_14934
		sub.w	d1,X_pos(a0)

locret_14934:
		rts

; ===========================================================================

loc_14936:
		cmpi.w	#$E,d1
		bgt.s	loc_14942

loc_1493C:
		sub.w	d1,X_pos(a0)
		rts

; ===========================================================================

loc_14942:
		tst.b	Off38(a0)
		bne.s	loc_1493C
		bset	#1,Status(a0)
		sf	PeelOut_Flag
		bclr	#5,Status(a0)
		move.b	#1,Anim_Restart(a0)
		rts
; End of function Sonic_WalkVertL

; ---------------------------------------------------------------------------
; Subroutine to	find which tile	the object is standing on
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Floor_ChkTile:				; XREF: FindFloor; et al
		move.w	d2,d0					; MJ: load Y position
		andi.w	#$0780,d0				; MJ: get within 780 (E00 pixels) in multiples of 80
		add.w	d0,d0					; MJ: multiply by 2
		move.w	d3,d1					; MJ: load X position
		lsr.w	#7,d1					; MJ: shift to right side
		andi.w	#$007F,d1				; MJ: get within 7F
		add.w	d1,d0					; MJ: add calc'd Y to calc'd X
		moveq	#-1,d1					; MJ: prepare FFFF in d3
		movea.l	Layout_Data,a1			; MJ: load address of Layout to a1
		move.b	(a1,d0.w),d1				; MJ: collect correct chunk ID based on the X and Y position
		andi.w	#$FF,d1					; MJ: keep within FF
		lsl.w	#$07,d1					; MJ: multiply by 80
		move.w	d2,d0					; MJ: load Y position
		andi.w	#$0070,d0				; MJ: keep Y within 80 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID
		move.w	d3,d0					; MJ: load X position
		lsr.w	#3,d0					; MJ: divide by 8
		andi.w	#$000E,d0				; MJ: keep X within 10 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID

loc_14996:
		movea.l	d1,a1					; MJ: set address (Chunk to read)
		rts						; MJ: return
; ===========================================================================

loc_1499A:
		andi.w	#$7F,d1
		btst	#6,Render_Flags(a0)
		beq.s	loc_149B2
		addq.w	#1,d1
		cmpi.w	#$29,d1
		bne.s	loc_149B2
		move.w	#$51,d1

loc_149B2:
		ror.w	#7,d1
		ror.w	#2,d1
		move.w	d2,d0
		add.w	d0,d0
		andi.w	#$070,d0
		add.w	d0,d1
		move.w	d3,d0
		lsr.w	#3,d0
		andi.w	#$0E,d0
		add.w	d0,d1
		movea.l	d1,a1
		rts
; End of function Floor_ChkTile


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ColisionChkLayer:
		tst.b	Path_ID				; MJ: is collision set to first?
		beq.s	CCL_NoChange				; MJ: if so, branch
		move.w	d0,d4					; MJ: load block ID to d4
		and.w	#$0FFF,d0				; MJ: clear solid settings of d0
		and.w	#$C000,d4				; MJ: get only second solid settings of d4
		lsr.w	#$02,d4					; MJ: shift them to first solid settings location
		add.w	d4,d0					; MJ: add to rest of block ID

CCL_NoChange:
		rts						; MJ: return


FindFloor:
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		bsr.s	ColisionChkLayer			; MJ: check solid settings to use
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_149DE
		btst	d5,d4
		bne.s	loc_149EC

loc_149DE:
		add.w	a3,d2
		bsr.w	FindFloor2
		sub.w	a3,d2
		addi.w	#$10,d1
		rts
; ===========================================================================

loc_149EC:
		movea.l	($FFFFF796).w,a2			; MJ: load collision index address
		move.b	(a2,d0.w),d0				; MJ: load correct Collision ID based on the Block ID
		andi.w	#$FF,d0					; MJ: clear the left byte
		beq.s	loc_149DE				; MJ: if collision ID is 00, branch
		move.l	Coll_Pointer,a2				; MJ: load angle map data to a2
		move.b	(a2,d0.w),(a4)				; MJ: collect correct angle based on the collision ID
		lsl.w	#4,d0					; MJ: multiply collision ID by 10
		move.w	d3,d1					; MJ: load X position
		btst	#$A,d4					; MJ: is the block mirrored?
		beq.s	loc_14A12				; MJ: if not, branch
		not.w	d1					; MJ: reverse bits of the X position
		neg.b	(a4)					; MJ: reverse the angle ID

loc_14A12:
		btst	#$B,d4					; MJ: is the block flipped?
		beq.s	loc_14A22				; MJ: if not, branch
		addi.b	#$40,(a4)				; MJ: increase angle ID by 40..
		neg.b	(a4)					; MJ: ..reverse the angle ID..
		subi.b	#$40,(a4)				; MJ: ..and subtract 40 again

loc_14A22:
		andi.w	#$F,d1					; MJ: get only within 10 (d1 is pixel based on the collision block)
		add.w	d0,d1					; MJ: add collision ID (x10) (d0 is the collision block being read)
		move.l	Coll_Pointer+4,a2			; MJ: load collision array
		move.b	(a2,d1.w),d0				; MJ: load solid value
		ext.w	d0					; MJ: clear left byte
		eor.w	d6,d4					; MJ: set ceiling/wall bits
		btst	#$B,d4					; MJ: is sonic walking on the left wall?
		beq.s	loc_14A3E				; MJ: if not, branch
		neg.w	d0					; MJ: reverse solid value

loc_14A3E:
		tst.w	d0					; MJ: is the solid data null?
		beq.s	loc_149DE				; MJ: if so, branch
		bmi.s	loc_14A5A				; MJ: if it's negative, branch
		cmpi.b	#$10,d0					; MJ: is it 10?
		beq.s	loc_14A66				; MJ: if so, branch
		move.w	d2,d1					; MJ: load Y position
		andi.w	#$F,d1					; MJ: get only within 10 pixels
		add.w	d1,d0					; MJ: add to solid value
		move.w	#$F,d1					; MJ: set F
		sub.w	d0,d1					; MJ: minus solid value from F
		rts			; d1 = position?	; MJ: return

; ===========================================================================

loc_14A5A:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_149DE

loc_14A66:
		sub.w	a3,d2
		bsr.w	FindFloor2
		add.w	a3,d2
		subi.w	#$10,d1
		rts
; End of function FindFloor


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindFloor2:				; XREF: FindFloor
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		bsr.w	ColisionChkLayer			; MJ: check solid settings to use
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14A86
		btst	d5,d4
		bne.s	loc_14A94

loc_14A86:
		move.w	#$F,d1
		move.w	d2,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts
; ===========================================================================

loc_14A94:
		movea.l	($FFFFF796).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	loc_14A86
		move.l	Coll_Pointer,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d3,d1
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14ABA
		not.w	d1
		neg.b	(a4)

loc_14ABA:
		btst	#$B,d4					; MJ: C to B (because S2 format has two solids)
		beq.s	loc_14ACA
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14ACA:
		andi.w	#$F,d1
		add.w	d0,d1
		move.l	Coll_Pointer+4,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$B,d4					; MJ: C to B (because S2 format has two solids)
		beq.s	loc_14AE6
		neg.w	d0

loc_14AE6:
		tst.w	d0
		beq.s	loc_14A86
		bmi.s	loc_14AFC
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts
; ===========================================================================

loc_14AFC:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14A86
		not.w	d1
		rts
; End of function FindFloor2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

FindWall:
		bsr.w	Floor_ChkTile				; MJ: get chunk/block location
		move.w	(a1),d0					; MJ: load block ID from chunk
		bsr.w	ColisionChkLayer			; MJ: check solid settings to use
		move.w	d0,d4					; MJ: copy to d4
		andi.w	#$3FF,d0				; MJ: clear flip/mirror/etc data
		beq.s	loc_14B1E				; MJ: if it was null, branch
		btst	d5,d4					; MJ: check solid set (C top solid | D Left/right solid)
		bne.s	loc_14B2C				; MJ: if the specific solid is set, branch

loc_14B1E:
		add.w	a3,d3					; MJ: add 10 to X position
		bsr.w	FindWall2
		sub.w	a3,d3					; MJ: minus 10 from X position
		addi.w	#$10,d1
		rts
; ===========================================================================

loc_14B2C:
		movea.l	($FFFFF796).w,a2			; MJ: load address of collision for level
		move.b	(a2,d0.w),d0				; MJ: load correct colision ID based on the block ID
		andi.w	#$FF,d0					; MJ: keep within FF
		beq.s	loc_14B1E				; MJ: if it's null, branch
		move.l	Coll_Pointer,a2				; MJ: load angle map data to a2
		move.b	(a2,d0.w),(a4)				; MJ: load angle set location based on collision ID
		lsl.w	#4,d0					; MJ: multiply by 10
		move.w	d2,d1					; MJ: load Y position
		btst	#$B,d4					; MJ: is the block ID flipped?
		beq.s	loc_14B5A				; MJ: if not, branch
		not.w	d1
		addi.b	#$40,(a4)				; MJ: increase angle set by 40
		neg.b	(a4)					; MJ: negate to opposite
		subi.b	#$40,(a4)				; MJ: decrease angle set by 40

loc_14B5A:
		btst	#$A,d4					; MJ: is the block ID mirrored?
		beq.s	loc_14B62				; MJ: if not, branch
		neg.b	(a4)					; MJ: negate to opposite

loc_14B62:
		andi.w	#$F,d1
		add.w	d0,d1
		move.l	Coll_Pointer+8,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14B7E
		neg.w	d0

loc_14B7E:
		tst.w	d0
		beq.s	loc_14B1E
		bmi.s	loc_14B9A
		cmpi.b	#$10,d0
		beq.s	loc_14BA6
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts
; ===========================================================================

loc_14B9A:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14B1E

loc_14BA6:
		sub.w	a3,d3
		bsr.w	FindWall2
		add.w	a3,d3
		subi.w	#$10,d1
		rts
; End of function FindWall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindWall2:				; XREF: FindWall
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		bsr.w	ColisionChkLayer			; MJ: check solid settings to use
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14BC6
		btst	d5,d4
		bne.s	loc_14BD4

loc_14BC6:
		move.w	#$F,d1
		move.w	d3,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts
; ===========================================================================

loc_14BD4:
		movea.l	($FFFFF796).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	loc_14BC6
		move.l	Coll_Pointer,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d2,d1
		btst	#$B,d4					; MJ: C to B (because S2 format has two solids)
		beq.s	loc_14C02
		not.w	d1
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14C02:
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14C0A
		neg.b	(a4)

loc_14C0A:
		andi.w	#$F,d1
		add.w	d0,d1
		move.l	Coll_Pointer+8,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14C26
		neg.w	d0

loc_14C26:
		tst.w	d0
		beq.s	loc_14BC6
		bmi.s	loc_14C3C
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts
; ===========================================================================

loc_14C3C:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14BC6
		not.w	d1
		rts
; End of function FindWall2

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkSpeed:			; XREF: Sonic_Move
		move.l	X_pos(a0),d3
		move.l	Y_Pos(a0),d2
		move.w	X_Vel(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	Y_Vel(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc_14D1A
		move.b	d1,d0
		bpl.s	loc_14D14
		subq.b	#1,d0

loc_14D14:
		addi.b	#$20,d0
		bra.s	loc_14D24
; ===========================================================================

loc_14D1A:
		move.b	d1,d0
		bpl.s	loc_14D20
		addq.b	#1,d0

loc_14D20:
		addi.b	#$1F,d0

loc_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc_14D3C
		addq.w	#8,d2

loc_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Sonic_WalkSpeed


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_CheckFloorColl:				; XREF: Sonic_Jump
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		addi.b	#$20,d0
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	loc_14FD6
		cmpi.b	#$80,d0
		beq.w	Sonic_DontRunOnWalls
		cmpi.b	#$C0,d0
		beq.w	sub_14E50

; End of function Sonic_CheckFloorColl

; ---------------------------------------------------------------------------
; Subroutine to	make Sonic land	on the floor after jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_HitFloor:				; XREF: Sonic_Floor
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	X_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#0,d2

loc_14DD0:
		move.b	($FFFFF76A).w,d3
		cmp.w	d0,d1
		ble.s	loc_14DDE
		move.b	($FFFFF768).w,d3
		exg	d0,d1

loc_14DDE:
		btst	#0,d3
		beq.s	locret_14DE6
		move.b	d2,d3

locret_14DE6:
		rts

; End of function Sonic_HitFloor

; ===========================================================================

loc_14DF0:				; XREF: Sonic_WalkSpeed
		addi.w	#$A,d2
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.b	#0,d2

loc_14E0A:				; XREF: sub_14EB4
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14E16
		move.b	d2,d3

locret_14E16:
		rts

; ---------------------------------------------------------------------------
; Subroutine allowing objects to interact with the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitFloor:
		move.w	X_pos(a0),d3

; End of function ObjHitFloor


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitFloor2:
		move.w	Y_Pos(a0),d2
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14E4E
		move.b	#0,d3

locret_14E4E:
		rts
; End of function ObjHitFloor2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14E50:				; XREF: Sonic_CheckFloorColl
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#-$40,d2
		bra.w	loc_14DD0

; End of function sub_14E50


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14EB4:				; XREF: Sonic_Floor
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3

loc_14EBC:
		addi.w	#$A,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.b	#-$40,d2
		bra.w	loc_14E0A

; End of function sub_14EB4

; ---------------------------------------------------------------------------
; Subroutine to	detect when an object hits a wall to its right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitWallRight:
		add.w	X_pos(a0),d3
		move.w	Y_Pos(a0),d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14F06
		move.b	#-$40,d3

locret_14F06:
		rts

; End of function ObjHitWallRight

; ---------------------------------------------------------------------------
; Subroutine preventing	Sonic from running on walls and	ceilings when he
; touches them
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_DontRunOnWalls:			; XREF: Sonic_Floor; et al
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	X_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#-$80,d2
		bra.w	loc_14DD0
; End of function Sonic_DontRunOnWalls

; ===========================================================================

loc_14F7C:
		subi.w	#$A,d2
		eori.w	#$F,d2
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.b	#-$80,d2
		bra.w	loc_14E0A

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitCeiling:
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindFloor				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14FD4
		move.b	#-$80,d3

locret_14FD4:
		rts
; End of function ObjHitCeiling

; ===========================================================================

loc_14FD6:				; XREF: Sonic_CheckFloorColl
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3
		moveq	#0,d0
		move.b	X_Radius(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	Y_Radius(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#$40,d2
		bra.w	loc_14DD0

; ---------------------------------------------------------------------------
; Subroutine to	stop Sonic when	he jumps at a wall
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_HitWall:				; XREF: Sonic_Floor
		move.w	Y_Pos(a0),d2
		move.w	X_pos(a0),d3

loc_1504A:
		subi.w	#$A,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.b	#$40,d2
		bra.w	loc_14E0A
; End of function Sonic_HitWall

; ---------------------------------------------------------------------------
; Subroutine to	detect when an object hits a wall to its left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitWallLeft:
		add.w	X_pos(a0),d3
		move.w	Y_Pos(a0),d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#-$10,a3
		move.w	#$400,d6
		moveq	#$D,d5					; MJ: set solid type to check
		bsr.w	FindWall				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_15098
		move.b	#$40,d3

locret_15098:
		rts
; End of function ObjHitWallLeft

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 06
; ---------------------------------------------------------------------------
EndingPlayerSprites:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	.i(pc,d0.w),d1
		jmp	.i(pc,d1.w)

; ===========================================================================
.i		dc.w .spawn-.i, .main-.i
; ===========================================================================

.list		dc.b	$1F, 5, 36, $1F

.spawn		move.b	Subtype(a0),d0
		move.b	d0,Current_Character.w
		add.b	d0,Current_Character.w
		move.b	.list(pc,d0.w),Anim(a0)

		move.b	#$8F,Tails_Tail_RAM.w		; load Tail's Tail
		sf	Sonic_ForceRollMode.w
		addq.b	#2,Routine(a0)
		move.w	#$780,Art_Tile(a0)
		move.b	#2,Priority(a0)
		move.b	#$18,X_Visible(a0)
		ori.b	#4,Render_Flags(a0)
		jsr	SetPlayerDisplay

.main		jsr	Sonic_Animate
		jsr	LoadSonicDynPLC

		move.l	a0,Tails_Tail_RAM+Off3C.w
		move.w	x_pos(a0),d0
		andi.w	#-$80,d0
		move.w	$FFFFF700.w,d1
		subi.w	#$80,d1
		andi.w	#-$80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	.del
		jmp	DisplaySprite

.del		jmp	DeleteObject

; ---------------------------------------------------------------------------
; Object 07
; ---------------------------------------------------------------------------

GenerateAnimals:
		moveq	#0,d6
		move.b	Subtype(a0),d6
		movea.l	a0,a1

		move.w	x_pos(a0),d5
		move.w	y_pos(a0),d4
		bra.s	.load

.loadAnimal	jsr	SingleObjLoad
		bne.s	.end
.load		move.b	#$28,(a1)
		move.b	#4,Render_Flags(a1)

		jsr	RandomNumber
		and.w	#$F,d0
		move.b	.subs(pc,d0.w),Subtype(a1)

		move.w	d5,x_pos(a1)
		move.w	d4,y_pos(a1)
		jsr	RandomNumber
		and.w	#$F,d0
		add.w	#$20,d0
		sub.w	d0,y_pos(a1)

		swap	d0
		and.w	#$3C,d0
		sub.w	#$1E,d0
		add.w	d0,x_pos(a1)
		dbf	d6,.loadAnimal

.end		rts

.subs		dc.b $A, $C, $D, $E, $F, $10, $11, $12, $13, $14, $A, $C, $F, $10, $13, $14
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 66 - rotating disc that grabs Sonic (SBZ)
; ---------------------------------------------------------------------------

Obj66:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj66_Index(pc,d0.w),d1
		jmp	Obj66_Index(pc,d1.w)
; ===========================================================================
Obj66_Index:	dc.w Obj66_Main-Obj66_Index
		dc.w Obj66_Action-Obj66_Index
		dc.w Obj66_Display-Obj66_Index
		dc.w Obj66_Release-Obj66_Index
; ===========================================================================

Obj66_Main:				; XREF: Obj66_Index
		addq.b	#2,Routine(a0)
		moveq	#1,d1
		movea.l	a0,a1
		bra.s	Obj66_MakeItem
; ===========================================================================

Obj66_Loop:
		jsr	SingleObjLoad
		bne.s	loc_150FE
		move.b	#$66,0(a1)
		addq.b	#4,Routine(a1)
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	#3,Priority(a1)
		move.b	#$10,Anim_Frame(a1)

Obj66_MakeItem:				; XREF: Obj66_Main
		move.l	#Map_obj66,Mappings_Offset(a1)
		move.w	#$4348,Art_Tile(a1)
		ori.b	#4,Render_Flags(a1)
		move.b	#$38,X_Visible(a1)

		dbf	d1,Obj66_Loop

loc_150FE:
		move.b	#$30,X_Visible(a0)
		move.b	#4,Priority(a0)
		move.w	#$3C,Off30(a0)
		move.b	#1,Off34(a0)
		move.b	Subtype(a0),Off38(a0)

Obj66_Action:				; XREF: Obj66_Index
		bsr.w	Obj66_ChkSwitch
		tst.b	Render_Flags(a0)
		bpl.w	Obj66_Display
		move.w	#$30,d1
		move.w	d1,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	X_pos(a0),d4
		jsr	SolidObject
		btst	#5,Status(a0)
		beq.w	Obj66_Display
		lea	Object_RAM,a1
		moveq	#$E,d1
		move.w	X_pos(a1),d0
		cmp.w	X_pos(a0),d0
		blo.s	Obj66_GrabSonic
		moveq	#7,d1

Obj66_GrabSonic:
		cmp.b	Anim_Frame(a0),d1
		bne.s	Obj66_Display
		move.b	d1,Off32(a0)
		addq.b	#4,Routine(a0)
		move.b	#1,($FFFFF7C8).w ; lock	controls
		move.b	#2,Anim(a1)	; make Sonic use "rolling" animation
		move.w	#$800,Inertia(a1)
		move.w	#0,X_Vel(a1)
		move.w	#0,Y_Vel(a1)
		bclr	#5,Status(a0)
		bclr	#5,Status(a1)
		bset	#1,Status(a1)
		sf	PeelOut_Flag
		sf	IF_Spindash
		move.w	X_pos(a1),d2
		move.w	Y_Pos(a1),d3
		bsr.w	Obj66_ChgPos
		add.w	d2,X_pos(a1)
		add.w	d3,Y_Pos(a1)
		asr	X_pos(a1)
		asr	Y_Pos(a1)

Obj66_Display:				; XREF: Obj66_Index
		jmp	MarkObjGone
; ===========================================================================

Obj66_Release:				; XREF: Obj66_Index
		move.b	Anim_Frame(a0),d0
		cmpi.b	#4,d0
		beq.s	loc_151C8
		cmpi.b	#7,d0
		bne.s	loc_151F8

loc_151C8:
		cmp.b	Off32(a0),d0
		beq.s	loc_151F8
		lea	Object_RAM,a1
		move.w	#0,X_Vel(a1)
		move.w	#$800,Y_Vel(a1)
		cmpi.b	#4,d0
		beq.s	loc_151F0
		move.w	#$800,X_Vel(a1)
		move.w	#$800,Y_Vel(a1)

loc_151F0:
		sf	($FFFFF7C8).w	; unlock controls
		subq.b	#4,Routine(a0)

loc_151F8:
		bsr.s	Obj66_ChkSwitch
		bsr.s	Obj66_ChgPos
		jmp	MarkObjGone

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj66_ChkSwitch:			; XREF: Obj66_Action
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	Off38(a0),d0
		btst	#0,(a2,d0.w)	; is switch pressed?
		beq.s	loc_15224	; if not, branch
		tst.b	Off36(a0)		; has switch previously	been pressed?
		bne.s	Obj66_Animate	; if yes, branch
		neg.b	Off34(a0)
		move.b	#1,Off36(a0)	; set to "previously pressed"
		bra.s	Obj66_Animate
; ===========================================================================

loc_15224:
		sf	Off36(a0)		; set to "not yet pressed"

Obj66_Animate:
		subq.b	#1,Anim_Dur(a0)
		bpl.s	locret_15246
		move.b	#7,Anim_Dur(a0)
		move.b	Off34(a0),d1
		move.b	Anim_Frame(a0),d0
		add.b	d1,d0
		andi.b	#$F,d0
		move.b	d0,Anim_Frame(a0)

locret_15246:
		rts
; End of function Obj66_ChkSwitch


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj66_ChgPos:				; XREF: Obj66_GrabSonic
		lea	Object_RAM,a1
		moveq	#0,d0
		move.b	Anim_Frame(a0),d0
		add.w	d0,d0
		lea	Obj66_PosData(pc,d0.w),a2
		move.b	(a2)+,d0
		ext.w	d0
		add.w	X_pos(a0),d0
		move.w	d0,X_pos(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	Y_Pos(a0),d0
		move.w	d0,Y_Pos(a1)
		rts
; End of function Obj66_ChgPos

; ===========================================================================
Obj66_PosData:	dc.b  $E0,   0,	$E2,  $E ; disc	x-pos, Sonic x-pos, disc y-pos,	Sonic y-pos
		dc.b  $E8, $18,	$F2, $1E
		dc.b	0, $20,	 $E, $1E
		dc.b  $18, $18,	$1E,  $E
		dc.b  $20,   0,	$1E, $F2
		dc.b  $18, $E8,	 $E, $E2
		dc.b	0, $E0,	$F2, $E2
		dc.b  $E8, $E8,	$E2, $F2
; ---------------------------------------------------------------------------
; Sprite mappings - rotating disc that grabs Sonic (SBZ)
; ---------------------------------------------------------------------------
Map_obj66:
	include "_maps\obj66.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 67 - disc that	you run	around (SBZ)
; ---------------------------------------------------------------------------

Obj67:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj67_Index(pc,d0.w),d1
		jmp	Obj67_Index(pc,d1.w)
; ===========================================================================
Obj67_Index:	dc.w Obj67_Main-Obj67_Index
		dc.w Obj67_Action-Obj67_Index
; ===========================================================================

Obj67_Main:				; XREF: Obj67_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj67,Mappings_Offset(a0)
		move.w	#$C344,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#8,X_Visible(a0)
		move.w	X_pos(a0),Off32(a0)
		move.w	Y_Pos(a0),Off30(a0)
		move.b	#$18,Off34(a0)
		move.b	#$48,Off38(a0)
		move.b	Subtype(a0),d1	; get object type
		andi.b	#$F,d1		; read only the	2nd digit
		beq.s	loc_15546
		move.b	#$10,Off34(a0)
		move.b	#$38,Off38(a0)

loc_15546:
		move.b	Subtype(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asl.w	#3,d1
		move.w	d1,Off36(a0)
		move.b	Status(a0),d0
		ror.b	#2,d0
		andi.b	#-$40,d0
		move.b	d0,Angle(a0)

Obj67_Action:				; XREF: Obj67_Index
		bsr.w	Obj67_MoveSonic
		bsr.w	Obj67_MoveSpot
		bra.w	Obj67_ChkDel
; ===========================================================================

Obj67_MoveSonic:			; XREF: Obj67_Action
		moveq	#0,d2
		move.b	Off38(a0),d2
		move.w	d2,d3
		add.w	d3,d3
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		sub.w	Off32(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bhs.s	loc_155A8
		move.w	Y_Pos(a1),d1
		sub.w	Off30(a0),d1
		add.w	d2,d1
		cmp.w	d3,d1
		bhs.s	loc_155A8
		btst	#1,Status(a1)
		beq.s	loc_155B8
		sf	Off3A(a0)
		rts
; ===========================================================================

loc_155A8:
		tst.b	Off3A(a0)
		beq.s	locret_155B6
		sf	Off38(a1)
		sf	Off3A(a0)

locret_155B6:
		rts
; ===========================================================================

loc_155B8:
		tst.b	Off3A(a0)
		bne.s	loc_155E2
		move.b	#1,Off3A(a0)
		btst	#2,Status(a1)
		bne.s	loc_155D0
		sf	Anim(a1)
		move.w	#0,Off3E(a1)

loc_155D0:
		bclr	#5,Status(a1)
		move.b	#1,Anim_Restart(a1)
		move.b	#1,Off38(a1)

loc_155E2:
		move.w	Inertia(a1),d0
		tst.w	Off36(a0)
		bpl.s	loc_15608
		cmpi.w	#-$400,d0
		ble.s	loc_155FA
		move.w	#-$400,Inertia(a1)
		rts
; ===========================================================================

loc_155FA:
		cmpi.w	#-$F00,d0
		bge.s	locret_15606
		move.w	#-$F00,Inertia(a1)

locret_15606:
		rts
; ===========================================================================

loc_15608:
		cmpi.w	#$400,d0
		bge.s	loc_15616
		move.w	#$400,Inertia(a1)
		rts
; ===========================================================================

loc_15616:
		cmpi.w	#$F00,d0
		ble.s	locret_15622
		move.w	#$F00,Inertia(a1)

locret_15622:
		rts
; ===========================================================================

Obj67_MoveSpot:				; XREF: Obj67_Action
		move.w	Off36(a0),d1
		add.w	d1,Angle(a0)
		move.b	Angle(a0),d1
		jsr	(CalcSine).l
		move.w	Off30(a0),d2
		move.w	Off32(a0),d3
		moveq	#0,d4
		move.b	Off34(a0),d4
		lsl.w	#8,d4
		move.l	d4,d5
		muls.w	d0,d4
		swap	d4
		muls.w	d1,d5
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,Y_Pos(a0)
		move.w	d5,X_pos(a0)
		rts
; ===========================================================================

Obj67_ChkDel:				; XREF: Obj67_Action
		move.w	Off32(a0),d0
		andi.w	#-$80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#-$80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj67_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj67_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - disc that you run around (SBZ)
; (It's just a small blob that moves around in a circle. The disc itself is
; part of the level tiles.)
; ---------------------------------------------------------------------------
Map_obj67:
	include "_maps\obj67.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 68 - conveyor belts (SBZ)
; ---------------------------------------------------------------------------

Obj68:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj68_Index(pc,d0.w),d1
		jmp	Obj68_Index(pc,d1.w)
; ===========================================================================
Obj68_Index:	dc.w Obj68_Main-Obj68_Index
		dc.w Obj68_Action-Obj68_Index
; ===========================================================================

Obj68_Main:				; XREF: Obj68_Index
		addq.b	#2,Routine(a0)
		move.b	#128,Off38(a0)	; set width to 128 pixels
		move.b	Subtype(a0),d1	; get object type
		andi.b	#$F,d1		; read only the	2nd digit
		beq.s	loc_156BA	; if zero, branch
		move.b	#56,Off38(a0)	; set width to 56 pixels

loc_156BA:
		move.b	Subtype(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asr.w	#4,d1
		move.w	d1,Off36(a0)	; set belt speed

Obj68_Action:				; XREF: Obj68_Index
		bsr.s	Obj68_MoveSonic
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj68_Delete
		rts
; ===========================================================================

Obj68_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj68_MoveSonic:			; XREF: Obj68_Action
		moveq	#0,d2
		move.b	Off38(a0),d2
		move.w	d2,d3
		add.w	d3,d3
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bhs.s	locret_1572E
		move.w	Y_Pos(a1),d1
		sub.w	Y_Pos(a0),d1
		addi.w	#$30,d1
		cmpi.w	#$30,d1
		bhs.s	locret_1572E
		btst	#1,Status(a1)
		bne.s	locret_1572E
		move.w	Off36(a0),d0
		add.w	d0,X_pos(a1)

locret_1572E:
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 69 - spinning platforms and trapdoors (SBZ)
; ---------------------------------------------------------------------------

Obj69:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj69_Index(pc,d0.w),d1
		jmp	Obj69_Index(pc,d1.w)
; ===========================================================================
Obj69_Index:	dc.w Obj69_Main-Obj69_Index
		dc.w Obj69_Trapdoor-Obj69_Index
		dc.w Obj69_Spinner-Obj69_Index
; ===========================================================================

Obj69_Main:				; XREF: Obj69_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj69,Mappings_Offset(a0)
		move.w	#$4492,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$80,X_Visible(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#$F,d0
		mulu.w	#$3C,d0
		move.w	d0,Off32(a0)
		tst.b	Subtype(a0)
		bpl.s	Obj69_Trapdoor
		addq.b	#2,Routine(a0)
		move.l	#Map_obj69a,Mappings_Offset(a0)
		move.w	#$4DF,Art_Tile(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#2,Anim(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; get object type
		move.w	d0,d1
		andi.w	#$F,d0		; read only the	2nd digit
		mulu.w	#6,d0		; multiply by 6
		move.w	d0,Off30(a0)	; set time delay
		move.w	d0,Off32(a0)
		andi.w	#$70,d1
		addi.w	#$10,d1
		lsl.w	#2,d1
		subq.w	#1,d1
		move.w	d1,Off36(a0)
		bra.s	Obj69_Spinner
; ===========================================================================

Obj69_Trapdoor:				; XREF: Obj69_Index
		subq.w	#1,Off30(a0)
		bpl.s	Obj69_Animate
		move.w	Off32(a0),Off30(a0)
		bchg	#0,Anim(a0)
		tst.b	Render_Flags(a0)
		bpl.s	Obj69_Animate
		move.w	#$BB,d0
		jsr	(PlaySound).l ;	play door sound

Obj69_Animate:
		lea	(Ani_obj69).l,a1
		jsr	AnimateSprite
		tst.b	Anim_Frame(a0)		; is frame number 0 displayed?
		bne.s	Obj69_NotSolid	; if not, branch
		move.w	#$4B,d1
		move.w	#$C,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	X_pos(a0),d4
		jsr	SolidObject
		jmp	MarkObjGone
; ===========================================================================

Obj69_NotSolid:
		btst	#3,Status(a0)
		beq.s	Obj69_Display
		lea	Object_RAM,a1
		bclr	#3,Status(a1)
		bclr	#3,Status(a0)
		sf	Routine2(a0)

Obj69_Display:
		jmp	MarkObjGone
; ===========================================================================

Obj69_Spinner:				; XREF: Obj69_Index
		move.w	($FFFFFE04).w,d0
		and.w	Off36(a0),d0
		bne.s	Obj69_Delay
		move.b	#1,Off34(a0)

Obj69_Delay:
		tst.b	Off34(a0)
		beq.s	Obj69_Animate2
		subq.w	#1,Off30(a0)
		bpl.s	Obj69_Animate2
		move.w	Off32(a0),Off30(a0)
		sf	Off34(a0)
		bchg	#0,Anim(a0)

Obj69_Animate2:
		lea	(Ani_obj69).l,a1
		jsr	AnimateSprite
		tst.b	Anim_Frame(a0)		; check	if frame number	0 is displayed
		bne.s	Obj69_NotSolid2	; if not, branch
		move.w	#$1B,d1
		move.w	#7,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	X_pos(a0),d4
		jsr	SolidObject
		jmp	MarkObjGone
; ===========================================================================

Obj69_NotSolid2:
		btst	#3,Status(a0)
		beq.s	Obj69_Display2
		lea	Object_RAM,a1
		bclr	#3,Status(a1)
		bclr	#3,Status(a0)
		sf	Routine2(a0)

Obj69_Display2:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj69:
	include "_anim\obj69.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - trapdoor (SBZ)
; ---------------------------------------------------------------------------
Map_obj69:
	include "_maps\obj69.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spinning platforms (SBZ)
; ---------------------------------------------------------------------------
Map_obj69a:
	include "_maps\obj69a.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6A - ground saws and pizza cutters (SBZ)
; ---------------------------------------------------------------------------

Obj6A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		jmp	Obj6A_Index(pc,d0.w)
; ===========================================================================
Obj6A_Index:	bra.s Obj6A_Main
		bra.s Obj6A_Action
; ===========================================================================

Obj6A_Main:				; XREF: Obj6A_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj6A,Mappings_Offset(a0)
		move.w	#$43B5,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$20,X_Visible(a0)
		move.w	X_pos(a0),Off3A(a0)
		move.w	Y_Pos(a0),Off38(a0)
		cmpi.b	#3,Subtype(a0)
		bhs.s	Obj6A_Action
		move.b	#$A2,Coll(a0)

Obj6A_Action:				; XREF: Obj6A_Index
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj6A_TypeIndex(pc,d0.w),d1
		jsr	Obj6A_TypeIndex(pc,d1.w)
		move.w	Off3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj6A_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj6A_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj6A_TypeIndex:dc.w Obj6A_Type00-Obj6A_TypeIndex, Obj6A_Type01-Obj6A_TypeIndex
		dc.w Obj6A_Type02-Obj6A_TypeIndex, Obj6A_Type03-Obj6A_TypeIndex
		dc.w Obj6A_Type04-Obj6A_TypeIndex
; ===========================================================================

Obj6A_Type00:				; XREF: Obj6A_TypeIndex
		rts
; ===========================================================================

Obj6A_Type01:				; XREF: Obj6A_TypeIndex
		move.w	#$60,d1
		moveq	#0,d0
		move.b	($FFFFFE6C).w,d0
		btst	#0,Status(a0)
		beq.s	Obj6A_Animate01
		neg.w	d0
		add.w	d1,d0

Obj6A_Animate01:
		move.w	Off3A(a0),d1
		sub.w	d0,d1
		move.w	d1,X_pos(a0)	; move saw sideways
		subq.b	#1,Anim_Dur(a0)
		bpl.s	loc_15A46
		move.b	#2,Anim_Dur(a0)	; time between frame changes
		bchg	#0,Anim_Frame(a0)	; change frame

loc_15A46:
		tst.b	Render_Flags(a0)
		bpl.s	locret_15A60
		move.w	($FFFFFE04).w,d0
		andi.w	#$F,d0
		bne.s	locret_15A60
		move.w	#$B0,d0
		jsr	(PlaySound).l ;	play saw sound

locret_15A60:
		rts
; ===========================================================================

Obj6A_Type02:				; XREF: Obj6A_TypeIndex
		move.w	#$30,d1
		moveq	#0,d0
		move.b	($FFFFFE64).w,d0
		btst	#0,Status(a0)
		beq.s	Obj6A_Animate02
		neg.w	d0
		addi.w	#$80,d0

Obj6A_Animate02:
		move.w	Off38(a0),d1
		sub.w	d0,d1
		move.w	d1,Y_Pos(a0)	; move saw vertically
		subq.b	#1,Anim_Dur(a0)
		bpl.s	loc_15A96
		move.b	#2,Anim_Dur(a0)
		bchg	#0,Anim_Frame(a0)

loc_15A96:
		tst.b	Render_Flags(a0)
		bpl.s	locret_15AB0
		move.b	($FFFFFE64).w,d0
		cmpi.b	#$18,d0
		bne.s	locret_15AB0
		move.w	#$B0,d0
		jsr	(PlaySound).l ;	play saw sound

locret_15AB0:
		rts
; ===========================================================================

Obj6A_Type03:				; XREF: Obj6A_TypeIndex
		tst.b	Off3D(a0)
		bne.s	Obj6A_Animate03
		move.w	Object_RAM+X_Pos,d0
		subi.w	#$C0,d0
		blo.s	loc_15B02
		sub.w	X_pos(a0),d0
		blo.s	loc_15B02
		move.w	Object_RAM+Y_Pos,d0
		subi.w	#$80,d0
		cmp.w	Y_Pos(a0),d0
		bhs.s	locret_15B04
		addi.w	#$100,d0
		cmp.w	Y_Pos(a0),d0
		blo.s	locret_15B04
		move.b	#1,Off3D(a0)
		move.w	#$600,X_Vel(a0)	; move object to the right
		move.b	#$A2,Coll(a0)
		move.b	#2,Anim_Frame(a0)
		move.w	#$B0,d0
		jsr	(PlaySound).l ;	play saw sound

loc_15B02:
		addq.l	#4,sp

locret_15B04:
		rts
; ===========================================================================

Obj6A_Animate03:			; XREF: ROM:00015AB6j
		jsr	ObjectMove
		move.w	X_pos(a0),Off3A(a0)
		subq.b	#1,Anim_Dur(a0)
		bpl.s	locret_15B24
		move.b	#2,Anim_Dur(a0)
		bchg	#0,Anim_Frame(a0)

locret_15B24:
		rts
; ===========================================================================

Obj6A_Type04:				; XREF: Obj6A_TypeIndex
		tst.b	Off3D(a0)
		bne.s	Obj6A_Animate04
		move.w	Object_RAM+X_Pos,d0
		addi.w	#$E0,d0
		sub.w	X_pos(a0),d0
		bhs.s	loc_15B74
		move.w	Object_RAM+Y_Pos,d0
		subi.w	#$80,d0
		cmp.w	Y_Pos(a0),d0
		bhs.s	locret_15B76
		addi.w	#$100,d0
		cmp.w	Y_Pos(a0),d0
		blo.s	locret_15B76
		move.b	#1,Off3D(a0)
		move.w	#-$600,X_Vel(a0)	; move object to the left
		move.b	#$A2,Coll(a0)
		move.b	#2,Anim_Frame(a0)
		move.w	#$B0,d0
		jsr	(PlaySound).l ;	play saw sound

loc_15B74:
		addq.l	#4,sp

locret_15B76:
		rts
; ===========================================================================

Obj6A_Animate04:
		jsr	ObjectMove
		move.w	X_pos(a0),Off3A(a0)
		subq.b	#1,Anim_Dur(a0)
		bpl.s	locret_15B96
		move.b	#2,Anim_Dur(a0)
		bchg	#0,Anim_Frame(a0)

locret_15B96:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - ground saws	and pizza cutters (SBZ)
; ---------------------------------------------------------------------------
Map_obj6A:
	include "_maps\obj6A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6B - stomper (SBZ)
; ---------------------------------------------------------------------------

Obj6B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj6B_Index(pc,d0.w),d1
		jmp	Obj6B_Index(pc,d1.w)
; ===========================================================================
Obj6B_Index:	dc.w Obj6B_Main-Obj6B_Index
		dc.w Obj6B_Action-Obj6B_Index

Obj6B_Var:	dc.b  $40,  $C,	$80,   1 ; width, height, ????,	type number
		dc.b  $1C, $20,	$38,   3
		dc.b  $1C, $20,	$40,   4
		dc.b  $1C, $20,	$60,   4
		dc.b  $80, $40,	  0,   5
; ===========================================================================

Obj6B_Main:				; XREF: Obj6B_Index
		addq.b	#2,Routine(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	Obj6B_Var(pc,d0.w),a3
		move.b	(a3)+,X_Visible(a0)
		move.b	(a3)+,Y_Radius(a0)
		lsr.w	#2,d0
		move.b	d0,Anim_Frame(a0)
		move.l	#Map_obj6B,Mappings_Offset(a0)
		move.w	#$22C0,Art_Tile(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ/SBZ3
		bne.s	Obj6B_SBZ12	; if not, branch
		bset	#0,($FFFFF7CB).w
		beq.s	Obj6B_SBZ3

Obj6B_ChkGone:				; XREF: Obj6B_SBZ3
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	Obj6B_Delete
		bclr	#7,2(a2,d0.w)

Obj6B_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj6B_SBZ3:				; XREF: Obj6B_Main
		move.w	#$41F0,Art_Tile(a0)
		cmpi.w	#$A80,X_pos(a0)
		bne.s	Obj6B_SBZ12
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	Obj6B_SBZ12
		btst	#0,2(a2,d0.w)
		beq.s	Obj6B_SBZ12
		sf	($FFFFF7CB).w
		bra.s	Obj6B_ChkGone
; ===========================================================================

Obj6B_SBZ12:				; XREF: Obj6B_Main
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.w	X_pos(a0),Off34(a0)
		move.w	Y_Pos(a0),Off30(a0)
		moveq	#0,d0
		move.b	(a3)+,d0
		move.w	d0,Off3C(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		bpl.s	Obj6B_Action
		andi.b	#$F,d0
		move.b	d0,Off3E(a0)
		move.b	(a3),Subtype(a0)
		cmpi.b	#5,(a3)
		bne.s	Obj6B_ChkGone2
		bset	#4,Render_Flags(a0)

Obj6B_ChkGone2:
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	Obj6B_Action
		bclr	#7,2(a2,d0.w)

Obj6B_Action:				; XREF: Obj6B_Index
		move.w	X_pos(a0),-(sp)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj6B_TypeIndex(pc,d0.w),d1
		jsr	Obj6B_TypeIndex(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	Render_Flags(a0)
		bpl.s	Obj6B_ChkDel
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	Y_Radius(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsr	SolidObject

Obj6B_ChkDel:
		move.w	Off34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_15D64
		jmp	DisplaySprite
; ===========================================================================

loc_15D64:
		cmpi.b	#1,($FFFFFE10).w
		bne.s	Obj6B_Delete2
		sf	($FFFFF7CB).w
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	Obj6B_Delete2
		bclr	#7,2(a2,d0.w)

Obj6B_Delete2:
		jmp	DeleteObject
; ===========================================================================
Obj6B_TypeIndex:dc.w Obj6B_Type00-Obj6B_TypeIndex, Obj6B_Type01-Obj6B_TypeIndex
		dc.w Obj6B_Type02-Obj6B_TypeIndex, Obj6B_Type03-Obj6B_TypeIndex
		dc.w Obj6B_Type04-Obj6B_TypeIndex, Obj6B_Type05-Obj6B_TypeIndex
; ===========================================================================

Obj6B_Type00:				; XREF: Obj6B_TypeIndex
		rts
; ===========================================================================

Obj6B_Type01:				; XREF: Obj6B_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_15DB4
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	Off3E(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_15DC2
		move.b	#1,Off38(a0)

loc_15DB4:
		move.w	Off3C(a0),d0
		cmp.w	Off3A(a0),d0
		beq.s	loc_15DE0
		addq.w	#2,Off3A(a0)

loc_15DC2:
		move.w	Off3A(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_15DD4
		neg.w	d0
		addi.w	#$80,d0

loc_15DD4:
		move.w	Off34(a0),d1
		sub.w	d0,d1
		move.w	d1,X_pos(a0)
		rts
; ===========================================================================

loc_15DE0:
		addq.b	#1,Subtype(a0)
		move.w	#$B4,Off36(a0)
		sf	Off38(a0)
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_15DC2
		bset	#0,2(a2,d0.w)
		bra.s	loc_15DC2
; ===========================================================================

Obj6B_Type02:				; XREF: Obj6B_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_15E14
		subq.w	#1,Off36(a0)
		bne.s	loc_15E1E
		move.b	#1,Off38(a0)

loc_15E14:
		tst.w	Off3A(a0)
		beq.s	loc_15E3C
		subq.w	#2,Off3A(a0)

loc_15E1E:
		move.w	Off3A(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_15E30
		neg.w	d0
		addi.w	#$80,d0

loc_15E30:
		move.w	Off34(a0),d1
		sub.w	d0,d1
		move.w	d1,X_pos(a0)
		rts
; ===========================================================================

loc_15E3C:
		subq.b	#1,Subtype(a0)
		sf	Off38(a0)
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_15E1E
		bclr	#0,2(a2,d0.w)
		bra.s	loc_15E1E
; ===========================================================================

Obj6B_Type03:				; XREF: Obj6B_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_15E7C
		tst.w	Off3A(a0)
		beq.s	loc_15E6A
		subq.w	#1,Off3A(a0)
		bra.s	loc_15E8E
; ===========================================================================

loc_15E6A:
		subq.w	#1,Off36(a0)
		bpl.s	loc_15E8E
		move.w	#$3C,Off36(a0)
		move.b	#1,Off38(a0)

loc_15E7C:
		addq.w	#8,Off3A(a0)
		move.w	Off3A(a0),d0
		cmp.w	Off3C(a0),d0
		bne.s	loc_15E8E
		sf	Off38(a0)

loc_15E8E:
		move.w	Off3A(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_15EA0
		neg.w	d0
		addi.w	#$38,d0

loc_15EA0:
		move.w	Off30(a0),d1
		add.w	d0,d1
		move.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

Obj6B_Type04:				; XREF: Obj6B_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_15ED0
		tst.w	Off3A(a0)
		beq.s	loc_15EBE
		subq.w	#8,Off3A(a0)
		bra.s	loc_15EF0
; ===========================================================================

loc_15EBE:
		subq.w	#1,Off36(a0)
		bpl.s	loc_15EF0
		move.w	#$3C,Off36(a0)
		move.b	#1,Off38(a0)

loc_15ED0:
		move.w	Off3A(a0),d0
		cmp.w	Off3C(a0),d0
		beq.s	loc_15EE0
		addq.w	#8,Off3A(a0)
		bra.s	loc_15EF0
; ===========================================================================

loc_15EE0:
		subq.w	#1,Off36(a0)
		bpl.s	loc_15EF0
		move.w	#$3C,Off36(a0)
		sf	Off38(a0)

loc_15EF0:
		move.w	Off3A(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_15F02
		neg.w	d0
		addi.w	#$38,d0

loc_15F02:
		move.w	Off30(a0),d1
		add.w	d0,d1
		move.w	d1,Y_Pos(a0)
		rts
; ===========================================================================

Obj6B_Type05:				; XREF: Obj6B_TypeIndex
		tst.b	Off38(a0)
		bne.s	loc_15F3E
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	Off3E(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	locret_15F5C
		move.b	#1,Off38(a0)
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_15F3E
		bset	#0,2(a2,d0.w)

loc_15F3E:
		subi.l	#$10000,X_pos(a0)
		addi.l	#$8000,Y_Pos(a0)
		move.w	X_pos(a0),Off34(a0)
		cmpi.w	#$980,X_pos(a0)
		beq.s	loc_15F5E

locret_15F5C:
		rts
; ===========================================================================

loc_15F5E:
		sf	Subtype(a0)
		sf	Off38(a0)
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - stomper and	platforms (SBZ)
; ---------------------------------------------------------------------------
Map_obj6B:
	include "_maps\obj6B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6C - vanishing	platforms (SBZ)
; ---------------------------------------------------------------------------

Obj6C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj6C_Index(pc,d0.w),d1
		jmp	Obj6C_Index(pc,d1.w)
; ===========================================================================
Obj6C_Index:	dc.w Obj6C_Main-Obj6C_Index
		dc.w Obj6C_Vanish-Obj6C_Index
		dc.w Obj6C_Vanish-Obj6C_Index
		dc.w loc_16068-Obj6C_Index
; ===========================================================================

Obj6C_Main:				; XREF: Obj6C_Index
		addq.b	#6,Routine(a0)
		move.l	#Map_obj6C,Mappings_Offset(a0)
		move.w	#$44C3,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$10,X_Visible(a0)
		move.b	#4,Priority(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; get object type
		andi.w	#$F,d0		; read only the	2nd digit
		addq.w	#1,d0		; add 1
		lsl.w	#7,d0		; multiply by $80
		move.w	d0,d1
		subq.w	#1,d0
		move.w	d0,Off30(a0)
		move.w	d0,Off32(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; get object type
		andi.w	#$F0,d0		; read only the	1st digit
		addi.w	#$80,d1
		mulu.w	d1,d0
		lsr.l	#8,d0
		move.w	d0,Off36(a0)
		subq.w	#1,d1
		move.w	d1,Off38(a0)

loc_16068:				; XREF: Obj6C_Index
		move.w	($FFFFFE04).w,d0
		sub.w	Off36(a0),d0
		and.w	Off38(a0),d0
		bne.s	Obj6C_Animate
		subq.b	#4,Routine(a0)
		bra.s	Obj6C_Vanish
; ===========================================================================

Obj6C_Animate:
		lea	(Ani_obj6C).l,a1
		jsr	AnimateSprite
		jmp	MarkObjGone
; ===========================================================================

Obj6C_Vanish:				; XREF: Obj6C_Index
		subq.w	#1,Off30(a0)
		bpl.s	loc_160AA
		move.w	#127,Off30(a0)
		tst.b	Anim(a0)
		beq.s	loc_160A4
		move.w	Off32(a0),Off30(a0)

loc_160A4:
		bchg	#0,Anim(a0)

loc_160AA:
		lea	(Ani_obj6C).l,a1
		jsr	AnimateSprite
		btst	#1,Anim_Frame(a0)	; has platform vanished?
		bne.s	Obj6C_NotSolid	; if yes, branch
		cmpi.b	#2,Routine(a0)
		bne.s	loc_160D6
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(PlatformObject).l
		jmp	MarkObjGone
; ===========================================================================

loc_160D6:
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		jsr	(ExitPlatform).l
		move.w	X_pos(a0),d2
		jsr	(MvSonicOnPtfm2).l
		jmp	MarkObjGone
; ===========================================================================

Obj6C_NotSolid:				; XREF: Obj6C_Vanish
		btst	#3,Status(a0)
		beq.s	Obj6C_Display
		lea	Object_RAM,a1
		bclr	#3,Status(a1)
		bclr	#3,Status(a0)
		move.b	#2,Routine(a0)
		sf	Routine2(a0)

Obj6C_Display:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj6C:
	include "_anim\obj6C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - vanishing platforms	(SBZ)
; ---------------------------------------------------------------------------
Map_obj6C:
	include "_maps\obj6C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6E - electrocution orbs (SBZ)
; ---------------------------------------------------------------------------

Obj6E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj6E_Index(pc,d0.w),d1
		jmp	Obj6E_Index(pc,d1.w)
; ===========================================================================
Obj6E_Index:	dc.w Obj6E_Main-Obj6E_Index
		dc.w Obj6E_Shock-Obj6E_Index
; ===========================================================================

Obj6E_Main:				; XREF: Obj6E_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj6E,Mappings_Offset(a0)
		move.w	#$47E,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#$28,X_Visible(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0	; read object type
		lsl.w	#4,d0		; multiply by $10
		subq.w	#1,d0
		move.w	d0,Off34(a0)

Obj6E_Shock:				; XREF: Obj6E_Index
		move.w	($FFFFFE04).w,d0
		and.w	Off34(a0),d0
		bne.s	Obj6E_Animate
		move.b	#1,Anim(a0)		; run "shocking" animation
		tst.b	Render_Flags(a0)
		bpl.s	Obj6E_Animate
		move.w	#$B1,d0
		jsr	PlaySound	; play electricity sound

Obj6E_Animate:
		lea	(Ani_obj6E).l,a1
		jsr	AnimateSprite
		move.b	#0,Coll(a0)
		cmpi.b	#3,Shield_RAM+Inertia
	        beq	Obj6E_Display
		cmpi.b	#4,Anim_Frame(a0)	; is frame number 4 displayed?
		bne.s	Obj6E_Display		; if not, branch
		move.b	#$A4,Coll(a0)		; if yes, make object hurt Sonic

Obj6E_Display:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj6E:
	include "_anim\obj6E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - electrocution orbs (SBZ)
; ---------------------------------------------------------------------------
Map_obj6E:
	include "_maps\obj6E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6F - spinning platforms that move around a conveyor belt (SBZ)
; ---------------------------------------------------------------------------

Obj6F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj6F_Index(pc,d0.w),d1
		jsr	Obj6F_Index(pc,d1.w)
		move.w	Off30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_1629A

Obj6F_Display:
		jmp	DisplaySprite
; ===========================================================================

loc_1629A:
		cmpi.b	#2,($FFFFFE11).w ; check if act	is 3
		bne.s	Obj6F_Act1or2	; if not, branch
		cmpi.w	#-$80,d0
		bhs.s	Obj6F_Display

Obj6F_Act1or2:
		move.b	Off2F(a0),d0
		bpl.s	Obj6F_Delete
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bclr	#0,(a2,d0.w)

Obj6F_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj6F_Index:	dc.w Obj6F_Main-Obj6F_Index
		dc.w loc_163D8-Obj6F_Index
; ===========================================================================

Obj6F_Main:				; XREF: Obj6F_Index
		move.b	Subtype(a0),d0
		bmi.w	loc_16380
		addq.b	#2,Routine(a0)
		move.l	#Map_obj69a,Mappings_Offset(a0)
		move.w	#$4DF,Art_Tile(a0)
		move.b	#$10,X_Visible(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	off_164A6(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,Off38(a0)
		move.w	(a2)+,Off30(a0)
		move.l	a2,Off3C(a0)
		andi.w	#$F,d1
		lsl.w	#2,d1
		move.b	d1,Off38(a0)
		move.b	#4,Off3A(a0)
		tst.b	($FFFFF7C0).w
		beq.s	loc_16356
		move.b	#1,Off3B(a0)
		neg.b	Off3A(a0)
		moveq	#0,d1
		move.b	Off38(a0),d1
		add.b	Off3A(a0),d1
		cmp.b	Off39(a0),d1
		blo.s	loc_16352
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_16352
		move.b	Off39(a0),d1
		subq.b	#4,d1

loc_16352:
		move.b	d1,Off38(a0)

loc_16356:
		move.w	(a2,d1.w),Off34(a0)
		move.w	2(a2,d1.w),Off36(a0)
		tst.w	d1
		bne.s	loc_1636C
		move.b	#1,Anim(a0)

loc_1636C:
		cmpi.w	#8,d1
		bne.s	loc_16378
		move.b	#0,Anim(a0)

loc_16378:
		jsr	Obj63_ChangeDir
		bra.w	loc_163D8
; ===========================================================================

loc_16380:				; XREF: Obj6F_Main
		move.b	d0,Off2F(a0)
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bset	#0,(a2,d0.w)
		beq.s	loc_1639A
		jmp	DeleteObject
; ===========================================================================

loc_1639A:
		add.w	d0,d0
		andi.w	#$1E,d0
	;	addi.w	#$114,d0
		lea	Objpos_index_SBZpf,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d1
		movea.l	a0,a1
		bra.s	Obj6F_LoadPform
; ===========================================================================

Obj6F_Loop:
		jsr	SingleObjLoad
		bne.s	loc_163D0

Obj6F_LoadPform:			; XREF: loc_1639A
		move.b	#$6F,(a1)
		move.w	(a2)+,X_pos(a1)
		move.w	(a2)+,Y_Pos(a1)
		move.w	(a2)+,d0
		move.b	d0,Subtype(a1)

loc_163D0:
		dbf	d1,Obj6F_Loop

		addq.l	#4,sp
		rts
; ===========================================================================

loc_163D8:				; XREF: Obj6F_Index
		lea	(Ani_obj6F).l,a1
		jsr	AnimateSprite
		tst.b	Anim_Frame(a0)
		bne.s	loc_16404
		move.w	X_pos(a0),-(sp)
		bsr.w	loc_16424
		move.w	#$1B,d1
		move.w	#7,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		jmp	SolidObject
; ===========================================================================

loc_16404:
		btst	#3,Status(a0)
		beq.s	loc_16420
		lea	Object_RAM,a1
		bclr	#3,Status(a1)
		bclr	#3,Status(a0)
		sf	Routine2(a0)

loc_16420:
		bra.w	*+4

loc_16424:
		move.w	X_pos(a0),d0
		cmp.w	Off34(a0),d0
		bne.s	loc_16484
		move.w	Y_Pos(a0),d0
		cmp.w	Off36(a0),d0
		bne.s	loc_16484
		moveq	#0,d1
		move.b	Off38(a0),d1
		add.b	Off3A(a0),d1
		cmp.b	Off39(a0),d1
		blo.s	loc_16456
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_16456
		move.b	Off39(a0),d1
		subq.b	#4,d1

loc_16456:
		move.b	d1,Off38(a0)
		movea.l	Off3C(a0),a1
		move.w	(a1,d1.w),Off34(a0)
		move.w	2(a1,d1.w),Off36(a0)
		tst.w	d1
		bne.s	loc_16474
		move.b	#1,Anim(a0)

loc_16474:
		cmpi.w	#8,d1
		bne.s	loc_16480
		move.b	#0,Anim(a0)

loc_16480:
		jsr	Obj63_ChangeDir

loc_16484:
		jmp	ObjectMove
; ===========================================================================
Ani_obj6F:
	include "_anim\obj6F.asm"

off_164A6:	dc.w word_164B2-off_164A6, word_164C6-off_164A6, word_164DA-off_164A6
		dc.w word_164EE-off_164A6, word_16502-off_164A6, word_16516-off_164A6
word_164B2:	dc.w $10, $E80,	$E14, $370, $EEF, $302,	$EEF, $340, $E14, $3AE
word_164C6:	dc.w $10, $F80,	$F14, $2E0, $FEF, $272,	$FEF, $2B0, $F14, $31E
word_164DA:	dc.w $10, $1080, $1014,	$270, $10EF, $202, $10EF, $240,	$1014, $2AE
word_164EE:	dc.w $10, $F80,	$F14, $570, $FEF, $502,	$FEF, $540, $F14, $5AE
word_16502:	dc.w $10, $1B80, $1B14,	$670, $1BEF, $602, $1BEF, $640,	$1B14, $6AE
word_16516:	dc.w $10, $1C80, $1C14,	$5E0, $1CEF, $572, $1CEF, $5B0,	$1C14, $61E
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 70 - large girder block (SBZ)
; ---------------------------------------------------------------------------

Obj70:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj70_Index(pc,d0.w),d1
		jmp	Obj70_Index(pc,d1.w)
; ===========================================================================
Obj70_Index:	dc.w Obj70_Main-Obj70_Index
		dc.w Obj70_Action-Obj70_Index
; ===========================================================================

Obj70_Main:				; XREF: Obj70_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj70,Mappings_Offset(a0)
		move.w	#$42F0,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#4,Priority(a0)
		move.b	#$60,X_Visible(a0)
		move.b	#$18,Y_Radius(a0)
		move.w	X_pos(a0),Off32(a0)
		move.w	Y_Pos(a0),Off30(a0)
		bsr.w	Obj70_Move2

Obj70_Action:				; XREF: Obj70_Index
		move.w	X_pos(a0),-(sp)
		tst.w	Off3A(a0)
		beq.s	Obj70_Move
		subq.w	#1,Off3A(a0)
		bne.s	Obj70_Solid

Obj70_Move:
		jsr	ObjectMove
		subq.w	#1,Off34(a0)	; subtract 1 from movement duration
		bne.s	Obj70_Solid	; if time remains, branch
		bsr.w	Obj70_Move2	; if time is zero, branch

Obj70_Solid:
		move.w	(sp)+,d4
		tst.b	Render_Flags(a0)
		bpl.s	Obj70_ChkDel
		moveq	#0,d1
		move.b	X_Visible(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	Y_Radius(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsr	SolidObject

Obj70_ChkDel:
		move.w	Off32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj70_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj70_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj70_Move2:				; XREF: Obj70_Main
		move.b	Off38(a0),d0
		andi.w	#$18,d0
		lea	(Obj70_MoveData).l,a1
		lea	(a1,d0.w),a1
		move.w	(a1)+,X_Vel(a0)
		move.w	(a1)+,Y_Vel(a0)
		move.w	(a1)+,Off34(a0)
		addq.b	#8,Off38(a0)	; use next movedata set
		move.w	#7,Off3A(a0)
		rts
; ===========================================================================
Obj70_MoveData:	dc.w   $100,	 0,   $60,     0 ; x-speed, y-speed, duration, blank
		dc.w	  0,  $100,   $30,     0
		dc.w  $FF00, $FFC0,   $60,     0
		dc.w	  0, $FF00,   $18,     0
; ---------------------------------------------------------------------------
; Sprite mappings - large girder block (SBZ)
; ---------------------------------------------------------------------------
Map_obj70:
	include "_maps\obj70.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 72 - teleporter (SBZ)
; ---------------------------------------------------------------------------

Obj72:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		cmpi.b  #3,$FFFFFE11
		beq   .c
		move.w	Obj72_Index(pc,d0.w),d1
		jsr	Obj72_Index(pc,d1.w)
		bra	.a

.c  		move.w	Obj72_2Index(pc,d0.w),d1
		jsr	Obj72_2Index(pc,d1.w)

.a
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj72_Delete
		rts
; ===========================================================================

Obj72_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj72_Index:	dc.w Obj72_Main-Obj72_Index
		dc.w loc_166C8-Obj72_Index
		dc.w loc_1675E-Obj72_Index
		dc.w loc_16798-Obj72_Index

Obj72_2Index:	dc.w loc_166C8-Obj72_2Index
                dc.w loc_1675E-Obj72_2Index
		dc.w Obj72_Move-Obj72_2Index
; ===========================================================================
Obj72_Move:
		subq.w	#8,$FFFFD000+Y_Pos
		move.w	#-1,$FFFFD000+Y_Vel
		tst.w	$FFFFD000+Y_Pos
		bne	locret_1675C
		move.w	#1,$FFFFFE02	; restart level
		move.b	#1,$FFFFE11
		rts

Obj72_Main:				; XREF: Obj72_Index
		addq.b	#2,Routine(a0)
		move.b	Subtype(a0),d0
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	Obj72_Data(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,Off3A(a0)
		move.l	a2,Off3C(a0)
		move.w	(a2)+,Off36(a0)
		move.w	(a2)+,Off38(a0)

loc_166C8:				; XREF: Obj72_Index
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_166E0
		addi.w	#$F,d0

loc_166E0:
		cmpi.w	#$10,d0
		bhs.s	locret_1675C
		move.w	Y_Pos(a1),d1
		sub.w	Y_Pos(a0),d1
		addi.w	#$20,d1
		cmpi.w	#$40,d1
		bhs.s	locret_1675C
		tst.b	($FFFFF7C8).w
		bne.s	locret_1675C
		cmpi.b	#7,Subtype(a0)
		bne.s	loc_1670E
		cmpi.w	#50,($FFFFFE20).w
		blo.s	locret_1675C

loc_1670E:
		addq.b	#2,Routine(a0)
		move.b	#$81,($FFFFF7C8).w ; lock controls
		move.b	#2,Anim(a1)	; use Sonic's rolling animation
		move.w	#$800,Inertia(a1)
		move.w	#0,X_Vel(a1)
		move.w	#0,Y_Vel(a1)
		bclr	#5,Status(a0)
		bclr	#5,Status(a1)
		bset	#1,Status(a1)
		sf	PeelOut_Flag
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		sf	Off32(a0)
		move.w	#$BE,d0
		jsr	(PlaySound).l ;	play Sonic rolling sound

locret_1675C:
		rts
; ===========================================================================

loc_1675E:				; XREF: Obj72_Index
		lea	Object_RAM,a1
		move.b	Off32(a0),d1
		addq.b	#2,Off32(a0)
		jsr	(CalcSine).l
		asr.w	#5,d0
		move.w	Y_Pos(a0),d2
		sub.w	d0,d2
		move.w	d2,Y_Pos(a1)
		cmpi.b	#$80,Off32(a0)
		bne.s	locret_16796
		bsr.w	sub_1681C
		addq.b	#2,Routine(a0)
		move.w	#$BC,d0
		jsr	(PlaySound).l ;	play teleport sound

locret_16796:
		rts
; ===========================================================================

loc_16798:				; XREF: Obj72_Index
		addq.l	#4,sp
		lea	Object_RAM,a1
		subq.b	#1,Off2E(a0)
		bpl.s	loc_167DA
		move.w	Off36(a0),X_pos(a1)
		move.w	Off38(a0),Y_Pos(a1)
		moveq	#0,d1
		move.b	Off3A(a0),d1
		addq.b	#4,d1
		cmp.b	Off3B(a0),d1
		blo.s	loc_167C2
		moveq	#0,d1
		bra.s	loc_16800
; ===========================================================================

loc_167C2:
		move.b	d1,Off3A(a0)
		movea.l	Off3C(a0),a2
		move.w	(a2,d1.w),Off36(a0)
		move.w	2(a2,d1.w),Off38(a0)
		bra.w	sub_1681C
; ===========================================================================

loc_167DA:
		move.l	X_pos(a1),d2
		move.l	Y_Pos(a1),d3
		move.w	X_Vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	Y_Vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,X_pos(a1)
		move.l	d3,Y_Pos(a1)
		rts
; ===========================================================================

loc_16800:
		andi.w	#$7FF,Y_Pos(a1)
		sf	Routine(a0)
		sf	($FFFFF7C8).w
		move.w	#0,X_Vel(a1)
		move.w	#$200,Y_Vel(a1)
		rts

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1681C:
		moveq	#0,d0
		move.w	#$1000,d2
		move.w	Off36(a0),d0
		sub.w	X_pos(a1),d0
		bge.s	loc_16830
		neg.w	d0
		neg.w	d2

loc_16830:
		moveq	#0,d1
		move.w	#$1000,d3
		move.w	Off38(a0),d1
		sub.w	Y_Pos(a1),d1
		bge.s	loc_16844
		neg.w	d1
		neg.w	d3

loc_16844:
		cmp.w	d0,d1
		blo.s	loc_1687A
		moveq	#0,d1
		move.w	Off38(a0),d1
		sub.w	Y_Pos(a1),d1
		swap	d1
		divs.w	d3,d1
		moveq	#0,d0
		move.w	Off36(a0),d0
		sub.w	X_pos(a1),d0
		beq.s	loc_16866
		swap	d0
		divs.w	d1,d0

loc_16866:
		move.w	d0,X_Vel(a1)
		move.w	d3,Y_Vel(a1)
		tst.w	d1
		bpl.s	loc_16874
		neg.w	d1

loc_16874:
		move.w	d1,Off2E(a0)
		rts
; ===========================================================================

loc_1687A:
		moveq	#0,d0
		move.w	Off36(a0),d0
		sub.w	X_pos(a1),d0
		swap	d0
		divs.w	d2,d0
		moveq	#0,d1
		move.w	Off38(a0),d1
		sub.w	Y_Pos(a1),d1
		beq.s	loc_16898
		swap	d1
		divs.w	d0,d1

loc_16898:
		move.w	d1,Y_Vel(a1)
		move.w	d2,X_Vel(a1)
		tst.w	d0
		bpl.s	loc_168A6
		neg.w	d0

loc_168A6:
		move.w	d0,Off2E(a0)
		rts
; End of function sub_1681C

; ===========================================================================
Obj72_Data:	dc.w word_168BC-Obj72_Data, word_168C2-Obj72_Data, word_168C8-Obj72_Data
		dc.w word_168E6-Obj72_Data, word_168EC-Obj72_Data, word_1690A-Obj72_Data
		dc.w word_16910-Obj72_Data, word_1692E-Obj72_Data
word_168BC:	dc.w 4,	$794, $98C
word_168C2:	dc.w 4,	$94, $38C
word_168C8:	dc.w $1C, $794,	$2E8
		dc.w $7A4, $2C0, $7D0
		dc.w $2AC, $858, $2AC
		dc.w $884, $298, $894
		dc.w $270, $894, $190
word_168E6:	dc.w 4,	$894, $690
word_168EC:	dc.w $1C, $1194, $470
		dc.w $1184, $498, $1158
		dc.w $4AC, $FD0, $4AC
		dc.w $FA4, $4C0, $F94
		dc.w $4E8, $F94, $590
word_1690A:	dc.w 4,	$1294, $490
word_16910:	dc.w $1C, $1594, $FFE8
		dc.w $1584, $FFC0, $1560
		dc.w $FFAC, $14D0, $FFAC
		dc.w $14A4, $FF98, $1494
		dc.w $FF70, $1494, $FD90
word_1692E:	dc.w 4,	$894, $90
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 78 - Caterkiller enemy	(MZ, SBZ)
; ---------------------------------------------------------------------------

Obj78:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj78_Index(pc,d0.w),d1
		jmp	Obj78_Index(pc,d1.w)
; ===========================================================================
Obj78_Index:	dc.w Obj78_Main-Obj78_Index
		dc.w Obj78_Action-Obj78_Index
		dc.w Obj78_BodySeg1-Obj78_Index
		dc.w Obj78_BodySeg2-Obj78_Index
		dc.w Obj78_BodySeg1-Obj78_Index
		dc.w Obj78_Delete-Obj78_Index
		dc.w loc_16CC0-Obj78_Index
; ===========================================================================

locret_16950:
		rts
; ===========================================================================

Obj78_Main:				; XREF: Obj78_Index
		move.b	#7,Y_Radius(a0)
		move.b	#8,X_Radius(a0)
		jsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_16950
		add.w	d1,Y_Pos(a0)
		clr.w	Y_Vel(a0)
		addq.b	#2,Routine(a0)
		move.l	#Map_obj78,Mappings_Offset(a0)
		move.w	#$22B0,Art_Tile(a0)
		cmpi.b	#5,($FFFFFE10).w ; if level is SBZ, branch
		beq.s	loc_16996
		move.w	#$24FF,Art_Tile(a0)	; MZ specific code

loc_16996:
		andi.b	#3,Render_Flags(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	Render_Flags(a0),Status(a0)
		move.b	#4,Priority(a0)
		move.b	#8,X_Visible(a0)
		move.b	#$B,Coll(a0)
		move.w	X_pos(a0),d2
		moveq	#$C,d5
		btst	#0,Status(a0)
		beq.s	loc_169CA
		neg.w	d5

loc_169CA:
		moveq	#4,d6
		moveq	#0,d3
		moveq	#4,d4
		movea.l	a0,a2
		moveq	#2,d1

Obj78_LoadBody:
		jsr	SingleObjLoad2
		bne.s	Obj78_QuitLoad
		move.b	#$78,(a1)	; load body segment object
		move.b	d6,Routine(a1)
		addq.b	#2,d6
		move.l	Mappings_Offset(a0),Mappings_Offset(a1)
		move.w	Art_Tile(a0),Art_Tile(a1)
		move.b	#5,Priority(a1)
		move.b	#8,X_Visible(a1)
		move.b	#$CB,Coll(a1)
		add.w	d5,d2
		move.w	d2,X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	Status(a0),Status(a1)
		move.b	Status(a0),Render_Flags(a1)
		move.b	#8,Anim_Frame(a1)
		move.l	a2,Off3C(a1)
		move.b	d4,Off3C(a1)
		addq.b	#4,d4
		movea.l	a1,a2
		dbf	d1,Obj78_LoadBody ; repeat sequence 2 more times

Obj78_QuitLoad:
		move.b	#7,Off2A(a0)
		sf	Off3C(a0)

Obj78_Action:				; XREF: Obj78_Index
		tst.b	Status(a0)
		bmi.w	loc_16C96
		moveq	#0,d0
		move.b	Routine2(a0),d0
		move.w	Obj78_Index2(pc,d0.w),d1
		jsr	Obj78_Index2(pc,d1.w)
		move.b	Off2B(a0),d1
		bpl.s	Obj78_Display
		lea	(Ani_obj78).l,a1
		move.b	Angle(a0),d0
		andi.w	#$7F,d0
		addq.b	#4,Angle(a0)
		move.b	(a1,d0.w),d0
		bpl.s	Obj78_AniHead
		bclr	#7,Off2B(a0)
		bra.s	Obj78_Display
; ===========================================================================

Obj78_AniHead:
		andi.b	#$10,d1
		add.b	d1,d0
		move.b	d0,Anim_Frame(a0)

Obj78_Display:
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj78_ChkGone
		jmp	DisplaySprite
; ===========================================================================

Obj78_ChkGone:
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		beq.s	loc_16ABC
		bclr	#7,2(a2,d0.w)

loc_16ABC:
Obj78_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj78_Index2:	dc.w Obj78_Move-Obj78_Index2
		dc.w loc_16B02-Obj78_Index2
; ===========================================================================

Obj78_Move:				; XREF: Obj78_Index2
		subq.b	#1,Off2A(a0)
		bmi.s	Obj78_Move2
		rts
; ===========================================================================

Obj78_Move2:
		addq.b	#2,Routine2(a0)
		move.b	#$10,Off2A(a0)
		move.w	#-$C0,X_Vel(a0)
		move.w	#$40,Inertia(a0)
		bchg	#4,Off2B(a0)
		bne.s	loc_16AFC
		clr.w	X_Vel(a0)
		neg.w	Inertia(a0)

loc_16AFC:
		bset	#7,Off2B(a0)

loc_16B02:				; XREF: Obj78_Index2
		subq.b	#1,Off2A(a0)
		bmi.s	loc_16B5E
		move.l	X_pos(a0),-(sp)
		move.l	X_pos(a0),d2
		move.w	X_Vel(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_16B1E
		neg.w	d0

loc_16B1E:
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.l	d2,X_pos(a0)
		jsr	ObjHitFloor
		move.l	(sp)+,d2
		cmpi.w	#-8,d1
		blt.s	loc_16B70
		cmpi.w	#$C,d1
		bge.s	loc_16B70
		add.w	d1,Y_Pos(a0)
		swap	d2
		cmp.w	X_pos(a0),d2
		beq.s	locret_16B5C
		moveq	#0,d0
		move.b	Off3C(a0),d0
		addq.b	#1,Off3C(a0)
		andi.b	#$F,Off3C(a0)
		move.b	d1,Off2C(a0,d0.w)

locret_16B5C:
		rts
; ===========================================================================

loc_16B5E:
		subq.b	#2,Routine2(a0)
		move.b	#7,Off2A(a0)
		move.w	#0,X_Vel(a0)
		rts
; ===========================================================================

loc_16B70:
		move.l	d2,X_pos(a0)
		bchg	#0,Status(a0)
		move.b	Status(a0),Render_Flags(a0)
		moveq	#0,d0
		move.b	Off3C(a0),d0
		move.b	#$80,Off2C(a0,d0.w)
		addq.b	#1,Off3C(a0)
		andi.b	#$F,Off3C(a0)
		rts
; ===========================================================================

Obj78_BodySeg2:				; XREF: Obj78_Index
		movea.l	Off3C(a0),a1
		move.b	Off2B(a1),Off2B(a0)
		bpl.s	Obj78_BodySeg1
		lea	(Ani_obj78).l,a1
		move.b	Angle(a0),d0
		andi.w	#$7F,d0
		addq.b	#4,Angle(a0)
		tst.b	4(a1,d0.w)
		bpl.s	Obj78_AniBody
		addq.b	#4,Angle(a0)

Obj78_AniBody:
		move.b	(a1,d0.w),d0
		addq.b	#8,d0
		move.b	d0,Anim_Frame(a0)

Obj78_BodySeg1:				; XREF: Obj78_Index
		movea.l	Off3C(a0),a1
		tst.b	Status(a0)
		bmi.w	loc_16C90
		move.b	Off2B(a1),Off2B(a0)
		move.b	Routine2(a1),Routine2(a0)
		beq.w	loc_16C64
		move.w	Inertia(a1),Inertia(a0)
		move.w	X_Vel(a1),d0
		add.w	Inertia(a1),d0
		move.w	d0,X_Vel(a0)
		move.l	X_pos(a0),d2
		move.l	d2,d3
		move.w	X_Vel(a0),d0
		btst	#0,Status(a0)
		beq.s	loc_16C0C
		neg.w	d0

loc_16C0C:
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.l	d2,X_pos(a0)
		swap	d3
		cmp.w	X_pos(a0),d3
		beq.s	loc_16C64
		moveq	#0,d0
		move.b	Off3C(a0),d0
		move.b	Off2C(a1,d0.w),d1
		cmpi.b	#-$80,d1
		bne.s	loc_16C50
		swap	d3
		move.l	d3,X_pos(a0)
		move.b	d1,Off2C(a0,d0.w)
		bchg	#0,Status(a0)
		move.b	Status(a0),Render_Flags(a0)
		addq.b	#1,Off3C(a0)
		andi.b	#$F,Off3C(a0)
		bra.s	loc_16C64
; ===========================================================================

loc_16C50:
		ext.w	d1
		add.w	d1,Y_Pos(a0)
		addq.b	#1,Off3C(a0)
		andi.b	#$F,Off3C(a0)
		move.b	d1,Off2C(a0,d0.w)

loc_16C64:
		cmpi.b	#$C,Routine(a1)
		beq.s	loc_16C90
		move.b	(a1),d0
		cmp.b	(a0),d0
		beq.s	loc_16C82

loc_16C7C:
		jmp	DeleteObject

loc_16C82:
		jmp	DisplaySprite

; ===========================================================================
Obj78_FragSpeed:dc.w $FE00, $FE80, $180, $200
; ===========================================================================

loc_16C90:
		bset	#7,Status(a1)

loc_16C96:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj78_FragSpeed-2(pc,d0.w),d0
		btst	#0,Status(a0)
		beq.s	loc_16CAA
		neg.w	d0

loc_16CAA:
		move.w	d0,X_Vel(a0)
		move.w	#-$400,Y_Vel(a0)
		move.b	#$C,Routine(a0)
		andi.b	#-8,Anim_Frame(a0)

loc_16CC0:				; XREF: Obj78_Index
		jsr	ObjectFall
		tst.w	Y_Vel(a0)
		bmi.s	loc_16CE0
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_16CE0
		add.w	d1,Y_Pos(a0)
		move.w	#-$400,Y_Vel(a0)

loc_16CE0:
		tst.b	Render_Flags(a0)
		bpl.w	Obj78_ChkGone
		jmp	DisplaySprite
; ===========================================================================
Ani_obj78:
	include "_anim\obj78.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Caterkiller	enemy (MZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj78:
	include "_maps\obj78.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 79 - lamppost
; ---------------------------------------------------------------------------

Obj79:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj79_Index(pc,d0.w),d1
		jsr	Obj79_Index(pc,d1.w)
		jmp	MarkObjGone
; ===========================================================================
Obj79_Index:	dc.w Obj79_Main-Obj79_Index
		dc.w Obj79_BlueLamp-Obj79_Index
		dc.w Obj79_AfterHit-Obj79_Index
		dc.w Obj79_Twirl-Obj79_Index
; ===========================================================================

Obj79_Main:				; XREF: Obj79_Index
		addq.b	#2,Routine(a0)
		move.l	#Map_obj79,Mappings_Offset(a0)
		move.w	#$541,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.b	#8,X_Visible(a0)
		move.b	#5,Priority(a0)
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		bclr	#7,2(a2,d0.w)
		btst	#0,2(a2,d0.w)
		bne.s	Obj79_RedLamp
		move.b	($FFFFFE30).w,d1
		andi.b	#$7F,d1
		move.b	Subtype(a0),d2	; get lamppost number
		andi.b	#$7F,d2
		cmp.b	d2,d1		; is lamppost number higher than the number hit?
		blo.s	Obj79_BlueLamp	; if yes, branch

Obj79_RedLamp:
		bset	#0,2(a2,d0.w)
		move.b	#4,Routine(a0)	; run "Obj79_AfterHit" routine
		move.b	#3,Anim_Frame(a0)	; use red lamppost frame
		rts
; ===========================================================================

Obj79_BlueLamp:				; XREF: Obj79_Index
		tst.b	$FFFFFE08.w	; is debug mode	being used?
		bne.w	locret_16F90	; if yes, branch
		tst.b	($FFFFF7C8).w
		bmi.w	locret_16F90
		move.b	($FFFFFE30).w,d1
		andi.b	#$7F,d1
		move.b	Subtype(a0),d2
		andi.b	#$7F,d2
		cmp.b	d2,d1
		blo.s	Obj79_HitLamp
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		bset	#0,2(a2,d0.w)
		move.b	#4,Routine(a0)
		move.b	#3,Anim_Frame(a0)
		bra.w	locret_16F90
; ===========================================================================

Obj79_HitLamp:
		move.w	Object_RAM+X_Pos,d0
		sub.w	X_pos(a0),d0
		addq.w	#8,d0
		cmpi.w	#$10,d0
		bhs.w	locret_16F90
		move.w	Object_RAM+Y_Pos,d0
		sub.w	Y_Pos(a0),d0
		addi.w	#$40,d0
		cmpi.w	#$68,d0
		bhs.s	locret_16F90
		move.w	#$A1,d0
		jsr	(PlaySound).l ;	play lamppost sound
		addq.b	#2,Routine(a0)
		jsr	SingleObjLoad
		bne.s	loc_16F76
		move.b	#$79,0(a1)	; load twirling	lamp object
		move.b	#6,Routine(a1)	; use "Obj79_Twirl" routine
		move.w	X_pos(a0),Off30(a1)
		move.w	Y_Pos(a0),Off32(a1)
		subi.w	#$18,Off32(a1)
		move.l	#Map_obj79,Mappings_Offset(a1)
		move.w	#$541,Art_Tile(a1)
		move.b	#4,Render_Flags(a1)
		move.b	#8,X_Visible(a1)
		move.b	#4,Priority(a1)
		move.b	#2,Anim_Frame(a1)
		move.w	#$20,Off36(a1)

loc_16F76:
		move.b	#1,Anim_Frame(a0)	; use "post only" frame, with no lamp
		bsr.w	Obj79_StoreInfo
		lea	DestroyTable.w,a2
		moveq	#0,d0
		move.b	Respawn(a0),d0
		bset	#0,2(a2,d0.w)

locret_16F90:
		rts
; ===========================================================================

Obj79_AfterHit:				; XREF: Obj79_Index
		rts
; ===========================================================================

Obj79_Twirl:				; XREF: Obj79_Index
		subq.w	#1,Off36(a0)
		bpl.s	loc_16FA0
		move.b	#4,Routine(a0)

loc_16FA0:
		move.b	Angle(a0),d1
		subi.b	#$10,Angle(a0)
		subi.b	#$40,d1
		jsr	(CalcSine).l
		muls.w	#$C00,d1
		swap	d1
		add.w	Off30(a0),d1
		move.w	d1,X_pos(a0)
		muls.w	#$C00,d0
		swap	d0
		add.w	Off32(a0),d0
		move.w	d0,Y_Pos(a0)
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	store information when you hit a lamppost
; ---------------------------------------------------------------------------

Obj79_StoreInfo:			; XREF: Obj79_HitLamp
		move.b	Subtype(a0),($FFFFFE30).w 		; lamppost number
		move.b	($FFFFFE30).w,($FFFFFE31).w
		move.w	X_pos(a0),($FFFFFE32).w		; x-position
		move.w	Y_Pos(a0),($FFFFFE34).w		; y-position
		move.w	($FFFFFE20).w,($FFFFFE36).w 	; rings
		move.b	($FFFFFE1B).w,($FFFFFE54).w 	; lives
		move.l	($FFFFFE22).w,($FFFFFE38).w 	; time
		move.b	($FFFFF742).w,($FFFFFE3C).w 	; routine counter for dynamic level mod
		move.w	($FFFFF72E).w,($FFFFFE3E).w 	; lower y-boundary of level
		move.w	($FFFFF700).w,($FFFFFE40).w 	; screen x-position
		move.w	($FFFFF704).w,($FFFFFE42).w 	; screen y-position
		move.w	($FFFFF708).w,($FFFFFE44).w 	; bg position
		move.w	($FFFFF70C).w,($FFFFFE46).w 	; bg position
		move.w	($FFFFF710).w,($FFFFFE48).w 	; bg position
		move.w	($FFFFF714).w,($FFFFFE4A).w 	; bg position
		move.w	($FFFFF718).w,($FFFFFE4C).w 	; bg position
		move.w	($FFFFF71C).w,($FFFFFE4E).w 	; bg position
		move.w	($FFFFF648).w,($FFFFFE50).w 	; water height
		move.b	($FFFFF64D).w,($FFFFFE52).w 	; rountine counter for water
		move.b	($FFFFF64E).w,($FFFFFE53).w 	; water direction
		rts

; ---------------------------------------------------------------------------
; Subroutine to	load stored info when you start	a level	from a lamppost
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj79_LoadInfo:				; XREF: LevelSizeLoad
		move.b	($FFFFFE31).w,($FFFFFE30).w
		move.w	($FFFFFE32).w,Object_RAM+X_Pos
		move.w	($FFFFFE34).w,Object_RAM+Y_Pos
		move.w	($FFFFFE36).w,($FFFFFE20).w
		move.b	($FFFFFE54).w,($FFFFFE1B).w
		clr.w	($FFFFFE20).w
		sf	($FFFFFE1B).w
		move.l	($FFFFFE38).w,($FFFFFE22).w
		move.b	#59,($FFFFFE25).w
		subq.b	#1,($FFFFFE24).w
		move.b	($FFFFFE3C).w,($FFFFF742).w
		move.b	($FFFFFE52).w,($FFFFF64D).w
		move.w	($FFFFFE3E).w,($FFFFF72E).w
		move.w	($FFFFFE3E).w,($FFFFF726).w
		move.w	($FFFFFE40).w,($FFFFF700).w
		move.w	($FFFFFE42).w,($FFFFF704).w
		move.w	($FFFFFE44).w,($FFFFF708).w
		move.w	($FFFFFE46).w,($FFFFF70C).w
		move.w	($FFFFFE48).w,($FFFFF710).w
		move.w	($FFFFFE4A).w,($FFFFF714).w
		move.w	($FFFFFE4C).w,($FFFFF718).w
		move.w	($FFFFFE4E).w,($FFFFF71C).w
		tst.l	Water_Array.w	; check if has water
		bmi.w	loc_170E4
		move.w	($FFFFFE50).w,($FFFFF648).w
		move.b	($FFFFFE52).w,($FFFFF64D).w
		move.b	($FFFFFE53).w,($FFFFF64E).w

loc_170E4:
		tst.b	($FFFFFE30).w
		bpl.s	locret_170F6
		move.w	($FFFFFE32).w,d0
		subi.w	#$A0,d0
		move.w	d0,($FFFFF728).w

locret_170F6:
		rts
; End of function Obj79_LoadInfo

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - lamppost
; ---------------------------------------------------------------------------
Map_obj79:
	include "_maps\obj79.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7D - hidden points at the end of a level
; ---------------------------------------------------------------------------

Obj7D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj7D_Index(pc,d0.w),d1
		jmp	Obj7D_Index(pc,d1.w)
; ===========================================================================
Obj7D_Index:	dc.w Obj7D_Main-Obj7D_Index
		dc.w Obj7D_DelayDel-Obj7D_Index
; ===========================================================================

Obj7D_Main:				; XREF: Obj7D_Index
		moveq	#$10,d2
		move.w	d2,d3
		add.w	d3,d3
		lea	Object_RAM,a1
		move.w	X_pos(a1),d0
		sub.w	X_pos(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bhs.s	Obj7D_ChkDel
		move.w	Y_Pos(a1),d1
		sub.w	Y_Pos(a0),d1
		add.w	d2,d1
		cmp.w	d3,d1
		bhs.s	Obj7D_ChkDel
		tst.b	$FFFFFE08.w
		bne.s	Obj7D_ChkDel
		tst.b	($FFFFF7CD).w
		bne.s	Obj7D_ChkDel
		addq.b	#2,Routine(a0)
		move.l	#Map_obj7D,Mappings_Offset(a0)
		move.w	#$84B6,Art_Tile(a0)
		ori.b	#4,Render_Flags(a0)
		move.b	#0,Priority(a0)
		move.b	#$10,X_Visible(a0)
		move.b	Subtype(a0),Anim_Frame(a0)
		move.w	#119,Off30(a0)	; set display time to 2	seconds
		move.w	#$C9,d0
		jsr	(PlaySound).l ;	play bonus sound
		moveq	#0,d0
		move.b	Subtype(a0),d0
		add.w	d0,d0
		move.w	Obj7D_Points(pc,d0.w),d0 ; load	bonus points array
		jsr	AddPoints

Obj7D_ChkDel:
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj7D_Delete
		rts
; ===========================================================================

Obj7D_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj7D_Points:	dc.w 0			; Bonus	points array
		dc.w 1000
		dc.w 100
		dc.w 10
; ===========================================================================

Obj7D_DelayDel:				; XREF: Obj7D_Index
		subq.w	#1,Off30(a0)	; subtract 1 from display time
		bmi.s	Obj7D_Delete2	; if time is zero, branch
		move.w	X_pos(a0),d0
		andi.w	#-$80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#-$80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj7D_Delete2
		jmp	DisplaySprite
; ===========================================================================

Obj7D_Delete2:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - hidden points at the end of	a level
; ---------------------------------------------------------------------------
Map_obj7D:
	include "_maps\obj7D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8A - "SONIC TEAM PRESENTS" and	credits
; ---------------------------------------------------------------------------

Obj8A:

; ===========================================================================
; ---------------------------------------------------------------------------
; bosses
; ---------------------------------------------------------------------------
	include "boss/LZ3.asm"
	include "boss/LZ6.asm"
	include "boss/MZ2.asm"
	include "boss/MZ3.asm"
	include "boss/GHZ2.asm"
	include "boss/GHZ3.asm"
	include "boss/SLZ2.asm"
	include "boss/SLZ3.asm"
	include "boss/SYZ2.asm"
	include "boss/SYZ3.asm"
	include "boss/SBZ2.asm"
	include "boss/SBZ3.asm"
	include "boss/fz.asm"
	include "boss/fz2.asm"

; ===========================================================================
Ani_Eggman:
	include "_anim\Eggman.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Eggman (boss levels)
; ---------------------------------------------------------------------------
Map_Eggman:
	include "_maps\Eggman.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - extra boss items (e.g. swinging ball on a chain in GHZ)
; ---------------------------------------------------------------------------
Map_BossItems:
	include "_maps\Boss items.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3E - prison capsule
; ---------------------------------------------------------------------------

Obj3E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj3E_Index(pc,d0.w),d1
		jsr	Obj3E_Index(pc,d1.w)
		move.w	X_pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj3E_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj3E_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj3E_Index:	dc.w Obj3E_Main-Obj3E_Index
		dc.w Obj3E_BodyMain-Obj3E_Index
		dc.w Obj3E_Switched-Obj3E_Index
		dc.w Obj3E_Explosion-Obj3E_Index
		dc.w Obj3E_Explosion-Obj3E_Index
		dc.w Obj3E_Explosion-Obj3E_Index
		dc.w Obj3E_Animals-Obj3E_Index
		dc.w Obj3E_EndAct-Obj3E_Index

Obj3E_Var:	dc.b 2,	$20, 4,	0	; routine, width, priority, frame
		dc.b 4,	$C, 5, 1
		dc.b 6,	$10, 4,	3
		dc.b 8,	$10, 3,	5
; ===========================================================================

Obj3E_Main:				; XREF: Obj3E_Index
		move.l	#Map_obj3E,Mappings_Offset(a0)
		move.w	#$49D,Art_Tile(a0)
		move.b	#4,Render_Flags(a0)
		move.w	Y_Pos(a0),Off30(a0)
		moveq	#0,d0
		move.b	Subtype(a0),d0
		lsl.w	#2,d0
		lea	Obj3E_Var(pc,d0.w),a1
		move.b	(a1)+,Routine(a0)
		move.b	(a1)+,X_Visible(a0)
		move.b	(a1)+,Priority(a0)
		move.b	(a1)+,Anim_Frame(a0)
		cmpi.w	#8,d0		; is object type number	02?
		bne.s	Obj3E_Not02	; if not, branch
		move.b	#6,Coll(a0)
		move.b	#8,Coll2(a0)

Obj3E_Not02:
		rts
; ===========================================================================

Obj3E_BodyMain:				; XREF: Obj3E_Index
		cmpi.b	#2,($FFFFF7A7).w
		beq.s	Obj3E_ChkOpened
		move.w	#$2B,d1
		move.w	#$18,d2
		move.w	#$18,d3
		move.w	X_pos(a0),d4
		jmp	SolidObject
; ===========================================================================

Obj3E_ChkOpened:
		tst.b	Routine2(a0)		; has the prison been opened?
		beq.s	Obj3E_DoOpen	; if yes, branch
		sf	Routine2(a0)
		bclr	#3,Object_RAM+Status
		bset	#1,Object_RAM+Status

Obj3E_DoOpen:
		move.b	#2,Anim_Frame(a0)	; use frame number 2 (destroyed	prison)
		rts
; ===========================================================================

Obj3E_Switched:				; XREF: Obj3E_Index
		move.w	#$17,d1
		move.w	#8,d2
		move.w	#8,d3
		move.w	X_pos(a0),d4
		jsr	SolidObject
		lea	(Ani_obj3E).l,a1
		jsr	AnimateSprite
		move.w	Off30(a0),Y_Pos(a0)
		tst.b	Routine2(a0)
		beq.s	locret_1AC60
		addq.w	#8,Y_Pos(a0)
		move.b	#$A,Routine(a0)
		move.w	#$3C,Anim_Dur(a0)
		sf	($FFFFF7AA).w	; lock screen position
		sf	Routine2(a0)
		bclr	#3,Object_RAM+Status
		bset	#1,Object_RAM+Status

locret_1AC60:
		rts
; ===========================================================================

Obj3E_Explosion:			; XREF: Obj3E_Index
		moveq	#7,d0
		and.b	($FFFFFE0F).w,d0
		bne.s	loc_1ACA0
		jsr	SingleObjLoad
		bne.s	loc_1ACA0
		move.b	#$3F,(a1)	; load explosion object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		jsr	(RandomNumber).l
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,X_pos(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,Y_Pos(a1)

loc_1ACA0:
		subq.w	#1,Anim_Dur(a0)
		beq.s	Obj3E_MakeAnimal
		rts
; ===========================================================================

Obj3E_MakeAnimal:
		move.b	#2,($FFFFF7A7).w
		move.b	#$C,Routine(a0)	; replace explosions with animals
		move.b	#6,Anim_Frame(a0)
		move.w	#$96,Anim_Dur(a0)
		addi.w	#$20,Y_Pos(a0)
		moveq	#7,d6
		move.w	#$9A,d5
		moveq	#-$1C,d4

Obj3E_Loop:
		jsr	SingleObjLoad
		bne.s	locret_1ACF8
		move.b	#$28,0(a1)	; load animal object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		add.w	d4,X_pos(a1)
		addq.w	#7,d4
		move.w	d5,Off36(a1)
		subq.w	#8,d5
		dbf	d6,Obj3E_Loop	; repeat 7 more	times

locret_1ACF8:
		rts
; ===========================================================================

Obj3E_Animals:				; XREF: Obj3E_Index
		moveq	#7,d0
		and.b	($FFFFFE0F).w,d0
		bne.s	loc_1AD38
		jsr	SingleObjLoad
		bne.s	loc_1AD38
		move.b	#$28,0(a1)	; load animal object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		jsr	(RandomNumber).l
		andi.w	#$1F,d0
		subq.w	#6,d0
		tst.w	d1
		bpl.s	loc_1AD2E
		neg.w	d0

loc_1AD2E:
		add.w	d0,X_pos(a1)
		move.w	#$C,Off36(a1)

loc_1AD38:
		subq.w	#1,Anim_Dur(a0)
		bne.s	locret_1AD48
		addq.b	#2,Routine(a0)
		move.w	#180,Anim_Dur(a0)

locret_1AD48:
		rts
; ===========================================================================

Obj3E_EndAct:				; XREF: Obj3E_Index
		btst	#1,Object_RAM+Status
		bne.s	locret_1AD48
		move.b	#1,($FFFFF7CC).w ; lock	controls
		move.w	#0,($FFFFF602).w ; make Sonic run to	the right
		move.l	#0,Object_RAM+X_Vel

		moveq	#$3E,d0
		moveq	#$28,d1
		moveq	#$40,d2
		lea	($FFFFD040).w,a1 ; load	object RAM

Obj3E_FindObj28:
		cmp.b	(a1),d1		; is object $28	(animal) loaded?
		beq.s	Obj3E_Obj28Found ; if yes, branch
		adda.w	d2,a1		; next object RAM
		dbf	d0,Obj3E_FindObj28 ; repeat $3E	times

		jsr	GotThroughAct
		jmp	DeleteObject
; ===========================================================================

Obj3E_Obj28Found:
		rts
; ===========================================================================
Ani_obj3E:
	include "_anim\obj3E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - prison capsule
; ---------------------------------------------------------------------------
Map_obj3E:
	include "_maps\obj3E.asm"

; ---------------------------------------------------------------------------
; Object touch response	subroutine - Coll(a0) in	the object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


TouchResponse:				; XREF: Obj01
  		move.b	Shield_RAM+Inertia.w,Shield_UseType+1.w; save elemental shield type
		beq.s	Touch_Norm		; if 0, branch

		move.w	X_pos(a0),d2		; load Sonic's x-axis value
		move.w	Y_Pos(a0),d3		; load Sonic's y-axis value

  		subi.w	#$18,d2
		subi.w	#$18,d3
		move.w	#$30,d4
		move.w	#$30,d5

.q		bsr	Touch_Common	; load touchresponse for elemental shields
                lea	(a1),a4		; move last touched object to a4 (to prevent freezes caused by "double touching" an object, and that negated projectiles wont hit Sonic)
Touch_Norm:
		move.w	X_pos(a0),d2	; load Sonic's x-axis value
		move.w	Y_Pos(a0),d3	; load Sonic's y-axis value

	 	subq.w	#8,d2
		moveq	#0,d5
		move.b	Y_Radius(a0),d5		; load Sonic's height
		subq.b	#3,d5
		sub.w	d5,d3
		cmpi.b	#$39,Anim_Frame(a0)	; is Sonic ducking?
		bne.s	Touch_NoDuck		; if not, branch
		addi.w	#$C,d3
		moveq	#$A,d5

Touch_NoDuck:
		move.w	#$10,d4
		add.w	d5,d5
		sf	Shield_UseType+1

Touch_Common:
	     	lea	Object_RAM_Free,a1	; begin checking the object RAM
		move.w	#$5F,d6

Touch_Loop:
		tst.b	Render_Flags(a1)
		bpl	Touch_NextObj
		move.b	Coll(a1),d0		; load touch response number
		bne	Touch_Height		; if touch response is not 0, branch

Touch_NextObj:
		lea	Next_Obj(a1),a1	; next object RAM
		dbf	d6,Touch_Loop	; repeat $5F more times

Touch_end:
		moveq	#0,d0
		rts
; ===========================================================================
Touch_Sizes:	dc.b  $14, $14		; width, height
		dc.b   $C, $14
		dc.b  $14,  $C
		dc.b	4, $10
		dc.b   $C, $12
		dc.b  $10, $10
		dc.b	6,   6
		dc.b  $18,  $C
		dc.b   $C, $10
		dc.b  $10,  $C
		dc.b	8,   8
		dc.b  $14, $10
		dc.b  $14,   8
		dc.b   $E,  $E
		dc.b  $18, $18
		dc.b  $28, $10
		dc.b  $10, $18	; $10
		dc.b	8, $10
		dc.b  $20, $70
		dc.b  $40, $20
		dc.b  $80, $20
		dc.b  $20, $20
		dc.b	8,   8
		dc.b	4,   4
		dc.b  $20,   8
		dc.b   $C,  $C
		dc.b	8,   4
		dc.b  $18,   4
		dc.b  $28,   4
		dc.b	4,   8
		dc.b	4, $18
		dc.b	4, $28
		dc.b	4, $20	; $20
		dc.b  $18, $18
		dc.b   $C, $18
		dc.b  $48,   8
		dc.b   $F,  $F
		dc.b    6,  14
		dc.b  $20, $10
		dc.b  $1D, 8
; ===========================================================================

Touch_Height:				; XREF: TouchResponse
		andi.w	#$3F,d0
		add.w	d0,d0
		lea	Touch_Sizes-2(pc,d0.w),a2
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	X_pos(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bhs	loc_1AE98
		add.w	d1,d1
		add.w	d1,d0
		blo	Touch_Width
		bra	Touch_NextObj
; ===========================================================================

loc_1AE98:
		cmp.w	d4,d0
		bhi	Touch_NextObj

Touch_Width:
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	Y_Pos(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bhs.s	loc_1AEB6
		add.w	d1,d1
		add.w	d0,d1
		blo	Touch_ChkValue
		bra	Touch_NextObj
; ===========================================================================

loc_1AEB6:
		cmp.w	d5,d0
		bhi	Touch_NextObj

Touch_ChkValue:
	        cmpi.b	#1,Shield_UseType+1	; are we using instashield?
		beq	Touch_ChkValue2		; if we are, branch
		tst.b	Shield_UseType+1	; test shield type
		bne	ChkElementalColls	; if not 0 (aka testing elemental shields), branch
		cmpa.w	a1,a4			; is the address same as in elemental shields?
		beq	Touch_NextObj		; if is, load new object

Touch_ChkValue2:
		move.b	Coll(a1),d1	; load touch response number
		andi.b	#$C0,d1		; is touch response $40	or higher?
		beq	Touch_Enemy	; if not, branch
		cmpi.b	#$C0,d1		; is touch response $C0	or higher?
		beq	Touch_Special	; if yes, branch
		tst.b	d1		; is touch response $80-$BF ?
		bmi	Touch_ChkHurt	; if yes, branch

; touch	response is $40-$7F
		move.b	Coll(a1),d0
		andi.b	#$3F,d0
		cmpi.b	#6,d0		; is touch response $46	?
		beq	Touch_Monitor	; if yes, branch
		cmpi.w	#$5A,Off30(a0)
		bhs	locret_1AEF2
		addq.b	#2,Routine(a1)	; advance the object's routine counter

locret_1AEF2:
		rts
; ===========================================================================
ChkElementalColls:
		lea	EleMenSld_NegList-1(pc),a2; get negated object list -1 (for the oncoming increment
		move.b	(a1),d0			; move object type to d0
		move.b	Routine(a1),d1		; get routine counter of the object

.loopIncr	addq.w	#1,a2			; increment a2 to the next word
.loop		cmpi.b	#$FF,(a2)		; is this byte $FF?
		beq	Touch_NextObj		; if is, no matches found, search for new object
		cmp.b	(a2)+,d0		; is object type equal to the one in a2, and increment the pointer
		bne.s	.loopIncr		; if not, test new object

		cmpi.b	#-2,(a2)		; is the next byte $FE?
		beq.s	.Calculate		; if is, calculate the speed
		cmp.b	(a2)+,d1		; is value in a2 same as Routine of the object
		bne.s	.loop			; if not, look for other object

                cmpi.b	#$60,(a1)		; is it the orbinauts orbs?
		beq	JmpToDeleteObject	; if yes, delete

.Calculate	move.w	X_pos(a0),d1		; get X pos
		move.w	Y_Pos(a0),d2		; get Y pos
		sub.w	X_pos(a1),d1		; sub X pos
		sub.w	Y_Pos(a1),d2		; sub Y pos
		jsr	CalcAngle		; calculate angle
		jsr	CalcSine		; calculate Sine value

		muls.w	#-$A00,d1		; multiply
		asr.l	#8,d1			; shift right
		move.w	d1,X_Vel(a1)		; bounce Sonic away

		muls.w	#-$A00,d0		; multiply
		asr.l	#8,d0			; shift right
		move.w	d0,Y_Vel(a1)		; bounce Sonic away

.end		rts
EleMenSld_NegList:
  ElMenSld_NegList


Touch_Monitor:
		cmpi.b	#1,Shield_UseType+1
		beq	Monitor_Break
		tst.w	Y_Vel(a0)	; is Sonic moving upwards?
		bpl.s	loc_1AF1E	; if not, branch
		move.w	Y_Pos(a0),d0
		subi.w	#$10,d0
		cmp.w	Y_Pos(a1),d0
		blo.s	locret_1AF2E
		neg.w	Y_Vel(a0)		; reverse Sonic's y-motion
		move.w	#-$180,Y_Vel(a1)
		tst.b	Routine2(a1)
		bne.s	locret_1AF2E
		addq.b	#4,Routine2(a1)	; advance the monitor's routine counter
		rts
; ===========================================================================

loc_1AF1E:
		tst.b	FastInvis	; is sonic going fast enough?
                bne	Monitor_Break	; if is, break the monitor
                move.b	Player_SpecTouAni,d0
                cmp.b	Anim(a0),d0
                beq	Monitor_Break
		cmpi.b	#2,Anim(a0)	; is Sonic rolling/jumping?
		bne	locret_1AF2E
Monitor_Break	neg.w	Y_Vel(a0)		; reverse Sonic's y-motion
		addq.b	#2,Routine(a1)	; advance the monitor's routine counter

locret_1AF2E:
		rts
; ===========================================================================

Touch_Enemy:				; XREF: Touch_ChkValue
		cmpi.b	#1,Shield_UseType+1
		beq	loc_1AF40
		tst.b	($FFFFFE2D).w	; is Sonic invincible?
		bne.s	loc_1AF40	; if yes, branch
		cmpi.b	#9,Anim(a0)	; is Sonic SpinDashing?
		beq	loc_1AF40	; if yes, branch
		move.b	Player_SpecTouAni,d0
                cmp.b	Anim(a0),d0
                beq	loc_1AF40
		cmpi.b	#2,Anim(a0)	; is Sonic rolling?
		bne	Touch_ChkHurt	; if not, branch

loc_1AF40:
		tst.b	Coll2(a1)
		beq.s	Touch_KillEnemy
		cmpi.b	#1,Shield_UseType+1
		beq	.NoVelChange

		move.l	a1,-(sp)
		movea.l	a0,a1
		moveq	#2,d0
		jsr	K_Glide_HitObj
		move.l	(sp)+,a1
		tst.b	d1
		bne	Touch_ChkHurt

		neg.w	X_Vel(a0)
		neg.w	Y_Vel(a0)
		asr	X_Vel(a0)
		asr	Y_Vel(a0)

.NoVelChange	move.b	#0,Coll(a1)
		subq.b	#1,Coll2(a1)
		bne.s	.send
		bset	#7,Status(a1)

		cmp.b	#7,$FFFFFE10.w
		beq.s	.send
		sf	BossMode.w
		sf	$FFFFFE1E.w	; stop time counter
		move.b	#1,($FFFFFE1F).w ; update score	counter
	;	move.b	#1,($FFFFFE1D).w ; update rings	counter
		move.b	#$80,($FFFFFE1D).w ; update ring counter


		moveq	#0,d1
		move.l	#$54A00003,d0	; set VRAM address
		jsr	Hud_Lives_	; set boss lives to 0
		jmp	updateTime	; update time counter

.send		move.b	Coll2(a1),d0
		tas	d0
		move.b	d0,BossLives.w

locret_1AF68:
		rts

; ===========================================================================

Touch_KillEnemy:
		bset	#7,Status(a1)
		moveq	#0,d0
		move.w	($FFFFF7D0).w,d0
		addq.w	#2,($FFFFF7D0).w ; add 2 to item bonus counter
		cmpi.w	#6,d0
		blo.s	loc_1AF82
		moveq	#6,d0

loc_1AF82:
		move.w	d0,Off3E(a1)
		move.w	Enemy_Points(pc,d0.w),d0
		cmpi.w	#$20,($FFFFF7D0).w ; have 16 enemies been destroyed?
		blo.s	loc_1AF9C	; if not, branch
		move.w	#1000,d0	; fix bonus to 10000
		move.w	#$A,Off3E(a1)

loc_1AF9C:
		bsr.w	AddPoints
		move.b	#$27,(a1)	; change object	to points
		move.b	#0,Routine(a1)
		cmpi.b	#1,d6
		beq	.rts
		tst.w	Y_Vel(a0)
		bmi.s	loc_1AFC2
		move.w	Y_Pos(a0),d0
		cmp.w	Y_Pos(a1),d0
		bhs.s	loc_1AFCA
		neg.w	Y_Vel(a0)
.rts		rts

JmpToDeleteObject:
		jmp	DeleteObject2
; ===========================================================================

loc_1AFC2:
		addi.w	#$100,Y_Vel(a0)
		rts
; ===========================================================================

loc_1AFCA:
		subi.w	#$100,Y_Vel(a0)
		rts
; ===========================================================================
Enemy_Points:	dc.w 10, 20, 50, 100
; ===========================================================================

loc_1AFDA:				; XREF: Touch_CatKiller
		bset	#7,Status(a1)

Touch_ChkHurt:				; XREF: Touch_ChkValue
		cmpi.b	#1,Shield_UseType+1
		beq	loc_1AFE6
		tst.b	($FFFFFE2D).w	; is Sonic invincible?
		beq.s	Touch_Hurt	; if not, branch

loc_1AFE6:				; XREF: Touch_Hurt
		moveq	#-1,d0
		rts
; ===========================================================================

Touch_Hurt:				; XREF: Touch_ChkHurt
		tst.w	Off30(a0)
		bne.s	loc_1AFE6
		movea.l	a1,a2

; End of function TouchResponse
; continue straight to HurtSonic

; ---------------------------------------------------------------------------
; Hurting Sonic	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HurtSonic:
		tst.b	Shield_Type	; does Sonic have a shield?
		bne.s	Hurt_Shield	; if yes, branch
		tst.w	($FFFFFE20).w	; does Sonic have any rings?
		beq.w	Hurt_NoRings	; if not, branch
		jsr	SingleObjLoad
		bne.s	Hurt_Shield
		move.b	#$37,(a1)	; load bouncing	multi rings object
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)

Hurt_Shield:
		sf	Shield_Type.w	 ; remove shield
		sf	Shield_RAM+Inertia.w
		sf	Shield_RAM+Routine2.w; clear secondary routine counter to load object properly
		move.b	#4,Routine(a0)
		jsr	Sonic_ResetOnFloor
		bset	#1,Status(a0)
		move.w	#-$400,Y_Vel(a0)	; make Sonic bounce away from the object
		move.w	#-$200,X_Vel(a0)
		btst	#6,Status(a0)
		beq.s	Hurt_Reverse
		move.w	#-$200,Y_Vel(a0)
		move.w	#-$100,X_Vel(a0)

Hurt_Reverse:
		move.w	X_pos(a0),d0
		cmp.w	X_pos(a2),d0
		blo.s	Hurt_ChkSpikes	; if Sonic is left of the object, branch
		neg.w	X_Vel(a0)	; if Sonic is right of the object, reverse

Hurt_ChkSpikes:
		move.w	#0,Inertia(a0)
		sf	If_Spindash.w
		sf	PeelOut_Flag.w
		move.b	#$1A,Anim(a0)
		move.w	#$78,Off30(a0)
		move.w	#$A3,d0		; load normal damage sound
		cmpi.b	#$36,(a2)	; was damage caused by spikes?
		bne.s	Hurt_Sound	; if not, branch
		cmpi.b	#$16,(a2)	; was damage caused by LZ harpoon?
		bne.s	Hurt_Sound	; if not, branch
		move.w	#$A6,d0		; load spikes damage sound

Hurt_Sound:
                jsr	PlaySound
		moveq	#-1,d0
		rts
; ===========================================================================

Hurt_NoRings:
; End of function HurtSonic

; ---------------------------------------------------------------------------
; Subroutine to	kill Sonic
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


KillSonic:
		tst.b	$FFFFFE08.w	; is debug mode	active?
		bne	Kill_NoDeath	; if yes, branch
		move.b	#0,($FFFFFE2D).w ; remove invincibility
		clr.w	Shield_RAM.w
		move.b	#6,Routine(a0)
		jsr	Sonic_ResetOnFloor
		bset	#1,Status(a0)

		cmpi.w	#-$400*2,Y_Vel(a0)
		ble.s	.skip
		move.w	#-$700*2,Y_Vel(a0)

.skip		asr	Y_Vel(a0)
		asr	X_Vel(a0)
		asr	X_Vel(a0)
		asr	Inertia(a0)
		asr	Inertia(a0)

		move.w	Y_Pos(a0),Off38(a0)
		move.b	#$18,Anim(a0)
		bset	#7,Art_Tile(a0)

		buytest	Used_AirHorn
		beq.s	.nop
		moveq	#$FFFFFFE4,d0
		cmpi.b	#1,$FFFFFE12.w	; if last life, skip sfx
		beq.s	Kill_Sound

		moveq	#$FFFFFF8C,d0
		jsr	PlaySample
		bra.s	Kill_NoDeath

.nop		moveq	#$FFFFFFA3,d0	; play normal death sound
		cmpi.b	#$36,(a2)	; check	if you were killed by spikes
		bne.s	Kill_Sound
		moveq	#$FFFFFFA6,d0	; play spikes death sound

Kill_Sound:
		jsr	PlaySound

Kill_NoDeath:
		moveq	#-1,d0
		rts
; End of function KillSonic


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Touch_Special:				; XREF: Touch_ChkValue
		move.b	Coll(a1),d1
		andi.b	#$3F,d1
		cmpi.b	#$B,d1		; is touch response $CB	?
		beq.s	Touch_CatKiller	; if yes, branch
		cmpi.b	#$C,d1		; is touch response $CC	?
		beq.s	Touch_Yadrin	; if yes, branch
		cmpi.b	#$17,d1		; is touch response $D7	?
		beq.s	Touch_D7orE1	; if yes, branch
		cmpi.b	#$21,d1		; is touch response $E1	?
		beq.s	Touch_D7orE1	; if yes, branch
		cmpi.b	#$25,d1		; is touch response $E1	?
		beq.s	Touch_D7orE1	; if yes, branch
		rts
; ===========================================================================

Touch_CatKiller:			; XREF: Touch_Special
		bra.w	loc_1AFDA
; ===========================================================================

Touch_Yadrin:				; XREF: Touch_Special
		cmpi.b	#1,Shield_UseType+1
		beq	Touch_Enemy
		sub.w	d0,d5
		cmpi.w	#8,d5
		bhs.s	loc_1B144
		move.w	X_pos(a1),d0
		subq.w	#4,d0
		btst	#0,Status(a1)
		beq.s	loc_1B130
		subi.w	#$10,d0

loc_1B130:
		sub.w	d2,d0
		bhs.s	loc_1B13C
		addi.w	#$18,d0
		blo.s	loc_1B140
		bra.s	loc_1B144
; ===========================================================================

loc_1B13C:
		cmp.w	d4,d0
		bhi.s	loc_1B144

loc_1B140:
		bra.w	Touch_ChkHurt
; ===========================================================================

loc_1B144:
		bra.w	Touch_Enemy
; ===========================================================================

Touch_D7orE1:				; XREF: Touch_Special
		addq.b	#1,Coll2(a1)
		rts
; End of function Touch_Special
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 03 - Collision plane/layer switcher (From Sonic 2 [Modified])
; ---------------------------------------------------------------------------

Obj03_arr:	dc.w Path_ID, Sonic_SuperFly, Sonic_ForceRollMode, Sonic_SuperFly
Obj03:
	        tst.b	$FFFFFE08.w
		bne.s	rts_3

		moveq	#0,d0
		move.b	Render_Flags(a0),d0
		andi.b	#3,d0
		add.w	d0,d0
		move.w	Obj03_arr(pc,d0.w),a3

Obj3_Loadcollisions:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj03_Index(pc,d0.w),d1
		jsr	Obj03_Index(pc,d1.w)
rts_3:
		move.w	X_Pos(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj03_MarkChkGone
		rts

Obj03_MarkChkGone:
		jmp	Mark_ChkGone
; ===========================================================================
; ---------------------------------------------------------------------------
Obj03_Index:	dc.w Obj03_Init-Obj03_Index
		dc.w Obj03_MainX-Obj03_Index
		dc.w Obj03_MainY-Obj03_Index
; ---------------------------------------------------------------------------
; ===========================================================================
; ---------------------------------------------------------------------------
; Initiation
; ---------------------------------------------------------------------------

Obj03_Init:
		addq.b	#2,Routine(a0)
		move.b	Subtype(a0),d0
		btst	#2,d0
		beq.s	Obj03_Init_CheckX

		addq.b	#2,Routine(a0) ; => Obj03_MainY
		andi.w	#7,d0
		move.b	d0,Anim_Frame(a0)
		andi.w	#3,d0
		add.w	d0,d0
		move.w	word_1FD68(pc,d0.w),off32(a0)
		move.w	Y_Pos(a0),d1
		lea	Object_RAM,a1 ; a1=character
		cmp.w	Y_Pos(a1),d1
		bhs.s	Obj03_Init_Next
		move.b	#1,off34(a0)

Obj03_Init_Next:
		bra.w	Obj03_MainY
; ===========================================================================
word_1FD68:
	dc.w  $020
	dc.w  $040	; 1
	dc.w  $080	; 2
	dc.w  $100	; 3
; ===========================================================================
; loc_1FD70:
Obj03_Init_CheckX:
		andi.w	#3,d0
		move.b	d0,Anim_Frame(a0)
		add.w	d0,d0
		move.w	word_1FD68(pc,d0.w),off32(a0)
		move.w	X_Pos(a0),d1
		lea	Object_RAM,a1 ; a1=character
		cmp.w	X_Pos(a1),d1
		bhs.s	Obj03_Init_CheckX_Next
		move.b	#1,off34(a0)
Obj03_Init_CheckX_Next:

Obj03_MainX:
		btst	#7,Subtype(a0)
		beq.s	.c
		btst	#1,Object_RAM+Status.w
		bne	rts_2

.c		move.w	X_Pos(a0),d1
		lea	off34(a0),a2
		lea	Object_RAM,a1 ; a1=character

		tst.b	(a2)+
		bne.s	Obj03_MainX_Alt
		cmp.w	X_Pos(a1),d1
		bhi.w	return_1FEAC
		move.b	#1,-1(a2)
		move.w	Y_Pos(a0),d2
		move.w	d2,d3
		move.w	off32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	Y_Pos(a1),d4
		cmp.w	d2,d4
		blt.w	return_1FEAC
		cmp.w	d3,d4
		bge.w	return_1FEAC

		move.b	Subtype(a0),d0
		bpl.s	Obj03_ICX_B1
		btst	#1,off2E(a1)
		bne.s	rts_2

Obj03_ICX_B1:
		btst	#6,d0
		bne.s   Obj03_ICX_B2
		btst	#3,d0
		sne	(a3)
		rts

Obj03_ICX_B2:
		tst.b	(a3)
		seq	(a3)
rts_2:
		rts
; ===========================================================================

Obj03_MainX_Alt:
		cmp.w	X_Pos(a1),d1
		bls.w	return_1FEAC
		move.b	#0,-1(a2)
		move.w	Y_Pos(a0),d2
		move.w	d2,d3
		move.w	off32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	Y_Pos(a1),d4
		cmp.w	d2,d4
		blt.w	return_1FEAC
		cmp.w	d3,d4
		bge.w	return_1FEAC
		move.b	Subtype(a0),d0
		bpl.s	Obj03_MXA_B1
		btst	#1,off2E(a1)
		bne.s	return_1FEAC

Obj03_MXA_B1:
		btst	#6,d0
		bne.s	Obj03_MXA_B2
		btst	#4,d0
		sne	(a3)
		rts

Obj03_MXA_B2:
		tst.b	(a3)
		seq	(a3)
return_1FEAC:
		rts

; ===========================================================================

Obj03_MainY:
		btst	#7,Subtype(a0)
		beq.s	.c
		btst	#1,Object_RAM+Status.w
		bne.s	return_1FEAC

.c
		move.w	Y_Pos(a0),d1
		lea	off34(a0),a2
		lea	Object_RAM,a1 ; a1=character

		tst.b	(a2)+
		bne.s	Obj03_MainY_Alt
		cmp.w	Y_Pos(a1),d1
		bhi.w	return_1FFB6
		move.b	#1,-1(a2)
		move.w	X_Pos(a0),d2
		move.w	d2,d3
		move.w	off32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	X_Pos(a1),d4
		cmp.w	d2,d4
		blt.w	return_1FFB6
		cmp.w	d3,d4
		bge.w	return_1FFB6
		move.b	Subtype(a0),d0
		bpl.s	Obj03_MY_B1
		btst	#1,off2E(a1)
		bne.s	rts_4

Obj03_MY_B1:
		btst	#6,d0
		bne.s   Obj03_MY_B2
		btst	#3,d0
		sne	(a3)
		rts

Obj03_MY_B2:
		tst.b	(a3)
		seq	(a3)
rts_4:
		rts

; ===========================================================================

Obj03_MainY_Alt:
		cmp.w	Y_Pos(a1),d1
		bls.w	return_1FFB6
		move.b	#0,-1(a2)
		move.w	X_Pos(a0),d2
		move.w	d2,d3
		move.w	off32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	X_Pos(a1),d4
		cmp.w	d2,d4
		blt.w	return_1FFB6
		cmp.w	d3,d4
		bge.w	return_1FFB6
		move.b	Subtype(a0),d0
		bpl.s	Obj03_MYA_B1
		btst	#1,off2E(a1)
		bne.s	return_1FFB6

Obj03_MYA_B1:
		btst	#6,d0
		bne.s	Obj03_MYA_B2
		btst	#4,d0
		sne	(a3)
		rts

Obj03_MYA_B2:
		tst.b	(a3)
		seq	(a3)
return_1FFB6:
		rts


; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	animate	level graphics
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AniArt_Load:				; XREF: Demo_Time; loc_F54
		cmpi.b	#8,$FFFFF600.w	; if not in level (or special stage), exit
		blt.s	return_1FFB6
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.s	return_1FFB6	; if yes, branch
		lea	VDP_Data_Port,a6
		bsr.w	AniArt_GiantRing
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	AniArt_Index(pc,d0.w),d0
		jmp	AniArt_Index(pc,d0.w)

; End of function AniArt_Load

; ===========================================================================
AniArt_Index:	dc.w AniArt_GHZ-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_MZ-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_SBZ-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - Green Hill
; ---------------------------------------------------------------------------

AniArt_GHZ:				; XREF: AniArt_Index
		subq.b	#1,($FFFFF7B1).w
		bpl.s	loc_1C08A
		move.b	#5,($FFFFF7B1).w ; time	to display each	frame for
		lea	(Art_GhzWater).l,a1 ; load waterfall patterns
		move.b	($FFFFF7B0).w,d0
		addq.b	#1,($FFFFF7B0).w
		andi.w	#1,d0
		beq.s	loc_1C078
		lea	$100(a1),a1	; load next frame

loc_1C078:
		move.l	#$6F000001,VDP_Control_Port ; VRAM address
		move.w	#7,d1		; number of 8x8	tiles
		bra.w	LoadTiles
; ===========================================================================

loc_1C08A:
		subq.b	#1,($FFFFF7B3).w
		bpl.s	loc_1C0C0
		move.b	#$F,($FFFFF7B3).w
		lea	(Art_GhzFlower1).l,a1 ;	load big flower	patterns
		move.b	($FFFFF7B2).w,d0
		addq.b	#1,($FFFFF7B2).w
		andi.w	#1,d0
		beq.s	loc_1C0AE
		lea	$200(a1),a1

loc_1C0AE:
		move.l	#$6B800001,VDP_Control_Port
		move.w	#$F,d1
		bra.w	LoadTiles
; ===========================================================================

loc_1C0C0:
		subq.b	#1,($FFFFF7B5).w
		bpl.s	locret_1C10C
		move.b	#7,($FFFFF7B5).w
		move.b	($FFFFF7B4).w,d0
		addq.b	#1,($FFFFF7B4).w
		andi.w	#3,d0
		move.b	byte_1C10E(pc,d0.w),d0
		btst	#0,d0
		bne.s	loc_1C0E8
		move.b	#$7F,($FFFFF7B5).w

loc_1C0E8:
		lsl.w	#7,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		move.l	#$6D800001,VDP_Control_Port
		lea	(Art_GhzFlower2).l,a1 ;	load small flower patterns
		lea	(a1,d0.w),a1
		move.w	#$B,d1
		bsr.w	LoadTiles

locret_1C10C:
		rts
; ===========================================================================
byte_1C10E:	dc.b 0,	1, 2, 1
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - Hidden Palace
; ---------------------------------------------------------------------------
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - Marble
; ---------------------------------------------------------------------------

AniArt_MZ:				; XREF: AniArt_Index
		subq.b	#1,($FFFFF7B1).w
		bpl.s	loc_1C150
		move.b	#$13,($FFFFF7B1).w
		lea	(Art_MzLava1).l,a1 ; load lava surface patterns
		moveq	#0,d0
		move.b	($FFFFF7B0).w,d0
		addq.b	#1,d0
		cmpi.b	#3,d0
		bne.s	loc_1C134
		moveq	#0,d0

loc_1C134:
		move.b	d0,($FFFFF7B0).w
		mulu.w	#$100,d0
		adda.w	d0,a1
		move.l	#$5C400001,VDP_Control_Port
		move.w	#7,d1
		bsr.w	LoadTiles

loc_1C150:
		subq.b	#1,($FFFFF7B3).w
		bpl.s	loc_1C1AE
		move.b	#1,($FFFFF7B3).w
		moveq	#0,d0
		move.b	($FFFFF7B0).w,d0
		lea	(Art_MzLava2).l,a4 ; load lava patterns
		ror.w	#7,d0
		adda.w	d0,a4
		move.l	#$5A400001,VDP_Control_Port
		moveq	#0,d3
		move.b	($FFFFF7B2).w,d3
		addq.b	#1,($FFFFF7B2).w
		move.b	($FFFFFE68).w,d3
		move.w	#3,d2

loc_1C188:
		move.w	d3,d0
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	(AniArt_MZextra).l,a3
		move.w	(a3,d0.w),d0
		lea	(a3,d0.w),a3
		movea.l	a4,a1
		move.w	#$1F,d1
		jsr	(a3)
		addq.w	#4,d3
		dbf	d2,loc_1C188
		rts
; ===========================================================================

loc_1C1AE:
		subq.b	#1,($FFFFF7B5).w
		bpl.w	locret_1C1EA
		move.b	#7,($FFFFF7B5).w
		lea	(Art_MzTorch).l,a1 ; load torch	patterns
		moveq	#0,d0
		move.b	($FFFFF7B6).w,d0
		addq.b	#1,($FFFFF7B6).w
		andi.b	#3,($FFFFF7B6).w
		mulu.w	#$C0,d0
		adda.w	d0,a1
		move.l	#$5E400001,VDP_Control_Port
		move.w	#5,d1
		bra.w	LoadTiles
; ===========================================================================

locret_1C1EA:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - Scrap Brain
; ---------------------------------------------------------------------------

AniArt_SBZ:				; XREF: AniArt_Index
		tst.b	($FFFFF7B4).w
		beq.s	loc_1C1F8
		subq.b	#1,($FFFFF7B4).w
		bra.s	loc_1C250
; ===========================================================================

loc_1C1F8:
		subq.b	#1,($FFFFF7B1).w
		bpl.s	loc_1C250
		move.b	#7,($FFFFF7B1).w
		lea	(Art_SbzSmoke).l,a1 ; load smoke patterns
		move.l	#$49000002,VDP_Control_Port
		move.b	($FFFFF7B0).w,d0
		addq.b	#1,($FFFFF7B0).w
		andi.w	#7,d0
		beq.s	loc_1C234
		subq.w	#1,d0
		mulu.w	#$180,d0
		lea	(a1,d0.w),a1
		move.w	#$B,d1
		bra.w	LoadTiles
; ===========================================================================

loc_1C234:
		move.b	#$B4,($FFFFF7B4).w

loc_1C23A:
		move.w	#5,d1
		bsr.w	LoadTiles
		lea	(Art_SbzSmoke).l,a1
		move.w	#5,d1
		bra.w	LoadTiles
; ===========================================================================

loc_1C250:
		tst.b	($FFFFF7B5).w
		beq.s	loc_1C25C
		subq.b	#1,($FFFFF7B5).w
		bra.s	locret_1C2A0
; ===========================================================================

loc_1C25C:
		subq.b	#1,($FFFFF7B3).w
		bpl.s	locret_1C2A0
		move.b	#7,($FFFFF7B3).w
		lea	(Art_SbzSmoke).l,a1
		move.l	#$4A800002,VDP_Control_Port
		move.b	($FFFFF7B2).w,d0
		addq.b	#1,($FFFFF7B2).w
		andi.w	#7,d0
		beq.s	loc_1C298
		subq.w	#1,d0
		mulu.w	#$180,d0
		lea	(a1,d0.w),a1
		move.w	#$B,d1
		bra.w	LoadTiles
; ===========================================================================

loc_1C298:
		move.b	#$78,($FFFFF7B5).w
		bra.s	loc_1C23A
; ===========================================================================

locret_1C2A0:
; ===========================================================================

AniArt_none:				; XREF: AniArt_Index
		rts

; ---------------------------------------------------------------------------
; Subroutine to	load (d1 - 1) 8x8 tiles
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadTiles:
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		dbf	d1,LoadTiles
		rts
; End of function LoadTiles

; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - more Marble Zone
; ---------------------------------------------------------------------------
AniArt_MZextra:	dc.w loc_1C3EE-AniArt_MZextra, loc_1C3FA-AniArt_MZextra
		dc.w loc_1C410-AniArt_MZextra, loc_1C41E-AniArt_MZextra
		dc.w loc_1C434-AniArt_MZextra, loc_1C442-AniArt_MZextra
		dc.w loc_1C458-AniArt_MZextra, loc_1C466-AniArt_MZextra
		dc.w loc_1C47C-AniArt_MZextra, loc_1C48A-AniArt_MZextra
		dc.w loc_1C4A0-AniArt_MZextra, loc_1C4AE-AniArt_MZextra
		dc.w loc_1C4C4-AniArt_MZextra, loc_1C4D2-AniArt_MZextra
		dc.w loc_1C4E8-AniArt_MZextra, loc_1C4FA-AniArt_MZextra
; ===========================================================================

loc_1C3EE:				; XREF: AniArt_MZextra
		move.l	(a1),(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C3EE
		rts
; ===========================================================================

loc_1C3FA:				; XREF: AniArt_MZextra
		move.l	2(a1),d0
		move.b	1(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C3FA
		rts
; ===========================================================================

loc_1C410:				; XREF: AniArt_MZextra
		move.l	2(a1),(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C410
		rts
; ===========================================================================

loc_1C41E:				; XREF: AniArt_MZextra
		move.l	4(a1),d0
		move.b	3(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C41E
		rts
; ===========================================================================

loc_1C434:				; XREF: AniArt_MZextra
		move.l	4(a1),(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C434
		rts
; ===========================================================================

loc_1C442:				; XREF: AniArt_MZextra
		move.l	6(a1),d0
		move.b	5(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C442
		rts
; ===========================================================================

loc_1C458:				; XREF: AniArt_MZextra
		move.l	6(a1),(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C458
		rts
; ===========================================================================

loc_1C466:				; XREF: AniArt_MZextra
		move.l	8(a1),d0
		move.b	7(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C466
		rts
; ===========================================================================

loc_1C47C:				; XREF: AniArt_MZextra
		move.l	8(a1),(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C47C
		rts
; ===========================================================================

loc_1C48A:				; XREF: AniArt_MZextra
		move.l	X_Pos2(a1),d0
		move.b	9(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C48A
		rts
; ===========================================================================

loc_1C4A0:				; XREF: AniArt_MZextra
		move.l	X_Pos2(a1),(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C4A0
		rts
; ===========================================================================

loc_1C4AE:				; XREF: AniArt_MZextra
		move.l	Y_Pos(a1),d0
		move.b	$B(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C4AE
		rts
; ===========================================================================

loc_1C4C4:				; XREF: AniArt_MZextra
		move.l	Y_Pos(a1),(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C4C4
		rts
; ===========================================================================

loc_1C4D2:				; XREF: AniArt_MZextra
		move.l	Y_Pos(a1),d0
		rol.l	#8,d0
		move.b	0(a1),d0
		move.l	d0,(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C4D2
		rts
; ===========================================================================

loc_1C4E8:				; XREF: AniArt_MZextra
		move.w	Y_Pos2(a1),(a6)
		move.w	0(a1),(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C4E8
		rts
; ===========================================================================

loc_1C4FA:				; XREF: AniArt_MZextra
		move.l	0(a1),d0
		move.b	$F(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	X_Vel(a1),a1
		dbf	d1,loc_1C4FA
		rts

; ---------------------------------------------------------------------------
; Animated pattern routine - giant ring
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AniArt_GiantRing:			; XREF: AniArt_Load
		tst.w	($FFFFF7BE).w
		bne.s	loc_1C518
		rts
; ===========================================================================

loc_1C518:
		subi.w	#$1C0,($FFFFF7BE).w
		lea	(Art_BigRing).l,a1 ; load giant	ring patterns
		moveq	#0,d0
		move.w	($FFFFF7BE).w,d0
		lea	(a1,d0.w),a1
		addi.w	#$8000,d0
		lsl.l	#2,d0
		lsr.w	#2,d0
		ori.w	#$4000,d0
		swap	d0
		move.l	d0,Mappings_Offset(a6)
		move.w	#$D,d1
		bra.w	LoadTiles
; End of function AniArt_GiantRing

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 21 - SCORE, TIME, RINGS
; ---------------------------------------------------------------------------

Obj21:
		moveq	#0,d0
		move.b	Routine(a0),d0
		move.w	Obj21_Index(pc,d0.w),d1
		jsr	Obj21_Index(pc,d1.w)
		jmp	DisplaySprite
; ===========================================================================
Obj21_Index:	dc.w Obj21_Main-Obj21_Index
		dc.w Obj21_Flash-Obj21_Index
		dc.w Obj21_Delete-Obj21_Index
		dc.w Obj21_FadeOut-Obj21_Index
		dc.w Obj21_FlashMoving-Obj21_Index
		dc.w Obj21_FlashMovingS-Obj21_Index
		dc.w .LivesFinal-Obj21_Index
		dc.w .MainFrame-Obj21_Index
		dc.w .MainFrame2-Obj21_Index
		dc.w .scrollOff-Obj21_Index
		dc.w .scrollIn-Obj21_Index
; ===========================================================================


.MainFrame	subq.w	#2,X_pos(a0)		; move out of the screen
		bpl.s	.rts			; if still positive, branch
		add.w	#Obj21_EggFrame-Obj21_SCOR,Mappings_Offset+2(a0); new mappings
		addq.b	#2,Routine(a0)		; move back
		move.b	#$88,BossLives.w

.MainFrame2	addq.w	#2,X_pos(a0)		; move to screen
		cmpi.w	#$90,X_pos(a0)		; is on position?
		blt.s	.rts			; no? go away then
		move.w	#$90,X_pos(a0)		; set precision position
		subq.b	#4,Routine(a0)		; do nothing from now on
.rts		rts

; ===========================================================================
.respawnHUD	addq.b	#6,Routine(a0)		; respawn hud routine

.scrollOff	subq.w	#2,X_pos(a0)		; move out of the screen
		bpl.s	.rts			; if still positive, branch
		sf	Render_Flags(a0)
		sub.w	#Obj21_EggFrame-Map_obj21,Mappings_Offset+2(a0); new mappings
		addq.b	#2,Routine(a0)		; scroll back in

.scrollIn	addq.w	#2,X_pos(a0)		; move to screen
		cmpi.w	#$90,X_pos(a0)		; is on position?
		blt.s	.rts			; no? go away then
		andi.b	#2,Routine(a0)		; back to main code
		rts
; ===========================================================================
.LivesFinal	tst.b	$FFFFFE08.w	; is debug mode	on?
		bne.s	Obj21_Delete

		tst.b	BossMode.w
		bmi	Obj21_rts
		cmpa.w	#Hud_RAM,a0
		beq.s	.respawnHUD

Obj21_Delete:	jmp	DeleteObject

; ===========================================================================
Obj21_FlashMovingS:
		bsr.s	Obj21_FlashMoving
		addq.w	#5,Mappings_Offset+2(a0); correct the mappings offset (S and not RING)
		rts

Obj21_FlashMoving:
		lea	Obj21_RINGyell(pc),a1
		btst	#3,($FFFFFE05).w
		bne.s	.a
		lea	Obj21_RINGred(pc),a1	; sets mappings accordingly

.a		move.l	a1,Mappings_Offset(a0)	; save mappings
		subq.w	#2,X_pos(a0)		; move
		bmi.s	Obj21_Delete		; if negative, kill
Obj21_rts:
		rts

; ===========================================================================
Obj21_FadeOut:
		subq.w	#2,X_pos(a0)	; move out
		bmi	Obj21_Delete	; if negative, kill it
		move.b	Off38(a0),d0	; else get the routine offset
		add.b	d0,Routine(a0)	; add to routine counter
		rts

; ===========================================================================
Obj21_Main:				; XREF: Obj21_Main
		addq.b	#2,Routine(a0)
		move.w	#$90,X_pos(a0)
		move.w	#$108,X_Pos2(a0)
		move.l	#Map_obj21,Mappings_Offset(a0)
		move.w	#$6CA,Art_Tile(a0)
		sf	Render_Flags(a0)
		sf	Priority(a0)

Obj21_Flash:				; XREF: Obj21_Main
		tst.b	BossMode.w	; is a boss?
		bpl	.normal		; no? branch
		tst.b	$FFFFFE08.w	; is debug mode	on?
		bne.s	.normal		; yes? branch

		sf	Anim_Frame(a0)	; clear ani frame for the next step
		move.b	(a0),d4		; get object id
		lea	.list(pc),a4	; get the routine offset list ready
		jsr	loc_8486_2	; create object from each sprite piece

		move.l	#SonArtInformLoc,d1	; get graphics offset
		move.w	#$D480,d2		; VRAM offset
		move.w	#4*32,d3		; 4 tiles to load
		jmp	QueueDMATransfer	; queue the art load

.list		dc.b 8, 0, 0, 0, 0, 2, 4, 0, 6	; routine offsets from routine #6
		even

; ===========================================================================
.normal

Obj21_Flash2:
		moveq	#0,d0
		btst	#3,$FFFFFE05.w
		bne.s	.disp

		tst.w	$FFFFFE20.w	; do you have any rings?
		bne.s	.chk		; if do, branch
		addq.w	#1,d0		; make ring counter flash red

.chk		cmpi.b	#9,$FFFFFE23.w	; have 9 minutes elapsed?
		bne.s	.a		; if not, branch
		addq.w	#2,d0		; make time counter flash red

.a		cmp.b	#7,$FFFFFE10.w
		bne.s	.disp
		tst.b	$FFFFFE23.w
		bne.s	.disp
		addq.w	#2,d0		; make time counter flash red

.disp		move.b	d0,Anim_Frame(a0)
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - SCORE, TIME, RINGS
; ---------------------------------------------------------------------------
Map_obj21:
	include "_maps\obj21.asm"

; ---------------------------------------------------------------------------
; Add points subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AddPoints:
		move.b	#1,($FFFFFE1F).w ; set score counter to	update
		lea	($FFFFFFC0).w,a2
		lea	($FFFFFE26).w,a3
		add.l	d0,(a3)		; add d0*10 to the score
		move.l	#999999,d1
		cmp.l	(a3),d1		; is #999999 higher than the score?
		bhi.w	loc_1C6AC	; if yes, branch
		move.l	d1,(a3)		; reset	score to #999999
		move.l	d1,(a2)

loc_1C6AC:
		move.l	(a3),d0
		cmp.l	(a2),d0
		blo.w	locret_1C6B6
		move.l	d0,(a2)

locret_1C6B6:
		rts
; End of function AddPoints

; ---------------------------------------------------------------------------
; Subroutine to	update the HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudUpdate:
  		tst.b	$FFFFFE08.w	; is debug mode	on?
		bne.w	HudDebug	; if yes, branch
		tst.b	BossMode.w
		bmi	Hud_FZBss

		tst.b	($FFFFFE1F).w	; does the score need updating?
		beq.s	Hud_ChkRings	; if not, branch
		sf	($FFFFFE1F).w
		move.l	#$5C800003,d0	; set VRAM address
		move.l	($FFFFFE26).w,d1 ; load	score
		bsr.w	Hud_Score

Hud_ChkRings:
		tst.b	($FFFFFE1D).w	; does the ring	counter	need updating?
		beq.s	Hud_ChkTime	; if not, branch
		bpl.s	loc_1C6E4
		bsr.w	Hud_LoadZero

loc_1C6E4:
		sf	($FFFFFE1D).w
		move.l	#$5F400003,d0	; set VRAM address
		moveq	#0,d1
		move.w	($FFFFFE20).w,d1 ; load	number of rings
		bsr.w	Hud_Rings

Hud_ChkTime:
		bsr	updateclock

Hud_ChkLives:
		tst.b	($FFFFFE1C).w	; does the lives counter need updating?
		beq.s	Hud_ChkBonus	; if not, branch
		sf	($FFFFFE1C).w
		bsr.w	Hud_Lives

Hud_ChkBonus:
		tst.b	($FFFFF7D6).w	; do time/ring bonus counters need updating?
		beq	Hud_End		; if not, branch
		sf	($FFFFF7D6).w
		move.l	#$6E000002,VDP_Control_Port
		moveq	#0,d1
		move.w	($FFFFF7D2).w,d1 ; load	time bonus
		bsr.w	Hud_TimeRingBonus
		moveq	#0,d1
		move.w	($FFFFF7D4).w,d1 ; load	ring bonus
		bra.w	Hud_TimeRingBonus

Hud_FZBss:
		tst.b	($FFFFFE1C).w	; does the lives counter need updating?
		beq.s	Hud_BossHits	; if not, branch
		sf	($FFFFFE1C).w
		bsr.w	Hud_Lives

Hud_BossHits:
		bclr	#7,BossLives.w
		beq.s	updateclock

		moveq	#0,d1
		move.b	BossLives.w,d1
		move.l	#$54A00003,d0	; set VRAM address
		bsr.w	Hud_Lives_

updateclock:
		tst.b	$FFFFFE1E.w	; does the time	need updating?
		beq.s	Hud_End		; if not, branch
		tst.w	$FFFFF63A.w	; is the game paused?
		bne.s	Hud_End		; if yes, branch
		lea	$FFFFFE22.w,a1
		cmp.b	#7,$FFFFFE10.w
		bne.s	.normal

		tst.l	(a1)+
		beq.s	TimeOver
		subq.b	#1,-(a1)
		bpl	updateTime
		move.b	#59,(a1)
		subq.b	#1,-(a1)
		bpl	Hud_End
		move.b	#59,(a1)
		subq.b	#1,-(a1)
		bpl	Hud_End
		move.b	#0,(a1)
		rts

.normal		cmpi.l	#$93B3B,(a1)+	; is the time 9.59?
		beq	TimeOver	; if yes, branch
		addq.b	#1,-(a1)
		cmpi.b	#60,(a1)
		blo.s	updateTime
		move.b	#0,(a1)
		addq.b	#1,-(a1)
		cmpi.b	#60,(a1)
		blo.s	Hud_End
		move.b	#0,(a1)
		addq.b	#1,-(a1)
		cmpi.b	#9,(a1)
		blo.s	Hud_End
		move.b	#9,(a1)

Hud_End:
		rts

updateTime:
		move.l	#$5E400003,d0
		moveq	#0,d1
		move.b	($FFFFFE23).w,d1 ; load	minutes
		bsr.w	Hud_Mins
		move.l	#$5EC00003,d0
		moveq	#0,d1
		move.b	($FFFFFE24).w,d1 ; load	seconds
		bra.w	Hud_Secs
; ===========================================================================

TimeOver:				; XREF: Hud_ChkTime
		sf	($FFFFFE1E).w
		lea	Object_RAM,a0
		movea.l	a0,a2
		bsr.w	KillSonic
		move.b	#1,($FFFFFE1A).w
		rts
; ===========================================================================

HudDebug:				; XREF: HudUpdate
		bsr.w	HudDb_XY
		sf	$FFFFFE1D.w

HudDb_ObjCount:
		move.l	#$5F800003,d0	; set VRAM address
		moveq	#0,d1
		move.b	($FFFFF62B).w,d1 ; load	"number	of objects" counter
		bsr.w	Hud_Secs
		tst.b	($FFFFFE1C).w	; does the lives counter need updating?
		beq.s	HudDb_ChkBonus	; if not, branch
		sf	($FFFFFE1C).w
		bsr.w	Hud_Lives

HudDb_ChkBonus:
		tst.b	($FFFFF7D6).w	; does the ring/time bonus counter need	updating?
		beq.s	HudDb_End	; if not, branch
		sf	($FFFFF7D6).w
		move.l	#$6E000002,VDP_Control_Port ; set VRAM address
		moveq	#0,d1
		move.w	($FFFFF7D2).w,d1 ; load	time bonus
		bsr.w	Hud_TimeRingBonus
		moveq	#0,d1
		move.w	($FFFFF7D4).w,d1 ; load	ring bonus
		bsr.w	Hud_TimeRingBonus

HudDb_End:
		move.l	#$5E400003,($C00004).l ; set VRAM address
		move.l	FreeCycles.w,d1
		bsr	HudDb_XY2
		rts
; End of function HudUpdate

; ---------------------------------------------------------------------------
; Subroutine to	load "0" on the	HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_LoadZero:				; XREF: HudUpdate
		move.l	#$5F400003,VDP_Control_Port
		lea	Hud_TilesZero(pc),a2
		move.w	#2,d2
		bra.s	loc_1C83E
; End of function Hud_LoadZero

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed HUD patterns ("E", "0", colon)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Base:				; XREF: Level; SS_EndLoop; EndingSequence
		lea	VDP_Data_Port,a6
		bsr.w	Hud_Lives
		move.l	#$5C400003,VDP_Control_Port
		lea	Hud_TilesBase(pc),a2
		move.w	#$E,d2

loc_1C83E:				; XREF: Hud_LoadZero
		lea	Art_Hud(pc),a1

loc_1C842:
		move.w	#$F,d1
		move.b	(a2)+,d0
		bmi.s	loc_1C85E
		ext.w	d0
		lsl.w	#5,d0
		lea	(a1,d0.w),a3

loc_1C852:
		move.l	(a3)+,(a6)
		dbf	d1,loc_1C852

loc_1C858:
		dbf	d2,loc_1C842

		rts
; ===========================================================================

loc_1C85E:
		move.l	#0,(a6)
		dbf	d1,loc_1C85E

		bra.s	loc_1C858
; End of function Hud_Base

; ===========================================================================
Hud_TilesBase:	dc.b $16, $FF, $FF, $FF, $FF, $FF, $FF,	0, 0, $14, 0, 0
Hud_TilesZero:	dc.b $FF, $FF, 0, 0
; ---------------------------------------------------------------------------
; Subroutine to	load debug mode	numbers	patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudDb_XY:				; XREF: HudDebug
		move.l	#$5C400003,VDP_Control_Port ; set VRAM address
		move.w	($FFFFF700).w,d1 ; load	camera x-position
		swap	d1
		move.w	Object_RAM+X_Pos,d1 ; load	Sonic's x-position
		bsr.s	HudDb_XY2
		move.w	($FFFFF704).w,d1 ; load	camera y-position
		swap	d1
		move.w	Object_RAM+Y_Pos,d1 ; load	Sonic's y-position
; End of function HudDb_XY


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudDb_XY2:
		moveq	#7,d6
		lea	(Art_Text).l,a1

HudDb_XYLoop:
		rol.w	#4,d1
		move.w	d1,d2
		andi.w	#$F,d2
		cmpi.w	#$A,d2
		blo.s	loc_1C8B2
		addq.w	#7,d2

loc_1C8B2:
		lsl.w	#5,d2
		lea	(a1,d2.w),a3
		rept 8
		move.l	(a3)+,(a6)
		endr
		swap	d1
		dbf	d6,HudDb_XYLoop	; repeat 7 more	times

		rts
; End of function HudDb_XY2
; ---------------------------------------------------------------------------
; Subroutine to	load rings numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Rings:				; XREF: HudUpdate
		lea	(Hud_100).l,a2
		moveq	#2,d6
		bra.s	Hud_LoadArt
; End of function Hud_Rings

; ---------------------------------------------------------------------------
; Subroutine to	load score numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Score:				; XREF: HudUpdate
		lea	(Hud_100000).l,a2
		moveq	#5,d6

Hud_LoadArt:
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_ScoreLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C8EC:
		sub.l	d3,d1
		blo.s	loc_1C8F4
		addq.w	#1,d2
		bra.s	loc_1C8EC
; ===========================================================================

loc_1C8F4:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1C8FE
		move.w	#1,d4

loc_1C8FE:
		tst.w	d4
		beq.s	loc_1C92C
		lsl.w	#6,d2
		move.l	d0,4(a6)
		lea	(a1,d2.w),a3
		rept 16
		move.l	(a3)+,(a6)
		endr

loc_1C92C:
		addi.l	#$400000,d0
		dbf	d6,Hud_ScoreLoop

		rts
; End of function Hud_Score

; ---------------------------------------------------------------------------
; Subroutine to	load countdown numbers on the continue screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ContScrCounter:				; XREF: ContinueScreen
		move.l	#$5F800003,VDP_Control_Port ; set VRAM address
		lea	VDP_Data_Port,a6
		lea	(Hud_10).l,a2
		moveq	#1,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1 ; load numbers patterns

ContScr_Loop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C95A:
		sub.l	d3,d1
		blo.s	loc_1C962
		addq.w	#1,d2
		bra.s	loc_1C95A
; ===========================================================================

loc_1C962:
		add.l	d3,d1
		lsl.w	#6,d2
		lea	(a1,d2.w),a3
		rept 16
		move.l	(a3)+,(a6)
		endr
		dbf	d6,ContScr_Loop	; repeat 1 more	time

		rts
; End of function ContScrCounter

; ===========================================================================
; ---------------------------------------------------------------------------
; HUD counter sizes
; ---------------------------------------------------------------------------
DLC_num:
Hud_1000000000:	dc.l 1000000000
Hud_100000000:	dc.l 100000000
Hud_10000000:	dc.l 10000000
Hud_1000000:	dc.l 1000000
Hud_100000:	dc.l 100000		; XREF: Hud_Score
Hud_10000:	dc.l 10000
Hud_1000:	dc.l 1000		; XREF: Hud_TimeRingBonus
Hud_100:	dc.l 100		; XREF: Hud_Rings
Hud_10:		dc.l 10			; XREF: ContScrCounter; Hud_Secs; Hud_Lives
Hud_1:		dc.l 1			; XREF: Hud_Mins

; ---------------------------------------------------------------------------
; Subroutine to	load time numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Mins:				; XREF: Hud_ChkTime
		lea	(Hud_1).l,a2
		moveq	#0,d6
		bra.s	loc_1C9BA
; End of function Hud_Mins


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Secs:				; XREF: Hud_ChkTime
		lea	(Hud_10).l,a2
		moveq	#1,d6

loc_1C9BA:
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_TimeLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C9C4:
		sub.l	d3,d1
		blo.s	loc_1C9CC
		addq.w	#1,d2
		bra.s	loc_1C9C4
; ===========================================================================

loc_1C9CC:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1C9D6
		move.w	#1,d4

loc_1C9D6:
		lsl.w	#6,d2
		move.l	d0,4(a6)
		lea	(a1,d2.w),a3
		rept 16
		move.l	(a3)+,(a6)
		endr
		addi.l	#$400000,d0
		dbf	d6,Hud_TimeLoop

		rts
; End of function Hud_Secs

; ---------------------------------------------------------------------------
; Subroutine to	load time/ring bonus numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_TimeRingBonus:			; XREF: Hud_ChkBonus
		lea	(Hud_1000).l,a2
		moveq	#3,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_BonusLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1CA1E:
		sub.l	d3,d1
		blo.s	loc_1CA26
		addq.w	#1,d2
		bra.s	loc_1CA1E
; ===========================================================================

loc_1CA26:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1CA30
		move.w	#1,d4

loc_1CA30:
		tst.w	d4
		beq.s	Hud_ClrBonus
		lsl.w	#6,d2
		lea	(a1,d2.w),a3
		rept 16
		move.l	(a3)+,(a6)
		endr

loc_1CA5A:
		dbf	d6,Hud_BonusLoop ; repeat 3 more times

		rts
; ===========================================================================

Hud_ClrBonus:
		moveq	#$F,d5

Hud_ClrBonusLoop:
		move.l	#0,(a6)
		dbf	d5,Hud_ClrBonusLoop

		bra.s	loc_1CA5A
; End of function Hud_TimeRingBonus

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed lives	counter	patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Lives:				; XREF: Hud_ChkLives
		move.l	#$7B200003,d0	; set VRAM address
		moveq	#0,d1
		move.b	($FFFFFE12).w,d1 ; load	number of lives

Hud_Lives_:
		lea	(Hud_10).l,a2
		moveq	#1,d6
		moveq	#0,d4
		lea	Art_LivesNums(pc),a1

Hud_LivesLoop:
		move.l	d0,4(a6)
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1CA90:
		sub.l	d3,d1
		blo.s	loc_1CA98
		addq.w	#1,d2
		bra.s	loc_1CA90
; ===========================================================================

loc_1CA98:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1CAA2
		move.w	#1,d4

loc_1CAA2:
	;	tst.w	d4
	;	beq.s	Hud_ClrLives

loc_1CAA6:
		lsl.w	#5,d2
		lea	(a1,d2.w),a3
		rept 8
		move.l	(a3)+,(a6)
		endr

loc_1CABC:
		addi.l	#$400000,d0
		dbf	d6,Hud_LivesLoop ; repeat 1 more time

		rts
; ===========================================================================

Hud_ClrLives:
		tst.w	d6
		beq.s	loc_1CAA6
		moveq	#7,d5

Hud_ClrLivesLoop:
		move.l	#0,(a6)
		dbf	d5,Hud_ClrLivesLoop
		bra.s	loc_1CABC
; End of function Hud_Lives

; ===========================================================================
Art_Hud:	incbin	artunc\HUD.bin		; 8x16 pixel numbers on HUD
		even
Art_LivesNums:	incbin	artunc\livescnt.bin	; 8x8 pixel numbers on lives counter
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; When debug mode is currently in use
; ---------------------------------------------------------------------------

DebugMode:				; XREF: Obj01; Obj09
		moveq	#0,d0
		move.b	$FFFFFE08.w,d0
		move.w	Debug_Index-2(pc,d0.w),d0
		jmp	Debug_Index-2(pc,d0.w)
; ===========================================================================
Debug_Index:	dc.w Debug_Main-Debug_Index-2
		dc.w Debug_Skip-Debug_Index-2
; ===========================================================================

Debug_Main:				; XREF: Debug_Index
		addq.b	#2,$FFFFFE08.w
		move.b	#2,Object_Ram+Routine
		bclr	#6,Object_Ram+Status

		moveq	#0,d0
		move.w	d0,Object_Ram+X_Vel.w
		move.l	d0,Object_Ram+Y_Vel.w
		move.l	d0,If_Spindash.w
		move.l	d0,Player_DJ_Data.w
		move.b	d0,PeelOut_Flag.w
		move.b	d0,SpinDust_RAM+Anim.w	; clear Spin Dash dust animation
		move.b	#$21,Hud_RAM.w
		sf	Hud_RAM+Routine.w

		move.w	($FFFFF72C).w,($FFFFFEF0).w ; buffer level x-boundary
		move.w	($FFFFF726).w,($FFFFFEF2).w ; buffer level y-boundary
		move.w	d0,($FFFFF72C).w
		move.w	#$720,($FFFFF726).w
		andi.w	#$7FF,Object_RAM+Y_Pos.w
		andi.w	#$7FF,($FFFFF704).w
		andi.w	#$3FF,($FFFFF70C).w
		move.b	d0,Anim_Frame(a0)
		move.b	d0,Anim(a0)
		cmpi.b	#$10,($FFFFF600).w ; is	game mode = $10	(special stage)?
		bne.s	Debug_Zone	; if not, branch
		move.w	d0,($FFFFF782).w ; stop	special	stage rotating
		move.w	d0,($FFFFF780).w ; make	special	stage "upright"
		moveq	#6,d0		; use 6th debug	item list
		bra.s	Debug_UseList
; ===========================================================================

Debug_Zone:
                moveq	#0,d6
Debug_UseList:
		lea	DebugList,a2
		move.w	(a2)+,d6
		cmp.b	($FFFFFE06).w,d6
		bhi.s	loc_1CF9E
		move.b	#0,($FFFFFE06).w

loc_1CF9E:
		bsr.w	Debug_ShowItem
		move.b	#$C,($FFFFFE0A).w
		move.b	#1,($FFFFFE0B).w

Debug_Skip:				; XREF: Debug_Index
		moveq	#0,d0

loc_1CFBE:
		lea	DebugList,a2
		move.w	(a2)+,d6
		bsr.w	Debug_Control
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Debug_Control:
		moveq	#0,d4
		move.w	#1,d1
		move.b	($FFFFF605).w,d4
		andi.w	#$F,d4		; is up/down/left/right	pressed?
		bne.s	loc_1D018	; if yes, branch
		move.b	($FFFFF604).w,d0
		andi.w	#$F,d0
		bne.s	loc_1D000
		move.b	#$C,($FFFFFE0A).w
		move.b	#$F,($FFFFFE0B).w
		bra.w	Debug_BackItem
; ===========================================================================

loc_1D000:
		subq.b	#1,($FFFFFE0A).w
		bne.s	loc_1D01C
		move.b	#1,($FFFFFE0A).w
		addq.b	#1,($FFFFFE0B).w
		bne.s	loc_1D018
		move.b	#-1,($FFFFFE0B).w

loc_1D018:
		move.b	($FFFFF604).w,d4

loc_1D01C:
		moveq	#0,d1
		move.b	($FFFFFE0B).w,d1
		addq.w	#1,d1
		swap	d1
		asr.l	#4,d1
		move.l	Y_Pos(a0),d2
		move.l	X_pos(a0),d3
		btst	#0,d4		; is up	being pressed?
		beq.s	loc_1D03C	; if not, branch
		sub.l	d1,d2
		bhs.s	loc_1D03C
		moveq	#0,d2

loc_1D03C:
		btst	#1,d4		; is down being	pressed?
		beq.s	loc_1D052	; if not, branch
		add.l	d1,d2
		cmpi.l	#$7FF0000,d2
		blo.s	loc_1D052
		move.l	#$7FF0000,d2

loc_1D052:
		btst	#2,d4
		beq.s	loc_1D05E
		sub.l	d1,d3
		bhs.s	loc_1D05E
		moveq	#0,d3

loc_1D05E:
		btst	#3,d4
		beq.s	loc_1D066
		add.l	d1,d3

loc_1D066:
		move.l	d2,Y_Pos(a0)
		move.l	d3,X_pos(a0)

Debug_BackItem:
		btst	#6,($FFFFF604).w ; is button A pressed?
		beq.s	Debug_MakeItem	; if not, branch
		btst	#5,($FFFFF605).w ; is button C pressed?
		beq.s	Debug_NextItem	; if not, branch
		subq.b	#1,($FFFFFE06).w ; go back 1 item
		bhs.s	Debug_NoLoop
		add.b	d6,($FFFFFE06).w
		bra.s	Debug_NoLoop
; ===========================================================================

Debug_NextItem:
		btst	#6,($FFFFF605).w ; is button A pressed?
		beq.s	Debug_MakeItem	; if not, branch
		addq.b	#1,($FFFFFE06).w ; go forwards 1 item
		cmp.b	($FFFFFE06).w,d6
		bhi.s	Debug_NoLoop
		move.b	#0,($FFFFFE06).w ; loop	back to	first item

Debug_NoLoop:
		bra.w	Debug_ShowItem
; ===========================================================================

Debug_MakeItem:
		btst	#5,($FFFFF605).w ; is button C pressed?
		beq.s	Debug_Exit	; if not, branch
		jsr	SingleObjLoad
		bne.s	Debug_Exit
		move.w	X_pos(a0),X_pos(a1)
		move.w	Y_Pos(a0),Y_Pos(a1)
		move.b	Mappings_Offset(a0),(a1)	; create object
		move.b	Render_Flags(a0),Render_Flags(a1)
		move.b	Render_Flags(a0),Status(a1)
		andi.b	#$7F,Status(a1)
		moveq	#0,d0
		move.b	($FFFFFE06).w,d0
		lsl.w	#3,d0
		move.b	4(a2,d0.w),Subtype(a1)
		move.b  #1,Off3F(a1)
		move.l	a1,$FFFFFF60.w
Debug_DoNothing:
		rts
; ===========================================================================

Debug_Exit:
		btst	#4,($FFFFF605).w ; is button B pressed?
		beq.w	Debug_DoNothing	; if not, branch
		moveq	#0,d0
		move.b	d0,$FFFFFE08.w ; deactivate debug mode
		move.l	Player_MapLoc,Object_RAM+Mappings_Offset.w
		move.w	#$780,Object_RAM+Art_Tile.w
		sf	Object_RAM+Anim.w
		move.w	d0,X_Pos2(a0)
		move.w	d0,Y_Pos2(a0)
		move.w	($FFFFFEF0).w,($FFFFF72C).w ; restore level boundaries
		move.w	($FFFFFEF2).w,($FFFFF726).w

Debug_Exitnormal:
		move.w	d0,Object_RAM+X_Vel.w
		move.w	d0,Object_RAM+Y_Vel.w
		move.w	d0,Object_RAM+Inertia.w
		move.w	d0,Object_RAM+Off3C.w
		andi.b	#1,Object_RAM+Status.w	; clear everything but orientation
		bset	#1,Object_RAM+Status.w	; set to air
		move.b  #2,Object_RAM+Anim.w
		sf	Object_RAM+Routine2.w
		addq.l	#4,sp
		sf	Object_RAM+Off38.w
		ori.b	#1,($FFFFFE1F).w 	; update score	counter
		move.b	#1,($FFFFFE1D).w 	; update rings	counter
		move.b	#1,($FFFFFE1E).w 	; update time counter

		bsr	Hud_Base		; clear debug X/Y coordinates
		jsr	Sonic_Setspeed
		jmp	SetPlayerDisplay
; End of function Debug_Control


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Debug_ShowItem:				; XREF: Debug_Main
		moveq	#0,d0
		move.b	($FFFFFE06).w,d0
		lsl.w	#3,d0
		move.l	(a2,d0.w),Mappings_Offset(a0)	; load mappings	for item
		move.w	6(a2,d0.w),Art_Tile(a0) ; load	VRAM setting for item
		move.b	5(a2,d0.w),Anim_Frame(a0) ; load frame	number for item
		rts
; End of function Debug_ShowItem

; ===========================================================================
; ---------------------------------------------------------------------------
; Debug	list - Green Hill
; ---------------------------------------------------------------------------
DebugList:
	include "_inc\Debug list - GHZ.asm"
; ---------------------------------------------------------------------------
; Main level load blocks
; ---------------------------------------------------------------------------
MainLoadBlocks:
	include "_inc\Main level load blocks.asm"

; ---------------------------------------------------------------------------
; Pattern load cues
; ---------------------------------------------------------------------------
ArtLoadCues:
	include "_inc\Pattern load cues.asm"


; ---------------------------------------------------------------------------
; Sprite mappings - Sonic
; ---------------------------------------------------------------------------
Map_Sonic:
	include "_maps\Sonic.asm"
; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Sonic
; ---------------------------------------------------------------------------
SonicDynPLC:
	include "_inc\Sonic dynamic pattern load cues.asm"
; ---------------------------------------------------------------------------
; Sprite mappings - knuckles
; ---------------------------------------------------------------------------
Map_Knux:
	include "_maps\Knux.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Knuckles
; ---------------------------------------------------------------------------
KnuxDynPLC:
	include "_inc\Knux DPLC.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Tails
; ---------------------------------------------------------------------------
Map_Tails:
	include "_maps\tails.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Tails
; ---------------------------------------------------------------------------
TailsDynPLC:
	include "_inc\Tails_DPLC.asm"

; ---------------------------------------------------------------------------
; Compressed graphics - various
; ---------------------------------------------------------------------------
Comp_Stars:	incbin	artunc\invstars.bin.comper; invincibility stars
		even
Nem_WtrFall:	incbin	artnem\WatrFall.nem	; HPZ waterfall object
		even
Nem_Orbs:	incbin	artnem\orbs.nem		; HPZ orbs
		even
HPZ_Orbs:	incbin	misc\Orbs.dat		; data for HPZ orbs animated art
		even
Nem_HPZ_BDG:	incbin artnem\bridge.nem
		even
Nem_HPZ_PTFM:	incbin artnem\platform.nem
		even
Nem_Locks	incbin artnem\portallocks.nem
		even
; ---------------------------------------------------------------------------
; Compressed graphics - GHZ stuff
; ---------------------------------------------------------------------------
Nem_Stalk:	incbin	artnem\ghzstalk.bin	; GHZ flower stalk
		even
Nem_Swing:	incbin	artnem\ghzswing.bin	; GHZ swinging platform
		even
Nem_Bridge:	incbin	artnem\ghzbridg.bin	; GHZ bridge
		even
Nem_GhzUnkBlock:incbin	artnem\xxxghzbl.bin	; unused GHZ block
		even
Nem_Ball:	incbin	artnem\ghzball.bin	; GHZ giant ball
		even
Nem_Spikes:	incbin	artnem\spikes.bin	; spikes
		even
Nem_SpikePole:	incbin	artnem\ghzlog.bin	; GHZ spiked log
		even
Nem_PplRock:	incbin	artnem\ghzrock.bin	; GHZ purple rock
		even
Nem_GhzWall1:	incbin	artnem\ghzwall1.bin	; GHZ destroyable wall
		even
Nem_GhzWall2:	incbin	artnem\ghzwall2.bin	; GHZ normal wall
		even
; ---------------------------------------------------------------------------
; Compressed graphics - LZ stuff
; ---------------------------------------------------------------------------
Nem_Water:	incbin	artnem\lzwater.bin	; LZ water surface
		even
Nem_Splash:	incbin	artnem\lzsplash.bin	; LZ waterfalls and splashes
		even
Nem_LzSpikeBall:incbin	artnem\lzspball.bin	; LZ spiked ball on chain
		even
Nem_FlapDoor:	incbin	artnem\lzflapdo.bin	; LZ flapping door
		even
Nem_Bubbles:	incbin	artnem\lzbubble.bin	; LZ bubbles and countdown numbers
		even
Nem_LzBlock3:	incbin	artnem\lzblock3.bin	; LZ 32x16 block
		even
Nem_LzDoor1:	incbin	artnem\lzvdoor.bin	; LZ vertical door
		even
Nem_Harpoon:	incbin	artnem\lzharpoo.bin	; LZ harpoon
		even
Nem_LzPole:	incbin	artnem\lzpole.bin	; LZ pole that breaks
		even
Nem_LzDoor2:	incbin	artnem\lzhdoor.bin	; LZ large horizontal door
		even
Nem_LzWheel:	incbin	artnem\lzwheel.bin	; LZ wheel from corner of conveyor belt
		even
Nem_LzBlock2:	incbin	artnem\lzblock2.bin	; LZ blocks
		even
Nem_LzPlatfm:	incbin	artnem\lzptform.bin	; LZ rising platforms
		even
Nem_Cork:	incbin	artnem\lzcork.bin	; LZ cork block
		even
Nem_LzBlock1:	incbin	artnem\lzblock1.bin	; LZ 32x32 block
		even
Nem_Gargoyle:	incbin	artnem\lzgargoy.bin	; LZ gargoyle head and spitting fire
		even
; ---------------------------------------------------------------------------
; Compressed graphics - MZ stuff
; ---------------------------------------------------------------------------
Nem_MzMetal:	incbin	artnem\mzmetal.bin	; MZ metal blocks
		even
Nem_MzSwitch:	incbin	artnem\mzswitch.bin	; MZ switch
		even
Nem_MzGlass:	incbin	artnem\mzglassy.bin	; MZ green glassy block
		even
Nem_MzFire:	incbin	artnem\mzfire.bin	; MZ fireballs
		even
Nem_Lava:	incbin	artnem\mzlava.bin	; MZ lava
		even
Nem_MzBlock:	incbin	artnem\mzblock.bin	; MZ green pushable block
		even
; ---------------------------------------------------------------------------
; Compressed graphics - SLZ stuff
; ---------------------------------------------------------------------------
Nem_Seesaw:	incbin	artnem\slzseesa.bin	; SLZ seesaw
		even
Nem_SlzSpike:	incbin	artnem\slzspike.bin	; SLZ spikeball that sits on a seesaw
		even
Nem_Fan:	incbin	artnem\slzfan.bin	; SLZ fan
		even
Nem_SlzWall:	incbin	artnem\slzwall.bin	; SLZ smashable wall
		even
Nem_Pylon:	incbin	artnem\slzpylon.bin	; SLZ foreground pylon
		even
Nem_SlzSwing:	incbin	artnem\slzswing.bin	; SLZ swinging platform
		even
Nem_SlzBlock:	incbin	artnem\slzblock.bin	; SLZ 32x32 block
		even
Nem_SlzCannon:	incbin	artnem\slzcanno.bin	; SLZ fireball launcher cannon
		even
; ---------------------------------------------------------------------------
; Compressed graphics - SYZ stuff
; ---------------------------------------------------------------------------
Nem_Bumper:	incbin	artnem\syzbumpe.bin	; SYZ bumper
		even
Nem_SyzSpike2:	incbin	artnem\syzsspik.bin	; SYZ small spikeball
		even
Nem_LzSwitch:	incbin	artnem\switch.bin	; LZ/SYZ/SBZ switch
		even
Nem_SyzSpike1:	incbin	artnem\syzlspik.bin	; SYZ/SBZ large spikeball
		even

; ---------------------------------------------------------------------------
; Compressed graphics - SBZ stuff
; ---------------------------------------------------------------------------
Nem_SbzWheel1:	incbin	artnem\sbzwhee1.bin	; SBZ spot on rotating wheel that Sonic runs around
		even
Nem_SbzWheel2:	incbin	artnem\sbzwhee2.bin	; SBZ wheel that grabs Sonic
		even
Nem_Cutter:	incbin	artnem\sbzcutte.bin	; SBZ pizza cutter
		even
Nem_Stomper:	incbin	artnem\sbzstomp.bin	; SBZ stomper
		even
Nem_SpinPform:	incbin	artnem\sbzpform.bin	; SBZ spinning platform
		even
Nem_TrapDoor:	incbin	artnem\sbztrapd.bin	; SBZ trapdoor
		even
Nem_SbzFloor:	incbin	artnem\sbzfloor.bin	; SBZ collapsing floor
		even
Nem_Electric:	incbin	artnem\sbzshock.bin	; SBZ electric shock orb
		even
Nem_SbzBlock:	incbin	artnem\sbzvanis.bin	; SBZ vanishing block
		even
Nem_FlamePipe:	incbin	artnem\sbzflame.bin	; SBZ flaming pipe
		even
Nem_SbzDoor1:	incbin	artnem\sbzvdoor.bin	; SBZ small vertical door
		even
Nem_SlideFloor:	incbin	artnem\sbzslide.bin	; SBZ floor that slides away
		even
Nem_SbzDoor2:	incbin	artnem\sbzhdoor.bin	; SBZ large horizontal door
		even
Nem_Girder:	incbin	artnem\sbzgirde.bin	; SBZ crushing girder
		even
; ---------------------------------------------------------------------------
; Compressed graphics - enemies
; ---------------------------------------------------------------------------
Nem_BallHog:	incbin	artnem\ballhog.bin	; ball hog
		even
Nem_Crabmeat:	incbin	artnem\crabmeat.bin	; crabmeat
		even
Nem_Buzz:	incbin	artnem\buzzbomb.bin	; buzz bomber
		even
Nem_Burrobot:	incbin	artnem\burrobot.bin	; burrobot
		even
Nem_Chopper:	incbin	artnem\chopper.bin	; chopper
		even
Nem_Jaws:	incbin	artnem\jaws.bin		; jaws
		even
Nem_Roller:	incbin	artnem\roller.bin	; roller
		even
Nem_Motobug:	incbin	artnem\motobug.bin	; moto bug
		even
Nem_Newtron:	incbin	artnem\newtron.bin	; newtron
		even
Nem_Yadrin:	incbin	artnem\yadrin.bin	; yadrin
		even
Nem_Basaran:	incbin	artnem\basaran.bin	; basaran
		even
Nem_Splats:	incbin	artnem\splats.bin	; splats
		even
Nem_Bomb:	incbin	artnem\bomb.bin		; bomb
		even
Nem_Orbinaut:	incbin	artnem\orbinaut.bin	; orbinaut
		even
Nem_Cater:	incbin	artnem\caterkil.bin	; caterkiller
		even
Nem_HSpring:	incbin	artnem\springh.bin	; horizontal spring
		even
Nem_VSpring:	incbin	artnem\springv.bin	; vertical spring
		even
Nem_Ring:	incbin	artnem\rings.bin	; rings
		even
Nem_Monitors:	incbin	artnem\monitors.bin	; monitors
		even
Nem_BigFlash:	incbin	artnem\rngflash.bin	; flash from giant ring
		even
Nem_Bonus:	incbin	artnem\bonus.bin	; hidden bonuses at end of a level
		even
Nem_Explode:	incbin	artnem\explosio.bin	; explosion
		even
Lives_Sonic:	incbin	artnem\lifeicon.bin	; life counter icon
		even
Lives_Knux:	incbin	artnem\knuxlifeicon.bin	; life counter icon
		even
Lives_Tails:	incbin	artnem\tailslifeicon.bin; life counter icon
		even
Nem_Points:	incbin	artnem\points.bin	; points from destroyed enemy or object
		even
Nem_GameOver:	incbin	artnem\gameover.bin	; game over / time over
		even
Nem_SignPost:	incbin	artnem\signpost.bin	; end of level signpost
		even
Nem_Lamp:	incbin	artnem\lamppost.bin	; lamppost
		even

Nem_TitleCard:	incbin	artunc\titlecards.unc	; title cards
		even
Nem_Hud:	incbin	artnem\hud.bin		; HUD (rings, time, score)
		even
; ---------------------------------------------------------------------------
; Compressed graphics - animals
; ---------------------------------------------------------------------------

Nem_Rabbit:	incbin	artnem\rabbit.bin	; rabbit
		even

LBZbossArt1:	incbin	boss/LBZtiles1.kos
		even
LBZbossArt2:	incbin	boss/LBZtiles2.kos
		even
LBZbossArt3:	incbin	boss/LBZtiles3.kos
		even
LBZbossArt4:	incbin	boss/LBZface.kos
		even

; ---------------------------------------------------------------------------
; Compressed graphics - various
; ---------------------------------------------------------------------------
SonArtInformLoc:
	align	$20000
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Sonic
; ---------------------------------------------------------------------------
Art_Sonic:	incbin	artunc\sonic.bin	; Sonic
		even

ArtSonInform:	equ	Art_Sonic-SonArtInformLoc
	inform 0,"Free space before location Art_Sonic is $\$ArtSonInform (Hex, \#ArtSonInform Dec) bytes"
	;	align	$20000
		org *-$e0
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Knuckles
; ---------------------------------------------------------------------------
Art_Knux:	incbin	artunc\knux.bin
		even
		align	$20000
; ---------------------------------------------------------------------------
; Uncompressed graphics	- tails
; ---------------------------------------------------------------------------
Art_Tails:	incbin	artunc\tails.bin
		even

ArtUnc_EndSigns:
	incbin 'artunc/End Signs.bin'
	even

ArtUnc_Instashield:
          incbin 'artunc/ArtUnc_Insta.bin'
	  even
ArtUnc_BubbleShield:
	  incbin 'artunc/ArtUnc_BubbleShield.bin'
	  even
ArtUnc_LighteningShield:
	  incbin 'artunc/ArtUnc_LighteningShield.bin'
	  even
ArtUnc_FireShield:
    	  incbin 'artunc/ArtUnc_FireShield.bin'
    	  even
Comp_Sparks:
          incbin 'artunc/Electricshield_Sparks.bin.comper'
    	  even
ArtComp_Shield:
	incbin 'artunc\shield.comper'
	even
ArtComp_MonShield:
	incbin 'artunc\monshield.comper'
	even

ArtKos_S3TitleSonic1:			incbin 's3k/Comper Art/Sonic 1.bin'
	even
ArtKos_S3TitleSonic8:			incbin 's3k/Comper Art/Sonic 8.bin'
	even
ArtKos_S3TitleSonic9:			incbin 's3k/Comper Art/Sonic 9.bin'
	even
ArtKos_S3TitleSonicA:			incbin 's3k/Comper Art/Sonic A.bin'
	even
ArtKos_S3TitleSonicB:			incbin 's3k/Comper Art/Sonic B.bin'
	even
ArtKos_S3TitleSonicD:			incbin 's3k/Comper Art/Sonic D.bin'
	even

Nem_Flicky:	incbin	artnem\flicky.bin	; flicky
		even
Nem_Squirrel:	incbin	artnem\squirrel.bin	; squirrel
		even
Nem_Seal:	incbin	artnem\seal.bin		; seal
		even
Nem_BlackBird:	incbin	artnem\blackbrd.bin	; blackbird
		even
Nem_Chicken:	incbin	artnem\chicken.bin	; chicken
		even
Nem_Pig:	incbin	artnem\pig.bin		; pig
		even

Nem_PortalTurret:incbin "artnem\portalturret.bin"
		even
Nem_Eggmate	incbin "artnem\eggmate.bin"
		even
Nem_EggLogo:	incbin "artnem\eggicon.bin"
		even
Nem_Eggman:	incbin	artnem\bossmain.bin	; boss main patterns
		even
Nem_Weapons:	incbin	artnem\bossxtra.bin	; boss add-ons and weapons
		even
Nem_Exhaust:	incbin	artnem\bossflam.bin	; boss exhaust flame
		even
; ---------------------------------------------------------------------------
; Compressed graphics - primary patterns and block mappings
; ---------------------------------------------------------------------------
Blk16_ow:	incbin	map16\ow.bin
		even
Nem_ow: 	incbin	artnem\8x8ow.bin	; GHZ primary patterns
		even
Blk256_ow:	incbin	map256\ow.bin
		even
Blk16_GHZ:	incbin	map16\ghz.bin
		even
Nem_GHZ:	incbin	artnem\8x8ghz.bin	; GHZ primary patterns
		even
Blk256_GHZ:	incbin	map256\ghz.bin
		even
Blk16_LZ:	incbin	map16\lz.bin
		even
Nem_LZ:		incbin	artnem\8x8lz.bin	; LZ primary patterns
		even
Blk256_LZ:	incbin	map256\lz.bin
		even
Blk16_MZ:	incbin	map16\mz.bin
		even
Nem_MZ:		incbin	artnem\8x8mz.bin	; MZ primary patterns
		even
Blk256_MZ:	incbin	map256\mz.bin
		even
Blk16_SLZ:	incbin	map16\slz.bin
		even
Nem_SLZ:	incbin	artnem\8x8slz.bin	; SLZ primary patterns
		even
Blk256_SLZ:	incbin	map256\slz.bin
		even
Blk16_SYZ:	incbin	map16\syz.bin
		even
Nem_SYZ:	incbin	artnem\8x8syz.bin	; SYZ primary patterns
		even
Blk256_SYZ:	incbin	map256\syz.bin
		even
Blk16_SBZ:	incbin	map16\sbz.bin
		even
Nem_SBZ:	incbin	artnem\8x8sbz.bin	; SBZ primary patterns
		even
Blk256_SBZ:	incbin	map256\sbz.bin
		even

ArtKos_S3TitleSonicC:			incbin 's3k/Comper Art/Sonic C.bin'
	even

; ---------------------------------------------------------------------------
; Compressed graphics - bosses and ending sequence
; ---------------------------------------------------------------------------
Unc_arrowgfx:	incbin "artunc\arrow.bin"
		even
Nem_FzBoss:	incbin	artnem\fzboss.bin	; FZ boss
		even
Nem_FzEggman:	incbin	artnem\fzboss2.bin	; Eggman after the FZ boss
		even
Nem_Prison:	incbin	artnem\prison.bin	; prison capsule
		even
Nem_Sbz2Eggman:	incbin	artnem\sbz2boss.bin	; Eggman in SBZ2 and FZ
		even
; ---------------------------------------------------------------------------
; Collision data
; ---------------------------------------------------------------------------
AngleMap:	incbin	collide\anglemap.bin	; floor angle map
		even
AngleMap_s2:	incbin	collide\anglemap2.bin	; floor angle map
		even
CollArray1:	incbin	collide\carray_n.bin	; normal collision array
		even
CollArray2:	incbin	collide\carray_r.bin	; rotated collision array
		even
CollArray1_s2:	incbin	collide\array21.bin	; normal collision array
		even
CollArray2_s2:	incbin	collide\array22.bin	; rotated collision array
		even
Col_GHZ_1:	incbin	collide\ghz1.bin	; GHZ index 1
		even
Col_GHZ_2:	incbin	collide\ghz2.bin	; GHZ index 2
		even
Col_LZ_1:	incbin	collide\lz1.bin		; LZ index 1
		even
Col_LZ_2:	incbin	collide\lz2.bin		; LZ index 2
		even
Col_MZ_1:	incbin	collide\mz1.bin		; MZ index 1
		even
Col_MZ_2:	incbin	collide\mz2.bin		; MZ index 2
		even
Col_SLZ_1:	incbin	collide\slz1.bin	; SLZ index 1
		even
Col_SLZ_2:	incbin	collide\slz2.bin	; SLZ index 2
		even
Col_SYZ_1:	incbin	collide\syz1.bin	; SYZ index 1
		even
Col_SYZ_2:	incbin	collide\syz2.bin	; SYZ index 2
		even
Col_SBZ_1:	incbin	collide\sbz1.bin	; SBZ index 1
		even
Col_SBZ_2:	incbin	collide\sbz2.bin	; SBZ index 2
		even
Col_ow_1:	incbin	collide\ow1.bin	; SBZ index 1
		even
Col_ow_2:	incbin	collide\ow2.bin	; SBZ index 2
		even

; ---------------------------------------------------------------------------
; Animated uncompressed graphics
; ---------------------------------------------------------------------------
Art_GhzWater:	incbin	artunc\ghzwater.bin	; GHZ waterfall
		even
Art_GhzFlower1:	incbin	artunc\ghzflowl.bin	; GHZ large flower
		even
Art_GhzFlower2:	incbin	artunc\ghzflows.bin	; GHZ small flower
		even
Art_MzLava1:	incbin	artunc\mzlava1.bin	; MZ lava surface
		even
Art_MzLava2:	incbin	artunc\mzlava2.bin	; MZ lava
		even
	include "#Natsumi/Screen.asm"
Art_MzTorch:	incbin	artunc\mztorch.bin	; MZ torch in background
		even
Art_SbzSmoke:	incbin	artunc\sbzsmoke.bin	; SBZ smoke in background
		even
; --------------------------------------------------------------------------
; Level	layout index
; ---------------------------------------------------------------------------
Level_Index:	dc.l Level_GHZ1, Level_GHZ2, Level_GHZ3, Level_GHZ4, Level_GHZ1, Level_GHZ2, Level_GHZ3, Level_GHZ1
		dc.l Level_LZ1, Level_LZ2, Level_LZ3, Level_SBZ3, Level_LZ1, Level_LZ6, Level_LZ3, Level_SBZ3
		dc.l Level_MZ1, Level_MZ2, Level_MZ3, Level_MZ4, Level_MZ1, Level_MZ2, Level_MZ3, Level_MZ4
		dc.l Level_SLZ1, Level_SLZ2, Level_SLZ3, Level_SLZ4, Level_SLZ1, Level_SLZ2, Level_SLZ3, Level_SLZ4
		dc.l Level_SYZ1, Level_SYZ2, Level_SYZ3, Level_SYZ4, Level_SYZ1, Level_SYZ2, Level_SYZ3, Level_SYZ4
		dc.l Level_SBZ1, Level_SBZ2, Level_SBZ2, Level_SBZ4, Level_SBZ1, Level_SBZ2, Level_SBZ2, Level_SBZ4
		dc.l Level_End, Level_End, Level_End, Level_End, Level_End, Level_End, Level_End, Level_End
		dc.l Level_ow, Level_ow, Level_ow, Level_ow, Level_ow, Level_ow, Level_ow, Level_ow
byte_68D70:	dc.b 0,	0, 0, 0
Level_ow:	incbin	levels\ow1.bin
		even
Level_ow2:	incbin	levels\ow2.bin
		even
Level_GHZ1:	incbin	levels\ghz1.bin
		even
Level_GHZ2:	incbin	levels\ghz2.bin
		even
Level_GHZ3:	incbin	levels\ghz3.bin
		even
Level_GHZ4:	incbin	levels\ghz4.bin
		even
Level_LZ1:	incbin	levels\lz1.bin
		even
Level_LZ2:	incbin	levels\lz2.bin
		even
Level_LZ3:	incbin	levels\lz3.bin
		even
Level_LZ3_WALL:	incbin	levels\lz3_wall.bin	; MJ: layout with LZ's wall change (When the switch is pressed) data is not in ram anymore,
		even				; and altering values in rom is prohibited, so a new layout is loaded in its place.
Level_LZ6:	incbin	levels\lz6.bin
		even
Level_SBZ3:	incbin	levels\sbz3.bin
		even
Level_MZ1:	incbin	levels\mz1.bin
		even
Level_MZ2:	incbin	levels\mz2.bin
		even
Level_MZ2_Fall:	incbin	levels\mz2_fall.bin
		even
Level_MZ3:	incbin	levels\mz3.bin
		even
Level_MZ4:	incbin	levels\mz4.bin
		even
Level_SLZ1:	incbin	levels\slz1.bin
		even
Level_SLZ2:	incbin	levels\slz2.bin
		even
Level_SLZ3:	incbin	levels\slz3.bin
		even
Level_SLZ4:	incbin	levels\slz4.bin
		even
Level_SYZ1:	incbin	levels\syz1.bin
		even
Level_SYZ2:	incbin	levels\syz2.bin
		even
Level_SYZ3:	incbin	levels\syz3.bin
		even
Level_SYZ4:	incbin	levels\syz4.bin
		even
Level_SBZ1:	incbin	levels\sbz1.bin
		even
Level_SBZ2:	incbin	levels\sbz2.bin
		even
Level_SBZ4:	incbin	levels\sbz4.bin
		even
Level_End:	incbin	levels\ending.bin
		even

; ---------------------------------------------------------------------------
; Animated uncompressed giant ring graphics
; ---------------------------------------------------------------------------
Art_BigRing:	incbin	artunc\bigring.bin
		even

; ---------------------------------------------------------------------------
; Sprite locations index
; ---------------------------------------------------------------------------
ObjPos_Index:	dc.w ObjPos_GHZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GHZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GHZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GHZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GHZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GHZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GHZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GHZ7-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_LZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_LZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_LZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_LZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_LZ6-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_LZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_MZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_MZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_MZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_MZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_MZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_MZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_MZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_MZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SYZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SYZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SYZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SYZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SYZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SYZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SYZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SYZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FZ-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FZ-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_OW-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
Objpos_index_LZpf:
                dc.w ObjPos_LZ1pf1-Objpos_index_LZpf, ObjPos_LZ1pf2-Objpos_index_LZpf
		dc.w ObjPos_LZ2pf1-Objpos_index_LZpf, ObjPos_LZ2pf2-Objpos_index_LZpf
		dc.w ObjPos_LZ3pf1-Objpos_index_LZpf, ObjPos_LZ3pf2-Objpos_index_LZpf
		dc.w ObjPos_LZ1pf1-Objpos_index_LZpf, ObjPos_LZ1pf2-Objpos_index_LZpf
Objpos_index_SBZpf:
                dc.w ObjPos_SBZ1pf1-Objpos_index_SBZpf, ObjPos_SBZ1pf2-Objpos_index_SBZpf
		dc.w ObjPos_SBZ1pf3-Objpos_index_SBZpf, ObjPos_SBZ1pf4-Objpos_index_SBZpf
		dc.w ObjPos_SBZ1pf5-Objpos_index_SBZpf, ObjPos_SBZ1pf6-Objpos_index_SBZpf
		dc.w ObjPos_SBZ1pf1-Objpos_index_SBZpf, ObjPos_SBZ1pf2-Objpos_index_SBZpf
		dc.b $FF, $FF, 0, 0, 0,	0
ObjPos_GHZ1:	incbin	objpos\ghz1.bin
		even
ObjPos_GHZ2:	incbin	objpos\ghz2.bin
		even
ObjPos_GHZ3:	incbin	objpos\ghz3.bin
		even
ObjPos_GHZ4:	incbin	objpos\ghz4.bin
		even
ObjPos_GHZ7:	incbin	objpos\ghz7.bin
		even
ObjPos_LZ1:	incbin	objpos\lz1.bin
		even
ObjPos_LZ2:	incbin	objpos\lz2.bin
		even
ObjPos_LZ3:	incbin	objpos\lz3.bin
		even
ObjPos_SBZ3:	incbin	objpos\sbz3.bin
		even
ObjPos_LZ6:	incbin	objpos\lz6.bin
		even
ObjPos_LZ1pf1:	incbin	objpos\lz1pf1.bin
		even
ObjPos_LZ1pf2:	incbin	objpos\lz1pf2.bin
		even
ObjPos_LZ2pf1:	incbin	objpos\lz2pf1.bin
		even
ObjPos_LZ2pf2:	incbin	objpos\lz2pf2.bin
		even
ObjPos_LZ3pf1:	incbin	objpos\lz3pf1.bin
		even
ObjPos_LZ3pf2:	incbin	objpos\lz3pf2.bin
		even
ObjPos_MZ1:	incbin	objpos\mz1.bin
		even
ObjPos_MZ2:	incbin	objpos\mz2.bin
		even
ObjPos_MZ3:	incbin	objpos\mz3.bin
		even
ObjPos_MZ4:	incbin	objpos\mz4.bin
		even
ObjPos_SLZ1:	incbin	objpos\slz1.bin
		even
ObjPos_SLZ2:	incbin	objpos\slz2.bin
		even
ObjPos_SLZ3:	incbin	objpos\slz3.bin
		even
ObjPos_SLZ4:	incbin	objpos\slz4.bin
		even
ObjPos_SYZ1:	incbin	objpos\syz1.bin
		even
ObjPos_SYZ2:	incbin	objpos\syz2.bin
		even
ObjPos_SYZ3:	incbin	objpos\syz3.bin
		even
ObjPos_SYZ4:	incbin	objpos\syz4.bin
		even
ObjPos_SBZ1:	incbin	objpos\sbz1.bin
		even
ObjPos_SBZ2:	incbin	objpos\sbz2.bin
		even
ObjPos_FZ:	incbin	objpos\fz.bin
		even
ObjPos_SBZ4:	incbin	objpos\sbz4.bin
		even
ObjPos_OW:	incbin	objpos\ow1.bin
		even
ObjPos_SBZ1pf1:	incbin	objpos\sbz1pf1.bin
		even
ObjPos_SBZ1pf2:	incbin	objpos\sbz1pf2.bin
		even
ObjPos_SBZ1pf3:	incbin	objpos\sbz1pf3.bin
		even
ObjPos_SBZ1pf4:	incbin	objpos\sbz1pf4.bin
		even
ObjPos_SBZ1pf5:	incbin	objpos\sbz1pf5.bin
		even
ObjPos_SBZ1pf6:	incbin	objpos\sbz1pf6.bin
		even
ObjPos_End:	incbin	objpos\ending.bin
		even
ObjPos_Null:	dc.b $FF, $FF, 0, 0, 0,	0

; ---------------------------------------------------------------------------
	even
		include 'SMPS\swa.smps.asm'

Go_SoundPriorities:
Go_SoundTypes:	dc.l SoundPriorities
Go_MusicIndex:		dc.l MusicIndex
Go_MusicIndex_E5toFF:	dc.l MusicIndex_E5plus	; XREF: Sound_81to9F
Go_SoundIndex:		dc.l SoundIndex
Go_SpeedUpIndex:	dc.l SpeedUpIndex
Go_PSGIndex:		dc.l PSG_Index

; ---------------------------------------------------------------------------
; PSG instruments used in music
; ---------------------------------------------------------------------------

PSG_Index:
		dc.l PSG1, PSG2, PSG3
		dc.l PSG4, PSG5, PSG6
		dc.l PSG7, PSG8, PSG9
PSG1:		incbin	"sound/psg1.bin"
PSG2:		incbin	"sound/psg2.bin"
PSG3:		incbin	"sound/psg3.bin"
PSG4:		incbin	"sound/psg4.bin"
PSG6:		incbin	"sound/psg6.bin"
PSG5:		incbin	"sound/psg5.bin"
PSG7:		incbin	"sound/psg7.bin"
PSG8:		incbin	"sound/psg8.bin"
PSG9:		incbin	"sound/psg9.bin"

; ---------------------------------------------------------------------------
; New tempos for songs during speed shoes
; ---------------------------------------------------------------------------
; DANGER! several songs will use the first few bytes of MusicIndex as their main
; tempos while speed shoes are active. If you don't want that, you should add
; their "correct" sped-up main tempos to the list.
; ---------------------------------------------------------------------------

SpeedUpIndex:	dc.b 7,	$72, $73, $26, $15, 8, $FF, 5

; ---------------------------------------------------------------------------
; Priority of sound. New music or SFX must have a priority higher than or equal
; to what is stored in v_sndprio or it won't play. If bit 7 of new priority is
; set ($80 and up), the new music or SFX will not set its priority -- meaning
; any music or SFX can override it (as long as it can override whatever was
; playing before). Usually, SFX will only override SFX, special SFX ($D0-$DF)
; will only override special SFX and music will only override music.
; ---------------------------------------------------------------------------

SoundPriorities:
  dc.b $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90
  dc.b $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $80
  dc.b $70, $70, $70, $70, $70, $70, $70, $70, $70, $68, $70, $70, $70, $60, $70, $70
  dc.b $60, $70, $60, $70, $70, $70, $70, $70, $70, $70, $70, $70, $70, $70, $7F, $60
  dc.b $70, $70, $70, $70, $70, $70, $70, $70, $70, $70, $70, $70, $70, $70, $70, $80
  dc.b $80, $80, $80, $80, $80, $80, $80, $80, $80, $80, $80, $80, $80, $80, $80, $90
  dc.b $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90
  dc.b $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90
  dc.b $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90
; ---------------------------------------------------------------------------
; Music	Pointers
; ---------------------------------------------------------------------------

MusicIndex:	dc.l Music81, Music82
		dc.l Music83, Music84
		dc.l Music85, Music86
		dc.l Music87, Music88
		dc.l Music89, Music8A
		dc.l Music8B, Music8C
		dc.l Music8D, Music8E
		dc.l Music8F, Music90
		dc.l Music91, Music92
		dc.l Music93

MusicIndex_E5plus:
                dc.l MusicE5, MusicE6
		dc.l MusicE7, MusicE8
		dc.l MusicE9, MusicEA
		dc.l MusicEB, MusicEC
		dc.l MusicED, MusicEE
		dc.l MusicEF, MusicF0
		dc.l MusicF1, MusicF2
		dc.l MusicF3, MusicF4
                dc.l MusicF5, MusicF6
		dc.l MusicF7, MusicF8
		dc.l MusicF9, MusicFA
		dc.l MusicFB, MusicFC
		dc.l MusicFD, MusicFE
		dc.l MusicFF

Music81:	incbin	sound\music81.bin
		even
Music82:	incbin	sound\music82.bin
		even
Music83:	incbin	sound\music83.bin
		even
Music84:	incbin	sound\music84.bin
		even
Music85:	incbin	sound\music85.bin
		even
Music86:	incbin	sound\music86.bin
		even
Music87:	incbin	sound\music87.bin
		even
Music88:	incbin	sound\music88.bin
		even
Music89:	incbin	sound\music89.bin
		even
Music8A:	incbin	sound\music8A.bin
		even
Music8B:	incbin	sound\music8B.bin
		even
Music8C:	incbin	sound\music8C.bin
		even
Music8D:	incbin	sound\music8D.bin
		even
Music8E:	incbin	sound\music8E.bin
		even
Music8F:	incbin	sound\music8F.bin
		even
Music90:	incbin	sound\music90.bin
		even
Music91:	incbin	sound\music91.bin
		even
Music92:	incbin	sound\music92.bin
		even
Music93:	incbin	sound\music93.bin
		even


MusicE5:	include	sound\slots.asm			; EB
		even
MusicE6:	include	sound\S3KSpecialStage.asm 	; EB
		even
MusicE7:	include	sound\MMX_Sigma_Fortress_1.asm 	; DalekSam
		even
MusicE8:	include	sound\Sonic3title.asm		; EB
		even
MusicE9:	include	sound\TF3_BossRemix_by_vladikcomper.asm	; vlad
		even
MusicEA:	include	sound\Z80_BGM_0C.asm			; vlad
		even
MusicEB:	include	sound\Z80_BGM_No_time_to_loose.asm	; vlad
		even
MusicEC:	include	sound\Z80_MusicBank_2_Boss_10.asm	; vlad		; thunderforce 4 boss 10
		even
MusicED:	include	sound\Z80_MusicBank_2_Boss_5.asm	; vlad
		even
MusicEE:	include	sound\TF4_BossRemaster_by_vladikcomper.asm	; vlad ; <- boss 5
		even
MusicEF:	include	sound\fullretreat.asm	; vlad
		even
MusicF0:	include	sound\Z80_MusicBank_1_Stage_7.asm	; vlad
		even
MusicF1:	include	sound\TF3_boss2.asm	; vlad
		even
MusicF2:	include	sound\TF_st5.asm	; vlad
		even
MusicF3:	include	sound\TF4_Configuration.asm	; vlad
		even
MusicF4:	include	sound\em00.asm	; vlad
		even
MusicF5:	include	sound\em08.asm	; vlad
		even
MusicF6:	include	sound\em22.asm	; vlad
		even
MusicF7:	include	sound\Z80_BGM_Jagd_flieger.asm	; vlad
		even
MusicF8:	include	sound\puppet.asm
		even
MusicF9:	include	sound\rdw.asm
		even
MusicFA:	include	sound\whirlwind.asm	; me
		even
MusicFB:	include	sound\introduce.asm	; yuu yuu hakusho
		even
MusicFC:	include	sound\unmelt.asm	; yuu yuu hakusho
		even
MusicFD:	incbin	sound\musicF0.bin 	; STD
		even
MusicFE:	incbin	sound\musicE9.bin 	; STD
		even
MusicFF:	incbin	sound\trance.bin	; STD
		even

; ---------------------------------------------------------------------------
; Sound	effect pointers
; ---------------------------------------------------------------------------

SoundIndex:
                dc.l Sound94, Sound95, Sound96
                dc.l Sound97, Sound98, Sound99
                dc.l Sound9A, Sound9B, Sound9C
                dc.l Sound9D, Sound9E, Sound9F
                dc.l SoundA0, SoundA1, SoundA2
		dc.l SoundA3, SoundA4, SoundA5
		dc.l SoundA6, SoundA7, SoundA8
		dc.l SoundA9, SoundAA, SoundAB
		dc.l SoundAC, SoundAD, SoundAE
		dc.l SoundAF, SoundB0, SoundB1
		dc.l SoundB2, SoundB3, SoundB4
		dc.l SoundB5, SoundB6, SoundB7
		dc.l SoundB8, SoundB9, SoundBA
		dc.l SoundBB, SoundBC, SoundBD
		dc.l SoundBE, SoundBF, SoundC0
		dc.l SoundC1, SoundC2, SoundC3
		dc.l SoundC4, SoundC5, SoundC6
		dc.l SoundC7, SoundC8, SoundC9
		dc.l SoundCA, SoundCB, SoundCC
		dc.l SoundCD, SoundCE, SoundCF
		dc.l SoundD1
go_soundd0:	dc.l SoundD0

SoundD1:	incbin	sound\soundD1.bin
		even
SoundD0:	incbin	sound\soundD0.bin
		even
SoundCF:	incbin	sound\soundCF.bin
		even
SoundC9:	incbin	sound\soundC9.bin
		even
SoundCA:	incbin	sound\soundCA.bin
		even
SoundCB:	incbin	sound\soundCB.bin
		even
SoundCC:	incbin	sound\soundCC.bin
		even
SoundCD:	incbin	sound\soundCD.bin
		even
SoundCE:	incbin	sound\soundCE.bin
		even
SoundC0:	incbin	sound\soundC0.bin
		even
SoundC1:	incbin	sound\soundC1.bin
		even
SoundC2:	incbin	sound\soundC2.bin
		even
SoundC3:	incbin	sound\soundC3.bin
		even
SoundC4:	incbin	sound\soundC4.bin
		even
SoundC5:	incbin	sound\soundC5.bin
		even
SoundC6:	incbin	sound\soundC6.bin
		even
SoundC7:	incbin	sound\soundC7.bin
		even
Sound94:        incbin	sound\sound94.bin    ; score
		even
Sound95:        incbin	sound\sound95.bin    ; tails fly
		even

Sound96:        incbin	sound\sound96.bin    ; tails tired
		even
Sound97:        incbin	sound\sound97.bin    ; knux wall
		even
Sound98:        incbin	sound\sound98.bin    ; knux ground
		even
Sound99:        incbin	sound\sound99.bin    ; s3k no
		even
Sound9a:	incbin	sound\sound9A.bin	; S3K ligteningshield doublejump sfx
		even
Sound9b:	incbin	sound\sound9B.bin	; S3K Bubbleshield got SFX
		even
Sound9c:
Sound9d:
Sound9e:
Sound9f:
SoundA0:	incbin	sound\soundA0.bin
		even
SoundA1:	incbin	sound\soundA1.bin
		even
SoundA2:	incbin	sound\soundA2.bin
		even
SoundA3:	incbin	sound\soundA3.bin
		even
SoundA4:	incbin	sound\soundA4.bin
		even
SoundA5:	incbin	sound\soundA5.bin
		even
SoundA6:	incbin	sound\soundA6.bin
		even
SoundA7:	incbin	sound\soundA7.bin
		even
SoundA8:	incbin	sound\soundA8.bin
		even
SoundA9:	incbin	sound\soundA9.bin
		even
SoundAA:	incbin	sound\soundAA.bin
		even
SoundAB:	incbin	sound\soundAB.bin
		even
SoundAC:	incbin	sound\soundAC.bin
		even
SoundAD:	incbin	sound\soundAD.bin
		even
SoundAE:	incbin	sound\soundAE.bin
		even
SoundAF:	incbin	sound\soundAF.bin
		even
SoundB0:	incbin	sound\soundB0.bin
		even
SoundB1:	incbin	sound\soundB1.bin
		even
SoundB2:	incbin	sound\soundB2.bin
		even
SoundB3:	incbin	sound\soundB3.bin
		even
SoundC8:	incbin	sound\soundC8.bin
		even
SoundB4:	incbin	sound\soundB4.bin
		even
SoundB5:	incbin	sound\soundB5.bin
		even
SoundB6:	incbin	sound\soundB6.bin
		even
SoundB7:	incbin	sound\soundB7.bin
		even
SoundB8:	incbin	sound\soundB8.bin
		even
SoundB9:	incbin	sound\soundB9.bin
		even
SoundBA:	incbin	sound\soundBA.bin
		even
SoundBB:	incbin	sound\soundBB.bin
		even
SoundBC:	incbin	sound\soundBC.bin
		even
SoundBD:	incbin	sound\soundBD.bin
		even
SoundBE:	incbin	sound\soundBE.bin
		even
SoundBF:	incbin	sound\soundBF.bin
		even

	include "#SSRG/SSRG_Screen.asm"
	even
	include "dostext.asm"
	include "TrumpQuote/Trump.asm"

		align 4
		include 'MegaPCM.asm'
Samples_End:	even
Samples_Size:	equ	Samples_End-MegaPCM_End

		inform 0,"PCM samples takes $\$Samples_Size (Hex, \#Samples_Size Dec) bytes of Space."

	inform	0," "	; spend 1 line for nothing, to make it easier see the errors
EndOfRom:
		END
